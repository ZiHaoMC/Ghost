Ghost.java:
package com.zihaomc.ghost;

import com.zihaomc.ghost.features.autocraft.AutoCraftCommand;
import com.zihaomc.ghost.features.automine.AutoMineCommand;
import com.zihaomc.ghost.features.ghostblock.GhostBlockCommand;
import com.zihaomc.ghost.commands.GhostConfigCommand;
import com.zihaomc.ghost.features.pathfinding.PathfindingCommand; 
import com.zihaomc.ghost.features.pathfinding.PathfindingHandler; 
import com.zihaomc.ghost.features.translation.TranslateCommand;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.features.autocraft.AutoCraftHandler;
import com.zihaomc.ghost.features.autocraft.AutoCraftRecipeManager;
import com.zihaomc.ghost.features.automine.AutoMineHandler;
import com.zihaomc.ghost.handlers.*;
import com.zihaomc.ghost.features.ghostblock.GhostBlockEventHandler;
import com.zihaomc.ghost.features.chat.ChatInputHandler;
import com.zihaomc.ghost.features.chat.CommandSuggestionHandler;
import com.zihaomc.ghost.features.translation.ChatTranslationHandler;
import com.zihaomc.ghost.features.translation.CacheSavingHandler;
import com.zihaomc.ghost.features.translation.ItemTooltipTranslationHandler;
import com.zihaomc.ghost.features.translation.SignTranslationHandler;
import com.zihaomc.ghost.features.autosneak.AutoSneakHandler;
import com.zihaomc.ghost.features.automine.AutoMineTargetManager;
import com.zihaomc.ghost.features.playeresp.PlayerESPHandler;
import com.zihaomc.ghost.features.gameplay.FastPistonBreakingHandler;
import com.zihaomc.ghost.features.visual.PlayerArrowRendererHandler;
import com.zihaomc.ghost.proxy.CommonProxy;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.init.Blocks;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.SidedProxy;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.client.ClientCommandHandler;
import net.minecraftforge.common.MinecraftForge;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;

/**
 * Ghost Mod 的主类。
 * 负责 Mod 的加载、初始化、事件注册和命令注册。
 */

@Mod(modid = Ghost.MODID, name = Ghost.NAME, version = Ghost.VERSION, acceptableRemoteVersions = "*")
public class Ghost {

    public static final String MODID = "ghost";
    public static final String VERSION = "0.1.1";
    public static final String NAME = "Ghost";
    public static final Logger logger = LogManager.getLogger(MODID);

    @Mod.Instance(MODID)
    public static Ghost instance;

    @SidedProxy(clientSide = "com.zihaomc.ghost.proxy.ClientProxy", serverSide = "com.zihaomc.ghost.proxy.ServerProxy")
    public static CommonProxy proxy;

    @Mod.EventHandler
    public void preInit(FMLPreInitializationEvent event) {
        LogUtil.info("log.lifecycle.preinit", NAME);
        Blocks.fire.toString();

        File configFile = event.getSuggestedConfigurationFile();
        GhostConfig.init(configFile);

        proxy.preInit(event);

        if (event.getSide() == Side.CLIENT) {
            ItemTooltipTranslationHandler.loadCacheFromFile();
            
            // --- 事件总线注册 ---
            
            // 1. 缓存保存
            MinecraftForge.EVENT_BUS.register(new CacheSavingHandler());
            LogUtil.debug("log.feature.cache.init");
            
            // 2. 聊天相关
            MinecraftForge.EVENT_BUS.register(new ChatInputHandler());
            MinecraftForge.EVENT_BUS.register(new CommandSuggestionHandler());
            LogUtil.debug("log.handler.registered.chatSuggest");

            // 3. 翻译相关
            MinecraftForge.EVENT_BUS.register(new ChatTranslationHandler());
            MinecraftForge.EVENT_BUS.register(new SignTranslationHandler());
            MinecraftForge.EVENT_BUS.register(new ItemTooltipTranslationHandler());
            LogUtil.debug("log.handler.registered.translation");

            // 4. 其他功能
            MinecraftForge.EVENT_BUS.register(new AutoSneakHandler());
            LogUtil.debug("log.handler.registered.autoSneak");

            MinecraftForge.EVENT_BUS.register(new PlayerESPHandler());
            LogUtil.debug("log.handler.registered.playerEsp");
            
            MinecraftForge.EVENT_BUS.register(new FastPistonBreakingHandler());
            LogUtil.debug("log.handler.registered.fastPiston");

            MinecraftForge.EVENT_BUS.register(new PlayerArrowRendererHandler());
            LogUtil.debug("log.handler.registered.playerArrow");

            MinecraftForge.EVENT_BUS.register(new KeybindHandler());
            LogUtil.debug("log.handler.registered.keybind");
            
            MinecraftForge.EVENT_BUS.register(new AutoMineHandler());
            LogUtil.debug("log.handler.registered.autoMine");

            MinecraftForge.EVENT_BUS.register(new AutoCraftHandler());
            LogUtil.debug("log.handler.registered.autoCraft");
            
            MinecraftForge.EVENT_BUS.register(new GhostBlockEventHandler());
            LogUtil.debug("log.handler.registered.ghostBlockCommand");

            MinecraftForge.EVENT_BUS.register(new PathfindingHandler()); // 注册寻路事件
            LogUtil.debug("log.handler.registered.pathfinding");
        }
    }

    @Mod.EventHandler
    public void init(FMLInitializationEvent event) {
        LogUtil.info("log.lifecycle.init", NAME);

        proxy.init(event);
        
        ItemTooltipTranslationHandler.loadCacheFromFile();
        AutoMineTargetManager.loadTargets();
        AutoCraftRecipeManager.initialize();

        if (event.getSide() == Side.CLIENT) {
            try {
                AutoMineHandler.MiningMode mode = AutoMineHandler.MiningMode.valueOf(GhostConfig.AutoMine.miningMode.toUpperCase());
                AutoMineHandler.setCurrentMiningMode_noMessage(mode);
            } catch (IllegalArgumentException e) {
                LogUtil.warn("log.config.invalid.automineMode", GhostConfig.AutoMine.miningMode);
                AutoMineHandler.setCurrentMiningMode_noMessage(AutoMineHandler.MiningMode.SIMULATE);
            }
            
            LogUtil.debug("log.command.registering.client");
            
            ClientCommandHandler.instance.registerCommand(new GhostBlockCommand());
            LogUtil.debug("log.command.registered.cgb");
            
            ClientCommandHandler.instance.registerCommand(new GhostConfigCommand());
            LogUtil.debug("log.command.registered.ghostConfig");

            ClientCommandHandler.instance.registerCommand(new TranslateCommand());
            LogUtil.debug("log.command.registered.gtranslate");

            ClientCommandHandler.instance.registerCommand(new AutoMineCommand());
            LogUtil.debug("log.command.registered.autoMine");

            ClientCommandHandler.instance.registerCommand(new AutoCraftCommand());
            LogUtil.debug("log.command.registered.autoCraft");

            ClientCommandHandler.instance.registerCommand(new PathfindingCommand()); // 注册寻路命令
            LogUtil.debug("log.command.registered.gpath");

        } else {
            LogUtil.debug("log.command.skipping.server");
        }
    }

    @Mod.EventHandler
    public void postInit(FMLPostInitializationEvent event) {
        LogUtil.info("log.lifecycle.postinit", NAME);
        proxy.postInit(event);
    }
}

LangUtil.java:
package com.zihaomc.ghost;

import net.minecraft.client.resources.I18n;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class LangUtil {
    public static String translate(String key, Object... args) {
        return I18n.format(key, args);
    }
}


proxy/ClientProxy.java:
package com.zihaomc.ghost.proxy;

import com.zihaomc.ghost.handlers.KeybindHandler;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;

public class ClientProxy extends CommonProxy {
    @Override
    public void preInit(FMLPreInitializationEvent event) {
        super.preInit(event);
    }

    @Override
    public void init(FMLInitializationEvent event) {
        super.init(event);
        // 初始化并注册按键绑定
        KeybindHandler.registerKeybinds();
    }

    @Override
    public void postInit(FMLPostInitializationEvent event) {
        super.postInit(event);
    }
}

proxy/ServerProxy.java:
package com.zihaomc.ghost.proxy;

import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;

public class ServerProxy extends CommonProxy {
    @Override
    public void preInit(FMLPreInitializationEvent event) {
        super.preInit(event);
    }

    @Override
    public void init(FMLInitializationEvent event) {
        super.init(event);
    }

    @Override
    public void postInit(FMLPostInitializationEvent event) {
        super.postInit(event);
    }
}


proxy/CommonProxy.java:
package com.zihaomc.ghost.proxy;

import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;

public class CommonProxy {
    public void preInit(FMLPreInitializationEvent event) {}
    public void init(FMLInitializationEvent event) {}
    public void postInit(FMLPostInitializationEvent event) {}
}


config/GhostConfig.java:
package com.zihaomc.ghost.config;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.config.Configuration;
import net.minecraftforge.common.config.Property;

import java.io.File;
import java.util.*;
import java.util.function.BiConsumer;
import java.util.stream.Collectors;

/**
 * 重构后的配置类。
 * - 使用静态内部类对配置项进行分组。
 * - 简化了加载和保存逻辑，减少了重复代码。
 * - 为 GhostConfigCommand 提供了统一的更新接口。
 */
public class GhostConfig {

    private static Configuration config = null;

    // --- 配置类别 ---
    public static final String CATEGORY_FILL = "fill_command";
    public static final String CATEGORY_SAVE = "save_options";
    public static final String CATEGORY_CHAT = "chat_features";
    public static final String CATEGORY_AUTO_PLACE = "auto_place_feature";
    public static final String CATEGORY_AUTO_SNEAK = "auto_sneak_feature";
    public static final String CATEGORY_PLAYER_ESP = "player_esp_feature";
    public static final String CATEGORY_BEDROCK_MINER = "bedrock_miner_feature";
    public static final String CATEGORY_GAMEPLAY_TWEAKS = "gameplay_tweaks";
    public static final String CATEGORY_TRANSLATION = "translation_api";
    public static final String CATEGORY_NOTE = "note_taking";
    public static final String CATEGORY_GUI_TWEAKS = "gui_tweaks";
    public static final String CATEGORY_AUTO_MINE = "auto_mine_feature";
    public static final String CATEGORY_AUTO_CRAFT = "auto_craft_feature";
    public static final String CATEGORY_PATHFINDING = "pathfinding_feature"; // 新增

    // --- 用于命令的统一配置更新器 ---
    public static final Map<String, BiConsumer<String, String>> settingUpdaters = new HashMap<>();

    // --- 分组后的配置项 ---
    public static class FillCommand {
        public static boolean alwaysBatchFill;
        public static int forcedBatchSize;
    }

    public static class SaveOptions {
        public static boolean enableAutoSave;
        public static String defaultSaveFileName;
    }

    public static class ChatFeatures {
        public static boolean enableChatSuggestions;
        public static boolean enableCommandHistoryScroll;
        public static boolean disableTwitchAtKey;
    }

    public static class AutoPlace {
        public static boolean enableAutoPlaceOnJoin;
    }

    public static class AutoSneak {
        public static boolean enableAutoSneakAtEdge;
        public static double autoSneakForwardOffset;
        public static double autoSneakVerticalCheckDepth;
    }

    public static class PlayerESP {
        public static boolean enablePlayerESP;
    }

    public static class BedrockMiner {
        public static boolean enableBedrockMiner;
        public static int pingSpikeThreshold;
        public static boolean headlessPistonMode;
        public static boolean blinkDuringTasksTick;
        public static Set<Block> blockWhitelist = new HashSet<>();
        public static Set<Block> dependBlockWhitelist = new HashSet<>();
        
        public static int getPingSpikeThreshold() { return pingSpikeThreshold; }
        public static boolean isHeadlessPistonMode() { return headlessPistonMode; }
        public static Set<Block> getDependBlockWhitelist() { return dependBlockWhitelist; }
        public static boolean isBlinkDuringTasksTick() { return blinkDuringTasksTick; }
        public static Set<Block> getBlockWhitelist() { return blockWhitelist; }
    }

    public static class GameplayTweaks {
        public static boolean fastPistonBreaking;
        public static boolean hideArrowsOnPlayers;
    }

    public static class Translation {
        public static boolean enableChatTranslation;
        public static boolean enableSignTranslation;
        public static boolean enableItemTranslation;
        public static boolean enableAutomaticTranslation;
        public static boolean autoShowCachedTranslation;
        public static boolean showTranslationOnly;
        public static boolean hideTranslationKeybindTooltip;
        
        public static boolean showProviderSwitchButtons;
        
        public static String niuTransApiKey;
        
        public static String translationSourceLang;
        public static String translationTargetLang;
        
        public static String translationProvider; 
    }

    public static class NoteTaking {
        public static boolean enableNoteFeature;
        public static boolean enableAdvancedEditing;
        public static boolean enableMarkdownRendering;
        public static boolean enableColorRendering;
        public static boolean enableAmpersandColorCodes;
    }

    public static class GuiTweaks {
        public static boolean fixGuiStateLossOnResize;
    }
    
    public static class AutoMine {
        public static double rotationSpeed;
        public static double maxReachDistance;
        public static int searchRadius;
        public static boolean serverRotation;
        public static boolean instantRotation;
        public static boolean sneakOnMine;
        public static boolean enableRandomMovements;
        public static int mineTimeoutSeconds;
        public static boolean enableRandomRotationSpeed;
        public static double rotationSpeedVariability;
        public static boolean preventDiggingDown;
        public static int randomMoveInterval;
        public static int randomMoveDuration;
        public static int randomMoveIntervalVariability;
        public static boolean enableVeinMining;
        public static String miningMode;
        public static boolean antiCheatCheck;
        public static boolean enableVoidSafetyCheck;
        public static int voidSafetyYLimit;

        public static boolean enableMithrilOptimization;
        public static String[] titaniumBlockIds;
        public static int mithrilCleanupThreshold;
        public static boolean enableAutomaticToolSwitching;
    }

    public static class AutoCraft {
        public static int autoCraftPlacementDelayTicks;
        public static int autoCraftCycleDelayTicks;
        public static int autoCraftMenuOpenDelayTicks;
        public static int autoCraftTableOpenDelayTicks;
        public static int autoCraftPickupStashWaitTicks;
    }

    // 新增 Pathfinding 配置类
    public static class Pathfinding {
        public static int maxIterations; // 最大计算迭代次数
    }

    // --- 核心方法 ---
    public static void init(File configFile) {
        if (config == null) {
            config = new Configuration(configFile);
            loadConfig();
        }
    }

    public static void loadConfig() {
        if (config == null) {
            LogUtil.error("log.config.notInitialized");
            return;
        }
        config.load();

        loadFillCommandSettings();
        loadSaveOptionsSettings();
        loadChatFeaturesSettings();
        loadAutoPlaceSettings();
        loadAutoSneakSettings();
        loadPlayerESPSettings();
        loadBedrockMinerSettings();
        loadGameplayTweaksSettings();
        loadTranslationSettings();
        loadNoteTakingSettings();
        loadGuiTweaksSettings();
        loadAutoMineSettings();
        loadAutoCraftSettings();
        loadPathfindingSettings(); // 加载寻路配置

        if (config.hasChanged()) {
            config.save();
            LogUtil.info("log.config.loaded");
        }
        
        initializeUpdaters();
    }
    
    // --- 加载逻辑 (分组) ---
    private static void loadFillCommandSettings() {
        FillCommand.alwaysBatchFill = loadBoolean(CATEGORY_FILL, "alwaysBatchFill", false, "ghostblock.config.alwaysBatchFill.tooltip");
        FillCommand.forcedBatchSize = loadInt(CATEGORY_FILL, "forcedBatchSize", 100, 1, Integer.MAX_VALUE, "ghostblock.config.forcedBatchSize.tooltip");
    }
    
    private static void loadSaveOptionsSettings() {
        SaveOptions.enableAutoSave = loadBoolean(CATEGORY_SAVE, "enableAutoSave", false, "ghostblock.config.enableAutoSave.tooltip");
        SaveOptions.defaultSaveFileName = loadString(CATEGORY_SAVE, "defaultSaveFileName", "", "ghostblock.config.defaultSaveFileName.tooltip");
    }

    private static void loadChatFeaturesSettings() {
        ChatFeatures.enableChatSuggestions = loadBoolean(CATEGORY_CHAT, "enableChatSuggestions", true, "ghostblock.config.enableChatSuggestions.tooltip");
        ChatFeatures.enableCommandHistoryScroll = loadBoolean(CATEGORY_CHAT, "enableCommandHistoryScroll", true, "ghostblock.config.enableCommandHistoryScroll.tooltip");
        ChatFeatures.disableTwitchAtKey = loadBoolean(CATEGORY_CHAT, "disableTwitchAtKey", true, "ghost.config.comment.disableTwitchAtKey");
    }

    private static void loadAutoPlaceSettings() {
        AutoPlace.enableAutoPlaceOnJoin = loadBoolean(CATEGORY_AUTO_PLACE, "enableAutoPlaceOnJoin", false, "ghostblock.config.enableAutoPlaceOnJoin.tooltip");
    }

    private static void loadAutoSneakSettings() {
        AutoSneak.enableAutoSneakAtEdge = loadBoolean(CATEGORY_AUTO_SNEAK, "enableAutoSneakAtEdge", false, "ghostblock.config.enableAutoSneakAtEdge.tooltip");
        AutoSneak.autoSneakForwardOffset = loadDouble(CATEGORY_AUTO_SNEAK, "autoSneakForwardOffset", 0.15, 0.05, 1.0, "ghostblock.config.autoSneakForwardOffset.tooltip");
        AutoSneak.autoSneakVerticalCheckDepth = loadDouble(CATEGORY_AUTO_SNEAK, "autoSneakVerticalCheckDepth", 1.0, 0.1, 3.0, "ghostblock.config.autoSneakVerticalCheckDepth.tooltip");
    }

    private static void loadPlayerESPSettings() {
        PlayerESP.enablePlayerESP = loadBoolean(CATEGORY_PLAYER_ESP, "enablePlayerESP", false, "ghostblock.config.enablePlayerESP.tooltip");
    }

    private static void loadBedrockMinerSettings() {
        BedrockMiner.enableBedrockMiner = loadBoolean(CATEGORY_BEDROCK_MINER, "enableBedrockMiner", false, "ghostblock.config.enableBedrockMiner.tooltip");
        BedrockMiner.pingSpikeThreshold = loadInt(CATEGORY_BEDROCK_MINER, "pingSpikeThreshold", 2, 0, 100, "ghost.config.comment.pingSpike");
        BedrockMiner.headlessPistonMode = loadBoolean(CATEGORY_BEDROCK_MINER, "headlessPistonMode", true, "ghost.config.comment.headlessPiston");
        BedrockMiner.blinkDuringTasksTick = loadBoolean(CATEGORY_BEDROCK_MINER, "blinkDuringTasksTick", true, "ghost.config.comment.blink");
        
        String[] whitelistArr = loadStringList(CATEGORY_BEDROCK_MINER, "blockWhitelist", new String[]{"minecraft:bedrock"}, "ghost.config.comment.blockWhitelist");
        BedrockMiner.blockWhitelist = Arrays.stream(whitelistArr).map(s -> Block.blockRegistry.getObject(new ResourceLocation(s))).filter(Objects::nonNull).collect(Collectors.toSet());

        String[] dependArr = loadStringList(CATEGORY_BEDROCK_MINER, "dependBlockWhitelist", new String[]{"minecraft:slime_block"}, "ghost.config.comment.dependWhitelist");
        BedrockMiner.dependBlockWhitelist = Arrays.stream(dependArr).map(s -> Block.blockRegistry.getObject(new ResourceLocation(s))).filter(Objects::nonNull).collect(Collectors.toSet());
    }
    
    private static void loadGameplayTweaksSettings() {
        GameplayTweaks.fastPistonBreaking = loadBoolean(CATEGORY_GAMEPLAY_TWEAKS, "fastPistonBreaking", false, "ghostblock.config.fastPistonBreaking.tooltip");
        GameplayTweaks.hideArrowsOnPlayers = loadBoolean(CATEGORY_GAMEPLAY_TWEAKS, "hideArrowsOnPlayers", false, "ghost.config.comment.hideArrowsOnPlayers");
    }

    private static void loadTranslationSettings() {
        Translation.enableChatTranslation = loadBoolean(CATEGORY_TRANSLATION, "enableChatTranslation", false, "ghost.config.comment.enableChatTranslation");
        Translation.enableSignTranslation = loadBoolean(CATEGORY_TRANSLATION, "enableSignTranslation", false, "ghost.config.comment.enableSignTranslation");
        Translation.enableItemTranslation = loadBoolean(CATEGORY_TRANSLATION, "enableItemTranslation", false, "ghost.config.comment.enableItemTranslation");
        Translation.enableAutomaticTranslation = loadBoolean(CATEGORY_TRANSLATION, "enableAutomaticTranslation", false, "ghost.config.comment.enableAutomaticTranslation");
        Translation.autoShowCachedTranslation = loadBoolean(CATEGORY_TRANSLATION, "autoShowCachedTranslation", true, "ghost.config.comment.autoShowCachedTranslation");
        Translation.showTranslationOnly = loadBoolean(CATEGORY_TRANSLATION, "showTranslationOnly", false, "ghost.config.comment.showTranslationOnly");
        Translation.hideTranslationKeybindTooltip = loadBoolean(CATEGORY_TRANSLATION, "hideTranslationKeybindTooltip", false, "ghost.config.comment.hideTranslationKeybindTooltip");
        
        Translation.showProviderSwitchButtons = loadBoolean(CATEGORY_TRANSLATION, "showProviderSwitchButtons", true, "ghost.config.comment.showProviderSwitchButtons");
        
        Translation.niuTransApiKey = loadString(CATEGORY_TRANSLATION, "niuTransApiKey", "", "ghostblock.config.niuTransApiKey.tooltip");
        Translation.translationSourceLang = loadString(CATEGORY_TRANSLATION, "translationSourceLang", "auto", "ghostblock.config.translationSourceLang.tooltip");
        Translation.translationTargetLang = loadString(CATEGORY_TRANSLATION, "translationTargetLang", "zh", "ghostblock.config.translationTargetLang.tooltip");
        Translation.translationProvider = loadString(CATEGORY_TRANSLATION, "translationProvider", "GOOGLE", "ghost.config.comment.translationProvider");
    }
    
    private static void loadNoteTakingSettings() {
        NoteTaking.enableNoteFeature = loadBoolean(CATEGORY_NOTE, "enableNoteFeature", true, "ghost.config.comment.enableNoteFeature");
        NoteTaking.enableAdvancedEditing = loadBoolean(CATEGORY_NOTE, "enableAdvancedEditing", true, "ghost.config.comment.enableAdvancedEditing");
        NoteTaking.enableMarkdownRendering = loadBoolean(CATEGORY_NOTE, "enableMarkdownRendering", true, "ghost.config.comment.enableMarkdownRendering");
        NoteTaking.enableColorRendering = loadBoolean(CATEGORY_NOTE, "enableColorRendering", true, "ghost.config.comment.enableColorRendering");
        NoteTaking.enableAmpersandColorCodes = loadBoolean(CATEGORY_NOTE, "enableAmpersandColorCodes", true, "ghost.config.comment.enableAmpersandColorCodes");
    }

    private static void loadGuiTweaksSettings() {
        GuiTweaks.fixGuiStateLossOnResize = loadBoolean(CATEGORY_GUI_TWEAKS, "fixGuiStateLossOnResize", true, "ghost.config.comment.fixGuiStateLossOnResize");
    }

    private static void loadAutoMineSettings() {
        AutoMine.rotationSpeed = loadDouble(CATEGORY_AUTO_MINE, "rotationSpeed", 10.0, 1.0, 180.0, "ghost.config.comment.autoMineRotationSpeed");
        AutoMine.maxReachDistance = loadDouble(CATEGORY_AUTO_MINE, "maxReachDistance", 4.5, 1.0, 6.0, "ghost.config.comment.autoMineMaxReach");
        AutoMine.searchRadius = loadInt(CATEGORY_AUTO_MINE, "searchRadius", 7, 3, 15, "ghost.config.comment.autoMineSearchRadius");
        AutoMine.mineTimeoutSeconds = loadInt(CATEGORY_AUTO_MINE, "mineTimeoutSeconds", 7, 2, 30, "ghost.config.comment.autoMineTimeout");
        AutoMine.instantRotation = loadBoolean(CATEGORY_AUTO_MINE, "instantRotation", false, "ghost.config.comment.autoMineInstantRotation");
        AutoMine.serverRotation = loadBoolean(CATEGORY_AUTO_MINE, "serverRotation", false, "ghost.config.comment.autoMineServerRotation");
        AutoMine.sneakOnMine = loadBoolean(CATEGORY_AUTO_MINE, "sneakOnMine", false, "ghost.config.comment.autoMineSneak");
        AutoMine.enableRandomMovements = loadBoolean(CATEGORY_AUTO_MINE, "enableRandomMovements", false, "ghost.config.comment.autoMineEnableRandomMove");
        AutoMine.enableRandomRotationSpeed = loadBoolean(CATEGORY_AUTO_MINE, "enableRandomRotationSpeed", true, "ghost.config.comment.autoMineEnableRandomSpeed");
        AutoMine.rotationSpeedVariability = loadDouble(CATEGORY_AUTO_MINE, "rotationSpeedVariability", 5.0, 0.0, 20.0, "ghost.config.comment.autoMineSpeedVariability");
        AutoMine.preventDiggingDown = loadBoolean(CATEGORY_AUTO_MINE, "preventDiggingDown", false, "ghost.config.comment.autoMinePreventDiggingDown");
        AutoMine.randomMoveInterval = loadInt(CATEGORY_AUTO_MINE, "randomMoveInterval", 200, 10, 400, "ghost.config.comment.autoMineRandomMoveInterval");
        AutoMine.randomMoveDuration = loadInt(CATEGORY_AUTO_MINE, "randomMoveDuration", 10, 1, 20, "ghost.config.comment.autoMineRandomMoveDuration");
        AutoMine.randomMoveIntervalVariability = loadInt(CATEGORY_AUTO_MINE, "randomMoveIntervalVariability", 100, 0, 1000, "ghost.config.comment.autoMineRandomMoveIntervalVariability");
        AutoMine.enableVeinMining = loadBoolean(CATEGORY_AUTO_MINE, "enableVeinMining", true, "ghost.config.comment.autoMineEnableVeinMining");
        AutoMine.miningMode = loadString(CATEGORY_AUTO_MINE, "miningMode", "SIMULATE", "ghost.config.comment.autoMineMiningMode");
        AutoMine.antiCheatCheck = loadBoolean(CATEGORY_AUTO_MINE, "antiCheatCheck", true, "ghost.config.comment.autoMineAntiCheatCheck");
        AutoMine.enableVoidSafetyCheck = loadBoolean(CATEGORY_AUTO_MINE, "enableVoidSafetyCheck", true, "ghost.config.comment.autoMineVoidSafetyCheck");
        AutoMine.voidSafetyYLimit = loadInt(CATEGORY_AUTO_MINE, "voidSafetyYLimit", 1, 0, 255, "ghost.config.comment.autoMineVoidSafetyYLimit");

        AutoMine.enableMithrilOptimization = loadBoolean(CATEGORY_AUTO_MINE, "enableMithrilOptimization", false, "ghost.config.comment.autoMineMithrilOptimization");
        AutoMine.titaniumBlockIds = loadStringList(CATEGORY_AUTO_MINE, "titaniumBlockIds", new String[]{"minecraft:stone:4"}, "ghost.config.comment.autoMineTitaniumBlockIds");
        AutoMine.mithrilCleanupThreshold = loadInt(CATEGORY_AUTO_MINE, "mithrilCleanupThreshold", 5, 1, 50, "ghost.config.comment.autoMineMithrilCleanupThreshold");
        AutoMine.enableAutomaticToolSwitching = loadBoolean(CATEGORY_AUTO_MINE, "enableAutomaticToolSwitching", false, "ghost.config.comment.autoMineEnableToolSwitching");
    }

    private static void loadAutoCraftSettings() {
        AutoCraft.autoCraftPlacementDelayTicks = loadInt(CATEGORY_AUTO_CRAFT, "autoCraftPlacementDelayTicks", 1, 1, 100, "ghost.config.comment.autoCraftPlacementDelay");
        AutoCraft.autoCraftCycleDelayTicks = loadInt(CATEGORY_AUTO_CRAFT, "autoCraftCycleDelayTicks", 5, 1, 200, "ghost.config.comment.autoCraftCycleDelay");
        AutoCraft.autoCraftMenuOpenDelayTicks = loadInt(CATEGORY_AUTO_CRAFT, "autoCraftMenuOpenDelayTicks", 5, 1, 200, "ghost.config.comment.autoCraftMenuOpenDelay");
        AutoCraft.autoCraftTableOpenDelayTicks = loadInt(CATEGORY_AUTO_CRAFT, "autoCraftTableOpenDelayTicks", 8, 1, 200, "ghost.config.comment.autoCraftTableOpenDelay");
        AutoCraft.autoCraftPickupStashWaitTicks = loadInt(CATEGORY_AUTO_CRAFT, "autoCraftPickupStashWaitTicks", 5, 1, 200, "ghost.config.comment.autoCraftPickupStashWait");
    }

    private static void loadPathfindingSettings() {
        Pathfinding.maxIterations = loadInt(CATEGORY_PATHFINDING, "maxIterations", 5000, 1000, 50000, "最大寻路计算步数");
    }

    // --- 加载辅助方法 ---
    private static boolean loadBoolean(String category, String key, boolean defaultValue, String commentKey) {
        return config.getBoolean(key, category, defaultValue, LangUtil.translate(commentKey));
    }

    private static int loadInt(String category, String key, int defaultValue, int min, int max, String commentKey) {
        return config.getInt(key, category, defaultValue, min, max, LangUtil.translate(commentKey));
    }
    
    private static double loadDouble(String category, String key, double defaultValue, double min, double max, String commentKey) {
        return config.get(category, key, defaultValue, LangUtil.translate(commentKey), min, max).getDouble();
    }
        
    private static String loadString(String category, String key, String defaultValue, String commentKey) {
        return config.getString(key, category, defaultValue, LangUtil.translate(commentKey));
    }

    private static String[] loadStringList(String category, String key, String[] defaultValue, String commentKey) {
        return config.getStringList(key, category, defaultValue, LangUtil.translate(commentKey));
    }
    
    // --- Setter 方法 (用于命令修改配置) ---
    private static void updateAndSave(String category, String key, Object value, Runnable fieldUpdater) {
        if (config == null) return;
        Property prop = config.get(category, key, "");
        prop.set(String.valueOf(value));
        config.save();
        fieldUpdater.run();
    }
    
    public static void setAlwaysBatchFill(boolean value) {
        updateAndSave(CATEGORY_FILL, "alwaysBatchFill", value, () -> FillCommand.alwaysBatchFill = value);
    }

    public static boolean setForcedBatchSize(int value) {
        if (value <= 0) return false;
        updateAndSave(CATEGORY_FILL, "forcedBatchSize", value, () -> FillCommand.forcedBatchSize = value);
        return true;
    }

    public static void setEnableAutoSave(boolean value) {
        updateAndSave(CATEGORY_SAVE, "enableAutoSave", value, () -> SaveOptions.enableAutoSave = value);
    }

    public static boolean setDefaultSaveFileName(String value) {
        String processedValue = (value != null) ? value.trim() : "";
        updateAndSave(CATEGORY_SAVE, "defaultSaveFileName", processedValue, () -> SaveOptions.defaultSaveFileName = processedValue);
        return true;
    }

    public static void setEnableChatSuggestions(boolean value) {
        updateAndSave(CATEGORY_CHAT, "enableChatSuggestions", value, () -> ChatFeatures.enableChatSuggestions = value);
    }

    public static void setEnableCommandHistoryScroll(boolean value) {
        updateAndSave(CATEGORY_CHAT, "enableCommandHistoryScroll", value, () -> ChatFeatures.enableCommandHistoryScroll = value);
    }
    
    public static void setDisableTwitchAtKey(boolean value) {
        updateAndSave(CATEGORY_CHAT, "disableTwitchAtKey", value, () -> ChatFeatures.disableTwitchAtKey = value);
    }

    public static void setEnableChatTranslation(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "enableChatTranslation", value, () -> Translation.enableChatTranslation = value);
    }

    public static void setEnableSignTranslation(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "enableSignTranslation", value, () -> Translation.enableSignTranslation = value);
    }

    public static void setEnableItemTranslation(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "enableItemTranslation", value, () -> Translation.enableItemTranslation = value);
    }

    public static void setEnableAutomaticTranslation(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "enableAutomaticTranslation", value, () -> Translation.enableAutomaticTranslation = value);
    }

    public static void setAutoShowCachedTranslation(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "autoShowCachedTranslation", value, () -> Translation.autoShowCachedTranslation = value);
    }

    public static void setShowTranslationOnly(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "showTranslationOnly", value, () -> Translation.showTranslationOnly = value);
    }

    public static void setHideTranslationKeybindTooltip(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "hideTranslationKeybindTooltip", value, () -> Translation.hideTranslationKeybindTooltip = value);
    }

    public static void setEnableAutoPlaceOnJoin(boolean value) {
        updateAndSave(CATEGORY_AUTO_PLACE, "enableAutoPlaceOnJoin", value, () -> AutoPlace.enableAutoPlaceOnJoin = value);
    }

    public static void setEnableAutoSneakAtEdge(boolean value) {
        updateAndSave(CATEGORY_AUTO_SNEAK, "enableAutoSneakAtEdge", value, () -> AutoSneak.enableAutoSneakAtEdge = value);
    }

    public static void setAutoSneakForwardOffset(double value) {
        if (value < 0.05 || value > 1.0) return;
        updateAndSave(CATEGORY_AUTO_SNEAK, "autoSneakForwardOffset", value, () -> AutoSneak.autoSneakForwardOffset = value);
    }

    public static void setAutoSneakVerticalCheckDepth(double value) {
        if (value < 0.1 || value > 3.0) return;
        updateAndSave(CATEGORY_AUTO_SNEAK, "autoSneakVerticalCheckDepth", value, () -> AutoSneak.autoSneakVerticalCheckDepth = value);
    }

    public static void setEnablePlayerESP(boolean value) {
        updateAndSave(CATEGORY_PLAYER_ESP, "enablePlayerESP", value, () -> PlayerESP.enablePlayerESP = value);
    }

    public static void setEnableBedrockMiner(boolean value) {
        if (value) {
            setFastPistonBreaking(true, false);
        }
        updateAndSave(CATEGORY_BEDROCK_MINER, "enableBedrockMiner", value, () -> BedrockMiner.enableBedrockMiner = value);
    }

    public static void setFastPistonBreaking(boolean value, boolean saveImmediately) {
        if (config == null) return;
        Property prop = config.get(CATEGORY_GAMEPLAY_TWEAKS, "fastPistonBreaking", false);
        prop.set(value);
        GameplayTweaks.fastPistonBreaking = value;
        if (saveImmediately) {
            config.save();
        }
    }

    public static void setHideArrowsOnPlayers(boolean value) {
        updateAndSave(CATEGORY_GAMEPLAY_TWEAKS, "hideArrowsOnPlayers", value, () -> GameplayTweaks.hideArrowsOnPlayers = value);
    }

    public static void setEnableNoteFeature(boolean value) {
        updateAndSave(CATEGORY_NOTE, "enableNoteFeature", value, () -> NoteTaking.enableNoteFeature = value);
    }

    public static void setNiuTransApiKey(String value) {
        updateAndSave(CATEGORY_TRANSLATION, "niuTransApiKey", value, () -> Translation.niuTransApiKey = value);
    }

    public static void setTranslationSourceLang(String value) {
        updateAndSave(CATEGORY_TRANSLATION, "translationSourceLang", value, () -> Translation.translationSourceLang = value);
    }

    public static void setTranslationTargetLang(String value) {
        updateAndSave(CATEGORY_TRANSLATION, "translationTargetLang", value, () -> Translation.translationTargetLang = value);
    }

    public static void setTranslationProvider(String value) {
        updateAndSave(CATEGORY_TRANSLATION, "translationProvider", value, () -> Translation.translationProvider = value);
    }
    
    public static void setShowProviderSwitchButtons(boolean value) {
        updateAndSave(CATEGORY_TRANSLATION, "showProviderSwitchButtons", value, () -> Translation.showProviderSwitchButtons = value);
    }

    public static void setEnableAdvancedEditing(boolean value) {
        updateAndSave(CATEGORY_NOTE, "enableAdvancedEditing", value, () -> NoteTaking.enableAdvancedEditing = value);
    }

    public static void setEnableMarkdownRendering(boolean value) {
        updateAndSave(CATEGORY_NOTE, "enableMarkdownRendering", value, () -> NoteTaking.enableMarkdownRendering = value);
    }

    public static void setEnableColorRendering(boolean value) {
        updateAndSave(CATEGORY_NOTE, "enableColorRendering", value, () -> NoteTaking.enableColorRendering = value);
    }

    public static void setEnableAmpersandColorCodes(boolean value) {
        updateAndSave(CATEGORY_NOTE, "enableAmpersandColorCodes", value, () -> NoteTaking.enableAmpersandColorCodes = value);
    }

    public static void setFixGuiStateLossOnResize(boolean value) {
        updateAndSave(CATEGORY_GUI_TWEAKS, "fixGuiStateLossOnResize", value, () -> GuiTweaks.fixGuiStateLossOnResize = value);
    }
    
    public static void setAutoMineRotationSpeed(double value) {
        if (value < 1.0 || value > 180.0) return;
        updateAndSave(CATEGORY_AUTO_MINE, "rotationSpeed", value, () -> AutoMine.rotationSpeed = value);
    }
    
    public static void setAutoMineMaxReachDistance(double value) {
        if (value < 1.0 || value > 6.0) return;
        updateAndSave(CATEGORY_AUTO_MINE, "maxReachDistance", value, () -> AutoMine.maxReachDistance = value);
    }
    
    public static void setAutoMineSearchRadius(int value) {
        if (value < 3 || value > 15) return;
        updateAndSave(CATEGORY_AUTO_MINE, "searchRadius", value, () -> AutoMine.searchRadius = value);
    }

    public static void setAutoMineServerRotation(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "serverRotation", value, () -> AutoMine.serverRotation = value);
    }

    public static void setAutoMineInstantRotation(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "instantRotation", value, () -> AutoMine.instantRotation = value);
    }

    public static void setAutoMineSneak(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "sneakOnMine", value, () -> AutoMine.sneakOnMine = value);
    }

    public static void setAutoMineEnableRandomMove(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "enableRandomMovements", value, () -> AutoMine.enableRandomMovements = value);
    }

    public static void setAutoMineTimeout(int value) {
        if (value < 2 || value > 30) return;
        updateAndSave(CATEGORY_AUTO_MINE, "mineTimeoutSeconds", value, () -> AutoMine.mineTimeoutSeconds = value);
    }

    public static void setAutoMineEnableRandomSpeed(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "enableRandomRotationSpeed", value, () -> AutoMine.enableRandomRotationSpeed = value);
    }

    public static void setAutoMineSpeedVariability(double value) {
        if (value < 0.0 || value > 20.0) return;
        updateAndSave(CATEGORY_AUTO_MINE, "rotationSpeedVariability", value, () -> AutoMine.rotationSpeedVariability = value);
    }

    public static void setAutoMinePreventDiggingDown(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "preventDiggingDown", value, () -> AutoMine.preventDiggingDown = value);
    }

    public static void setAutoMineRandomMoveInterval(int value) {
        if (value < 10 || value > 400) return;
        updateAndSave(CATEGORY_AUTO_MINE, "randomMoveInterval", value, () -> AutoMine.randomMoveInterval = value);
    }

    public static void setAutoMineRandomMoveDuration(int value) {
        if (value < 1 || value > 20) return;
        updateAndSave(CATEGORY_AUTO_MINE, "randomMoveDuration", value, () -> AutoMine.randomMoveDuration = value);
    }

    public static void setAutoMineRandomMoveIntervalVariability(int value) {
        if (value < 0 || value > 1000) return;
        updateAndSave(CATEGORY_AUTO_MINE, "randomMoveIntervalVariability", value, () -> AutoMine.randomMoveIntervalVariability = value);
    }

    public static void setAutoMineEnableVeinMining(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "enableVeinMining", value, () -> AutoMine.enableVeinMining = value);
    }
    
    public static void setAutoMineMiningMode(String value) {
        String upperValue = value.toUpperCase();
        List<String> validModes = Arrays.asList("SIMULATE", "PACKET_NORMAL", "PACKET_INSTANT");
        if (validModes.contains(upperValue)) {
            updateAndSave(CATEGORY_AUTO_MINE, "miningMode", upperValue, () -> AutoMine.miningMode = upperValue);
        } else {
            throw new RuntimeException(new CommandException("Invalid mining mode. Valid options are: SIMULATE, PACKET_NORMAL, PACKET_INSTANT"));
        }
    }
    
    public static void setAutoMineAntiCheatCheck(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "antiCheatCheck", value, () -> AutoMine.antiCheatCheck = value);
    }

    public static void setAutoMineEnableVoidSafetyCheck(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "enableVoidSafetyCheck", value, () -> AutoMine.enableVoidSafetyCheck = value);
    }

    public static void setAutoMineVoidSafetyYLimit(int value) {
        if (value < 0 || value > 255) return;
        updateAndSave(CATEGORY_AUTO_MINE, "voidSafetyYLimit", value, () -> AutoMine.voidSafetyYLimit = value);
    }

    public static void setAutoMineEnableMithrilOptimization(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "enableMithrilOptimization", value, () -> AutoMine.enableMithrilOptimization = value);
    }

    public static void setAutoMineMithrilCleanupThreshold(int value) {
        if (value < 1 || value > 50) return;
        updateAndSave(CATEGORY_AUTO_MINE, "mithrilCleanupThreshold", value, () -> AutoMine.mithrilCleanupThreshold = value);
    }

    public static void setAutoMineEnableAutomaticToolSwitching(boolean value) {
        updateAndSave(CATEGORY_AUTO_MINE, "enableAutomaticToolSwitching", value, () -> AutoMine.enableAutomaticToolSwitching = value);
    }
    
    public static void setAutoCraftPlacementDelayTicks(int value) {
        if (value < 1 || value > 100) return;
        updateAndSave(CATEGORY_AUTO_CRAFT, "autoCraftPlacementDelayTicks", value, () -> AutoCraft.autoCraftPlacementDelayTicks = value);
    }

    public static void setAutoCraftCycleDelayTicks(int value) {
        if (value < 1 || value > 200) return;
        updateAndSave(CATEGORY_AUTO_CRAFT, "autoCraftCycleDelayTicks", value, () -> AutoCraft.autoCraftCycleDelayTicks = value);
    }

    public static void setAutoCraftMenuOpenDelayTicks(int value) {
        if (value < 1 || value > 100) return;
        updateAndSave(CATEGORY_AUTO_CRAFT, "autoCraftMenuOpenDelayTicks", value, () -> AutoCraft.autoCraftMenuOpenDelayTicks = value);
    }
    
    public static void setAutoCraftTableOpenDelayTicks(int value) {
        if (value < 1 || value > 100) return;
        updateAndSave(CATEGORY_AUTO_CRAFT, "autoCraftTableOpenDelayTicks", value, () -> AutoCraft.autoCraftTableOpenDelayTicks = value);
    }

    public static void setAutoCraftPickupStashWaitTicks(int value) {
        if (value < 1 || value > 200) return;
        updateAndSave(CATEGORY_AUTO_CRAFT, "autoCraftPickupStashWaitTicks", value, () -> AutoCraft.autoCraftPickupStashWaitTicks = value);
    }

    public static Configuration getConfig() {
        return config;
    }
    
    // --- 命令更新器注册 ---
    private static void initializeUpdaters() {
        settingUpdaters.clear();
        
        settingUpdaters.put("alwaysbatchfill", (k, v) -> setAlwaysBatchFill(parseBoolean(v)));
        settingUpdaters.put("forcedbatchsize", (k, v) -> setForcedBatchSize(parseInt(v)));
        settingUpdaters.put("enableautosave", (k, v) -> setEnableAutoSave(parseBoolean(v)));
        settingUpdaters.put("defaultsavename", (k, v) -> setDefaultSaveFileName(v));
        settingUpdaters.put("enablechatsuggestions", (k, v) -> setEnableChatSuggestions(parseBoolean(v)));
        settingUpdaters.put("enablecommandhistoryscroll", (k, v) -> setEnableCommandHistoryScroll(parseBoolean(v)));
        settingUpdaters.put("disabletwitchatkey", (k, v) -> setDisableTwitchAtKey(parseBoolean(v)));
        settingUpdaters.put("enableautoplaceonjoin", (k, v) -> setEnableAutoPlaceOnJoin(parseBoolean(v)));
        settingUpdaters.put("enableautosneakatedge", (k, v) -> setEnableAutoSneakAtEdge(parseBoolean(v)));
        settingUpdaters.put("autosneakforwardoffset", (k, v) -> setAutoSneakForwardOffset(parseDouble(v)));
        settingUpdaters.put("autosneakverticalcheckdepth", (k, v) -> setAutoSneakVerticalCheckDepth(parseDouble(v)));
        settingUpdaters.put("enableplayeresp", (k, v) -> setEnablePlayerESP(parseBoolean(v)));
        settingUpdaters.put("enablebedrockminer", (k, v) -> setEnableBedrockMiner(parseBoolean(v)));
        settingUpdaters.put("fastpistonbreaking", (k, v) -> setFastPistonBreaking(parseBoolean(v), true));
        settingUpdaters.put("hidearrowsonplayers", (k, v) -> setHideArrowsOnPlayers(parseBoolean(v)));
        settingUpdaters.put("enablechattranslation", (k, v) -> setEnableChatTranslation(parseBoolean(v)));
        settingUpdaters.put("enablesigntranslation", (k, v) -> setEnableSignTranslation(parseBoolean(v)));
        settingUpdaters.put("enableitemtranslation", (k, v) -> setEnableItemTranslation(parseBoolean(v)));
        settingUpdaters.put("enableautomatictranslation", (k, v) -> setEnableAutomaticTranslation(parseBoolean(v)));
        settingUpdaters.put("autoshowcachedtranslation", (k, v) -> setAutoShowCachedTranslation(parseBoolean(v)));
        settingUpdaters.put("showtranslationonly", (k, v) -> setShowTranslationOnly(parseBoolean(v)));
        settingUpdaters.put("hidetranslationkeybindtooltip", (k, v) -> setHideTranslationKeybindTooltip(parseBoolean(v)));
        settingUpdaters.put("niutransapikey", (k, v) -> setNiuTransApiKey(v));
        settingUpdaters.put("translationsourcelang", (k, v) -> setTranslationSourceLang(v));
        settingUpdaters.put("translationtargetlang", (k, v) -> setTranslationTargetLang(v));
        settingUpdaters.put("translationprovider", (k, v) -> setTranslationProvider(v));
        
        settingUpdaters.put("showproviderswitchbuttons", (k, v) -> setShowProviderSwitchButtons(parseBoolean(v)));
        
        settingUpdaters.put("enablenotefeature", (k, v) -> setEnableNoteFeature(parseBoolean(v)));
        settingUpdaters.put("enableadvancedediting", (k, v) -> setEnableAdvancedEditing(parseBoolean(v)));
        settingUpdaters.put("enablemarkdownrendering", (k, v) -> setEnableMarkdownRendering(parseBoolean(v)));
        settingUpdaters.put("enablecolorrendering", (k, v) -> setEnableColorRendering(parseBoolean(v)));
        settingUpdaters.put("enableampersandcolorcodes", (k, v) -> setEnableAmpersandColorCodes(parseBoolean(v)));
        settingUpdaters.put("fixguistatelossonresize", (k, v) -> setFixGuiStateLossOnResize(parseBoolean(v)));

        settingUpdaters.put("autominerotationspeed", (k, v) -> setAutoMineRotationSpeed(parseDouble(v)));
        settingUpdaters.put("automaxreachdistance", (k, v) -> setAutoMineMaxReachDistance(parseDouble(v)));
        settingUpdaters.put("autominerearchradius", (k, v) -> setAutoMineSearchRadius(parseInt(v)));
        settingUpdaters.put("automineserverrotation", (k, v) -> setAutoMineServerRotation(parseBoolean(v)));
        settingUpdaters.put("automineinstantrotation", (k, v) -> setAutoMineInstantRotation(parseBoolean(v)));
        settingUpdaters.put("autominesneak", (k, v) -> setAutoMineSneak(parseBoolean(v)));
        settingUpdaters.put("automineenablerandommove", (k, v) -> setAutoMineEnableRandomMove(parseBoolean(v)));
        settingUpdaters.put("autominetimeout", (k, v) -> setAutoMineTimeout(parseInt(v)));
        settingUpdaters.put("automineenablerandomspeed", (k, v) -> setAutoMineEnableRandomSpeed(parseBoolean(v)));
        settingUpdaters.put("autominespeedvariability", (k, v) -> setAutoMineSpeedVariability(parseDouble(v)));
        settingUpdaters.put("autominepreventdiggingdown", (k, v) -> setAutoMinePreventDiggingDown(parseBoolean(v)));
        settingUpdaters.put("autominerandommoveinterval", (k, v) -> setAutoMineRandomMoveInterval(parseInt(v)));
        settingUpdaters.put("autominerandommoveduration", (k, v) -> setAutoMineRandomMoveDuration(parseInt(v)));
        settingUpdaters.put("autominerandommoveintervalvariability", (k, v) -> setAutoMineRandomMoveIntervalVariability(parseInt(v)));
        settingUpdaters.put("automineenableveinmining", (k, v) -> setAutoMineEnableVeinMining(parseBoolean(v)));
        settingUpdaters.put("automineminingmode", (k, v) -> setAutoMineMiningMode(v));
        settingUpdaters.put("automineanticheatcheck", (k, v) -> setAutoMineAntiCheatCheck(parseBoolean(v)));
        settingUpdaters.put("autominevoidsafetycheck", (k, v) -> setAutoMineEnableVoidSafetyCheck(parseBoolean(v)));
        settingUpdaters.put("autominevoidsafetylimit", (k, v) -> setAutoMineVoidSafetyYLimit(parseInt(v)));
        
        settingUpdaters.put("autominemithriloptimization", (k, v) -> setAutoMineEnableMithrilOptimization(parseBoolean(v)));
        settingUpdaters.put("autominemithrilcleanupthreshold", (k, v) -> setAutoMineMithrilCleanupThreshold(parseInt(v)));
        settingUpdaters.put("automineenabletoolswitching", (k,v) -> setAutoMineEnableAutomaticToolSwitching(parseBoolean(v)));

        settingUpdaters.put("autocraftplacementdelay", (k, v) -> setAutoCraftPlacementDelayTicks(parseInt(v)));
        settingUpdaters.put("autocraftcycledelay", (k, v) -> setAutoCraftCycleDelayTicks(parseInt(v)));
        settingUpdaters.put("autocraftmenuopendelay", (k, v) -> setAutoCraftMenuOpenDelayTicks(parseInt(v)));
        settingUpdaters.put("autocrafttableopendelay", (k, v) -> setAutoCraftTableOpenDelayTicks(parseInt(v)));
        settingUpdaters.put("autocraftpickupstashwait", (k, v) -> setAutoCraftPickupStashWaitTicks(parseInt(v)));
    }
    
    // --- 解析辅助方法 ---
    private static boolean parseBoolean(String input) {
        try { return CommandBase.parseBoolean(input); }
        catch (CommandException e) { throw new RuntimeException(e); }
    }
    private static int parseInt(String input) {
        try { return CommandBase.parseInt(input); }
        catch (CommandException e) { throw new RuntimeException(e); }
    }
    private static double parseDouble(String input) {
        try { return CommandBase.parseDouble(input); }
        catch (CommandException e) { throw new RuntimeException(e); }
    }
}

commands/GhostConfigCommand.java:
package com.zihaomc.ghost.commands;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import net.minecraft.client.Minecraft;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatComponentTranslation;
import net.minecraft.util.EnumChatFormatting;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 处理 /gconfig 命令，用于在游戏中动态修改 Mod 的配置。
 */
public class GhostConfigCommand extends CommandBase {

    @Override
    public String getCommandName() {
        return "ghostconfig";
    }

    @Override
    public List<String> getCommandAliases() {
        return Collections.singletonList("gconfig");
    }

    @Override
    public String getCommandUsage(ICommandSender sender) {
        return LangUtil.translate("ghostblock.commands.gconfig.usage.extended");
    }

    @Override
    public int getRequiredPermissionLevel() {
        return 0;
    }

    @Override
    public boolean canCommandSenderUseCommand(ICommandSender sender) {
        return true;
    }

    @Override
    public void processCommand(ICommandSender sender, String[] args) throws CommandException {
        if (args.length == 0) {
            displayCurrentSettings(sender);
            return;
        }

        String command = args[0].toLowerCase();

        if ("help".equalsIgnoreCase(command)) {
            displayHelp(sender);
            return;
        }

        if ("togglesuggest".equalsIgnoreCase(command)) {
            toggleChatSuggestions(sender);
            return;
        }

        String settingName = args[0];
        String settingKey = settingName.toLowerCase();

        if (GhostConfig.settingUpdaters.containsKey(settingKey)) {
            if (settingKey.equals("niutransapikey") && args.length == 1) {
                GhostConfig.setNiuTransApiKey("");
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.gconfig.success.key_cleared"));
                return;
            }

            if (args.length < 2) {
                throw new WrongUsageException(getCommandUsage(sender));
            }

            String valueStr = String.join(" ", Arrays.copyOfRange(args, 1, args.length));

            try {
                GhostConfig.settingUpdaters.get(settingKey).accept(settingName, valueStr);

                if (settingKey.equals("niutransapikey")) {
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.gconfig.success.key_set"));
                } else if (settingKey.equals("enablebedrockminer") && "true".equalsIgnoreCase(valueStr)) {
                    sendSuccessMessage(sender, settingName, valueStr);
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.AQUA, "ghostblock.commands.gconfig.fastpiston_autogen"));
                } else {
                    sendSuccessMessage(sender, settingName, valueStr);
                }
            } catch (RuntimeException e) {
                if (e.getCause() instanceof CommandException) {
                    throw (CommandException) e.getCause();
                }
                throw new CommandException("commands.generic.exception");
            }
        } else {
            throw new CommandException(LangUtil.translate("ghostblock.commands.gconfig.error.invalid_setting.all_options", settingName));
        }
    }

    private void toggleChatSuggestions(ICommandSender sender) {
        boolean newState = !GhostConfig.ChatFeatures.enableChatSuggestions;
        GhostConfig.setEnableChatSuggestions(newState);

        String feedbackKey = newState ? "ghostblock.commands.gconfig.togglesuggest.enabled" : "ghostblock.commands.gconfig.togglesuggest.disabled";
        ChatComponentTranslation feedback = new ChatComponentTranslation(feedbackKey);
        feedback.getChatStyle().setColor(newState ? EnumChatFormatting.GREEN : EnumChatFormatting.RED);
        sender.addChatMessage(feedback);
    }

    private void displayCurrentSettings(ICommandSender sender) {
        sender.addChatMessage(new ChatComponentTranslation("ghostblock.commands.gconfig.current_settings.header")
                .setChatStyle(new ChatComponentText("").getChatStyle().setColor(EnumChatFormatting.AQUA)));

        sender.addChatMessage(formatSettingLine("alwaysBatchFill", GhostConfig.FillCommand.alwaysBatchFill));
        sender.addChatMessage(formatSettingLine("forcedBatchSize", GhostConfig.FillCommand.forcedBatchSize));
        sender.addChatMessage(formatSettingLine("enableAutoSave", GhostConfig.SaveOptions.enableAutoSave));
        
        String displayFileName = GhostConfig.SaveOptions.defaultSaveFileName;
        if (displayFileName == null || displayFileName.trim().isEmpty()) {
            displayFileName = "(" + LangUtil.translate("ghostblock.commands.gconfig.current_settings.default_filename_placeholder") + ")";
        }
        sender.addChatMessage(formatSettingLine("defaultSaveName", displayFileName));

        sender.addChatMessage(formatSettingLine("enableChatSuggestions", GhostConfig.ChatFeatures.enableChatSuggestions));
        sender.addChatMessage(formatSettingLine("enableAutoPlaceOnJoin", GhostConfig.AutoPlace.enableAutoPlaceOnJoin));
        sender.addChatMessage(formatSettingLine("enableAutoSneakAtEdge", GhostConfig.AutoSneak.enableAutoSneakAtEdge));
        sender.addChatMessage(formatSettingLine("enablePlayerESP", GhostConfig.PlayerESP.enablePlayerESP));
        sender.addChatMessage(formatSettingLine("enableBedrockMiner", GhostConfig.BedrockMiner.enableBedrockMiner));
        sender.addChatMessage(formatSettingLine("fastPistonBreaking", GhostConfig.GameplayTweaks.fastPistonBreaking));

        sender.addChatMessage(formatSettingLine("enableAutomaticTranslation", GhostConfig.Translation.enableAutomaticTranslation));
        sender.addChatMessage(formatSettingLine("translationProvider", GhostConfig.Translation.translationProvider));
        sender.addChatMessage(formatSettingLine("translationTargetLang", GhostConfig.Translation.translationTargetLang));

        sender.addChatMessage(formatSettingLine("autoMineMiningMode", GhostConfig.AutoMine.miningMode));
        sender.addChatMessage(formatSettingLine("autoMineRotationSpeed", String.format("%.1f", GhostConfig.AutoMine.rotationSpeed)));
        sender.addChatMessage(formatSettingLine("autoMineMithrilOptimization", GhostConfig.AutoMine.enableMithrilOptimization));

        sender.addChatMessage(new ChatComponentText(" "));
        sender.addChatMessage(new ChatComponentTranslation("ghostblock.commands.gconfig.hint_toggle_suggest")
                .setChatStyle(new ChatComponentText("").getChatStyle().setColor(EnumChatFormatting.DARK_AQUA)));
    }

    private ChatComponentText formatSettingLine(String name, Object value) {
        String valueStr = String.valueOf(value);
        ChatComponentText line = new ChatComponentText("  " + name + ": ");
        line.getChatStyle().setColor(EnumChatFormatting.GRAY);
        ChatComponentText valueComp = new ChatComponentText(valueStr);
        valueComp.getChatStyle().setColor(EnumChatFormatting.YELLOW);
        line.appendSibling(valueComp);
        return line;
    }

    private void sendSuccessMessage(ICommandSender sender, String setting, Object value) {
        sender.addChatMessage(new ChatComponentTranslation("ghostblock.commands.gconfig.success", setting, value)
                .setChatStyle(new ChatComponentText("").getChatStyle().setColor(EnumChatFormatting.GREEN)));
    }

    private void displayHelp(ICommandSender sender) {
        EnumChatFormatting hl = EnumChatFormatting.GOLD;
        EnumChatFormatting tx = EnumChatFormatting.GRAY;
        EnumChatFormatting us = EnumChatFormatting.YELLOW;
        EnumChatFormatting op = EnumChatFormatting.AQUA;

        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.gconfig.help.menu")));
        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.gconfig.help.description")));
        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.gconfig.help.usage.main")));
        sender.addChatMessage(new ChatComponentText(us + "  /gconfig <设置项> <值>"));
        
        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.gconfig.help.available_settings")));
        sender.addChatMessage(new ChatComponentText(tx + "(输入 /gconfig 并按 Tab 键查看所有可用选项)"));

        sender.addChatMessage(new ChatComponentText(op + "  enable... " + tx + LangUtil.translate("ghost.commands.gconfig.help.type.boolean") + " (true/false)"));
        sender.addChatMessage(new ChatComponentText(op + "  autoMine... " + tx + "数值或模式"));
        sender.addChatMessage(new ChatComponentText(op + "  translation... " + tx + "文本代码"));

        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.gconfig.help.examples.header")));
        sender.addChatMessage(new ChatComponentText(us + "  /gconfig enableAutoSave true"));
        sender.addChatMessage(new ChatComponentText(us + "  /gconfig forcedBatchSize 500"));
        sender.addChatMessage(new ChatComponentText(us + "  /gconfig translationTargetLang en"));
        sender.addChatMessage(new ChatComponentText(us + "  /gconfig autoMineMiningMode PACKET_NORMAL"));

        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.gconfig.help.aliases") + ": " + hl + String.join(", ", getCommandAliases())));
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length == 1) {
            List<String> settingNames = new ArrayList<>(GhostConfig.settingUpdaters.keySet());
            settingNames.add("help");
            settingNames.add("toggleSuggest");
            Collections.sort(settingNames);
            return CommandBase.getListOfStringsMatchingLastWord(args, settingNames);
        } else if (args.length == 2) {
            String settingName = args[0].toLowerCase();

            if (isBooleanCommand(settingName)) {
                return CommandBase.getListOfStringsMatchingLastWord(args, "true", "false");
            }

            switch (settingName) {
                case "translationsourcelang":
                    return CommandBase.getListOfStringsMatchingLastWord(args, "auto", "zh", "en", "ja", "ko", "fr", "ru", "de");
                case "translationtargetlang":
                    return CommandBase.getListOfStringsMatchingLastWord(args, "zh", "en", "ja", "ko", "fr", "ru", "de");
                case "translationprovider":
                    return CommandBase.getListOfStringsMatchingLastWord(args, "NIUTRANS", "GOOGLE", "BING", "MYMEMORY");
                case "forcedbatchsize":
                    return CommandBase.getListOfStringsMatchingLastWord(args, "100", "500", "1000");
                case "defaultsavename":
                    List<String> nameSuggestions = new ArrayList<>();
                    nameSuggestions.add("default");
                    try {
                        if (Minecraft.getMinecraft().theWorld != null) {
                            String worldId = GhostBlockData.getWorldIdentifier(Minecraft.getMinecraft().theWorld);
                            String baseWorldId = GhostBlockData.getWorldBaseIdentifier(Minecraft.getMinecraft().theWorld);
                            if (!worldId.equals(baseWorldId)) {
                                nameSuggestions.add(baseWorldId);
                            }
                            nameSuggestions.add(worldId);
                        }
                    } catch (Exception ignored) {}
                    nameSuggestions = nameSuggestions.stream().distinct().sorted().collect(Collectors.toList());
                    return CommandBase.getListOfStringsMatchingLastWord(args, nameSuggestions);
                case "automineminingmode":
                    return CommandBase.getListOfStringsMatchingLastWord(args, "SIMULATE", "PACKET_NORMAL", "PACKET_INSTANT");
                case "autominerotationspeed":
                    return CommandBase.getListOfStringsMatchingLastWord(args, "10.0", "45.0", "90.0");
                case "autominetimeout":
                    return CommandBase.getListOfStringsMatchingLastWord(args, "5", "10", "20");
            }
        }
        return Collections.emptyList();
    }

    private boolean isBooleanCommand(String key) {
        return key.startsWith("enable") || key.startsWith("always") || key.startsWith("disable") ||
               key.startsWith("show") || key.startsWith("hide") ||
               key.equals("autoShowCachedTranslation") ||
               key.equals("headlesspistonmode") || key.equals("blinkduringtaskstick") ||
               key.equals("fastpistonbreaking") || key.equals("fixguistatelossonresize") ||
               key.equals("automineserverrotation") || key.equals("automineinstantrotation") ||
               key.equals("autominesneak") || key.equals("automineenablerandommove") ||
               key.equals("automineenablerandomspeed") || key.equals("autominepreventdiggingdown") ||
               key.equals("automineenableveinmining") ||
               key.equals("automineanticheatcheck") ||
               key.equals("autominevoidsafetycheck") ||
               key.equals("autominemithriloptimization") ||
               key.equals("automineenabletoolswitching");
    }
}


features/pathfinding/Pathfinder.java:
package com.zihaomc.ghost.features.pathfinding;

import net.minecraft.block.Block;
import net.minecraft.block.BlockFence;
import net.minecraft.block.BlockFenceGate;
import net.minecraft.block.BlockWall;
import net.minecraft.block.material.Material;
import net.minecraft.client.Minecraft;
import net.minecraft.init.Blocks;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.Vec3;
import net.minecraft.block.state.IBlockState;

import java.util.*;

/**
 * 修复版 A* 寻路算法。
 * - 修复了撞墙问题：使用 RayTrace 进行精确的墙壁检测。
 * - 修复了楼梯问题：增加了专门的垂直移动判断逻辑。
 */
public class Pathfinder {

    private static final Minecraft mc = Minecraft.getMinecraft();
    private static final double DIAGONAL_COST = 1.414;

    public static List<BlockPos> computePath(BlockPos start, BlockPos end, int maxIterations) {
        PriorityQueue<Node> openSet = new PriorityQueue<>();
        Set<BlockPos> closedSet = new HashSet<>();
        Map<BlockPos, Node> allNodes = new HashMap<>();

        Node startNode = new Node(start, null, 0, start.distanceSq(end));
        openSet.add(startNode);
        allNodes.put(start, startNode);

        int iterations = 0;

        while (!openSet.isEmpty() && iterations < maxIterations) {
            iterations++;
            Node current = openSet.poll();

            if (current.pos.distanceSq(end) < 1.5) {
                List<BlockPos> rawPath = retracePath(current);
                return smoothPath(rawPath);
            }

            closedSet.add(current.pos);

            for (Neighbor neighbor : getNeighbors(current.pos)) {
                BlockPos neighborPos = neighbor.pos;
                if (closedSet.contains(neighborPos)) continue;

                double newGCost = current.gCost + neighbor.cost;
                Node neighborNode = allNodes.getOrDefault(neighborPos, new Node(neighborPos, null, Double.MAX_VALUE, 0));

                if (newGCost < neighborNode.gCost) {
                    neighborNode.parent = current;
                    neighborNode.gCost = newGCost;
                    neighborNode.hCost = Math.sqrt(neighborPos.distanceSq(end)); // 欧几里得距离

                    if (openSet.contains(neighborNode)) {
                        openSet.remove(neighborNode);
                    }
                    openSet.add(neighborNode);
                    allNodes.put(neighborPos, neighborNode);
                }
            }
        }

        return new ArrayList<>();
    }

    /**
     * 路径平滑：使用光线追踪检测是否可以走直线。
     * 这比之前的点采样更精准，不会试图穿过墙角。
     */
    private static List<BlockPos> smoothPath(List<BlockPos> path) {
        if (path.size() <= 2) return path;

        List<BlockPos> smoothed = new ArrayList<>();
        smoothed.add(path.get(0));
        int currentIdx = 0;

        while (currentIdx < path.size() - 1) {
            int nextIdx = currentIdx + 1;
            // 贪婪策略：寻找最远的可见节点
            for (int i = path.size() - 1; i > currentIdx + 1; i--) {
                // 仅在高度差不大时尝试平滑，避免跳崖
                if (Math.abs(path.get(currentIdx).getY() - path.get(i).getY()) <= 1 && 
                    canSeeDirectly(path.get(currentIdx), path.get(i))) {
                    nextIdx = i;
                    break;
                }
            }
            smoothed.add(path.get(nextIdx));
            currentIdx = nextIdx;
        }
        return smoothed;
    }

    /**
     * 使用 RayTrace 检查两点之间是否有方块阻挡。
     * 这是防止“撞墙”的关键修复。
     */
    private static boolean canSeeDirectly(BlockPos start, BlockPos end) {
        // 从起点中心+眼高，看向终点中心+眼高
        Vec3 startVec = new Vec3(start.getX() + 0.5, start.getY() + 1.0, start.getZ() + 0.5);
        Vec3 endVec = new Vec3(end.getX() + 0.5, end.getY() + 1.0, end.getZ() + 0.5);

        // false, true, false -> 不忽略流体，忽略无碰撞箱方块(草)，不返回未碰撞方块
        MovingObjectPosition result = mc.theWorld.rayTraceBlocks(startVec, endVec, false, true, false);
        
        // 如果 RayTrace 击中了方块，说明有墙
        if (result != null && result.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
            return false;
        }
        
        // 额外检查：确保终点脚下是实心的 (防止平滑路径导致掉进坑里)
        return isSolid(end.down());
    }

    private static List<BlockPos> retracePath(Node endNode) {
        List<BlockPos> path = new ArrayList<>();
        Node current = endNode;
        while (current != null) {
            path.add(current.pos);
            current = current.parent;
        }
        Collections.reverse(path);
        return path;
    }

    private static class Neighbor {
        BlockPos pos;
        double cost;
        public Neighbor(BlockPos pos, double cost) { this.pos = pos; this.cost = cost; }
    }

    /**
     * 获取邻居节点，包含核心的移动逻辑
     */
    private static List<Neighbor> getNeighbors(BlockPos pos) {
        List<Neighbor> neighbors = new ArrayList<>();
        
        BlockPos[] cardinals = {pos.north(), pos.south(), pos.east(), pos.west()};
        boolean[] walkable = new boolean[4]; // 记录四个方向是否可行，用于对角线判断

        // 1. 处理四个正方向 (前后左右)
        for (int i = 0; i < 4; i++) {
            BlockPos target = cardinals[i];
            
            // 情况 A: 平地移动 (目标格子是空气，脚下是实心)
            if (isPassable(target) && isSolid(target.down()) && isSafeHead(target)) {
                neighbors.add(new Neighbor(target, 1.0));
                walkable[i] = true;
            } 
            // 情况 B: 上台阶/楼梯 (目标格子是实心，但目标上方是空气)
            // 修复点：这里检测 target 是实心，但 target.up 是空的
            else if (isSolid(target) && isPassable(target.up()) && isSafeHead(target.up())) {
                neighbors.add(new Neighbor(target.up(), 1.0)); // 实际上移动到了上方一格
                // 上台阶不算“平地可通行”，所以 walkable[i] 保持 false (防止对角线穿模)
            }
            // 情况 C: 下台阶 (目标格子是空气，目标脚下是空气，但再下面是实心)
            else if (isPassable(target) && isPassable(target.down()) && isSolid(target.down(2)) && isSafeHead(target.down())) {
                neighbors.add(new Neighbor(target.down(), 1.0));
                walkable[i] = true;
            }
        }

        // 2. 处理对角线 (仅限平地)
        // 索引对应: 0=N, 1=S, 2=E, 3=W
        // NE(0,2), NW(0,3), SE(1,2), SW(1,3)
        checkDiagonal(neighbors, walkable[0], walkable[2], pos.north().east());
        checkDiagonal(neighbors, walkable[0], walkable[3], pos.north().west());
        checkDiagonal(neighbors, walkable[1], walkable[2], pos.south().east());
        checkDiagonal(neighbors, walkable[1], walkable[3], pos.south().west());

        return neighbors;
    }

    private static void checkDiagonal(List<Neighbor> list, boolean b1, boolean b2, BlockPos target) {
        // 只有当两个正方向都可通行时，才允许走对角线，防止切角穿墙
        if (b1 && b2 && isPassable(target) && isSolid(target.down()) && isSafeHead(target)) {
            list.add(new Neighbor(target, DIAGONAL_COST));
        }
    }

    // --- 核心检测逻辑 ---

    /**
     * 检查某个位置是否“空旷”，允许玩家身体进入
     */
    private static boolean isPassable(BlockPos pos) {
        IBlockState state = mc.theWorld.getBlockState(pos);
        Block block = state.getBlock();
        // 危险方块检查
        if (block == Blocks.lava || block == Blocks.flowing_lava || block == Blocks.fire || block == Blocks.cactus) return false;
        
        // 关键修复：使用 getCollisionBoundingBox
        // 如果返回 null，说明没有碰撞箱 (空气、草、花)，可以穿过
        return block.getCollisionBoundingBox(mc.theWorld, pos, state) == null;
    }

    /**
     * 检查某个位置是否“实心”，允许玩家踩在上面
     */
    private static boolean isSolid(BlockPos pos) {
        IBlockState state = mc.theWorld.getBlockState(pos);
        Block block = state.getBlock();
        
        if (block == Blocks.air) return false;
        
        // 排除栅栏、墙等不能直接踩上去(因为太高)或者判定复杂的方块
        // 但允许楼梯、台阶
        if (block instanceof BlockFence || block instanceof BlockFenceGate || block instanceof BlockWall) return false;
        
        // 检查材质是否实心 (水、岩浆返回 false)
        return block.getMaterial().isSolid();
    }

    /**
     * 检查头顶是否有空间 (2格高)
     */
    private static boolean isSafeHead(BlockPos feetPos) {
        return isPassable(feetPos.up());
    }

    private static class Node implements Comparable<Node> {
        BlockPos pos;
        Node parent;
        double gCost;
        double hCost;

        public Node(BlockPos pos, Node parent, double gCost, double hCost) {
            this.pos = pos;
            this.parent = parent;
            this.gCost = gCost;
            this.hCost = hCost;
        }

        public double getFCost() { return gCost + hCost; }

        @Override
        public int compareTo(Node other) {
            return Double.compare(this.getFCost(), other.getFCost());
        }
        
        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Node) return pos.equals(((Node) obj).pos);
            return false;
        }
    }
}

features/pathfinding/PathfindingCommand.java:
package com.zihaomc.ghost.features.pathfinding;

import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.EnumChatFormatting;

import java.util.Collections;
import java.util.List;

public class PathfindingCommand extends CommandBase {

    @Override
    public String getCommandName() {
        return "gpath";
    }

    @Override
    public String getCommandUsage(ICommandSender sender) {
        return "/gpath <x> <y> <z> 或 /gpath stop";
    }

    @Override
    public int getRequiredPermissionLevel() {
        return 0;
    }

    @Override
    public boolean canCommandSenderUseCommand(ICommandSender sender) {
        return true;
    }

    @Override
    public void processCommand(ICommandSender sender, String[] args) throws CommandException {
        if (args.length == 0) {
            throw new WrongUsageException(getCommandUsage(sender));
        }

        if (args[0].equalsIgnoreCase("stop")) {
            PathfindingHandler.stop();
            sender.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + "[Ghost] 寻路已停止。"));
            return;
        }

        if (args.length < 3) {
            throw new WrongUsageException(getCommandUsage(sender));
        }

        BlockPos targetPos = GhostBlockHelper.parseBlockPosLegacy(sender, args, 0);
        BlockPos startPos = Minecraft.getMinecraft().thePlayer.getPosition();

        sender.addChatMessage(new ChatComponentText(EnumChatFormatting.GRAY + "[Ghost] 正在计算路径..."));

        // 在独立线程中计算路径，防止卡顿主线程
        new Thread(() -> {
            List<BlockPos> path = Pathfinder.computePath(startPos, targetPos, 5000); // 5000次迭代限制

            Minecraft.getMinecraft().addScheduledTask(() -> {
                if (path != null && !path.isEmpty()) {
                    PathfindingHandler.setPath(path);
                    sender.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + "[Ghost] 路径已找到 (" + path.size() + " 步)，开始移动。"));
                } else {
                    sender.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + "[Ghost] 无法到达指定坐标 (路径未找到或距离太远)。"));
                }
            });
        }).start();
    }
    
    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length == 1) {
            return getListOfStringsMatchingLastWord(args, "stop");
        }
        return null;
    }
}

features/pathfinding/PathfindingHandler.java:
package com.zihaomc.ghost.features.pathfinding;

import com.zihaomc.ghost.utils.LogUtil;
import com.zihaomc.ghost.utils.RotationUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.Vec3;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

import java.util.List;

public class PathfindingHandler {

    private static final Minecraft mc = Minecraft.getMinecraft();
    private static List<BlockPos> currentPath = null;
    private static boolean isPathfinding = false;
    private static int currentPathIndex = 0;
    
    private static final float ROTATION_SPEED = 20.0f; 

    public static void setPath(List<BlockPos> path) {
        currentPath = path;
        currentPathIndex = 0;
        
        // 简单的初始点优化
        if (path.size() > 1 && path.get(0).distanceSq(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ) < 1.0) {
            currentPathIndex = 1;
        }
        
        isPathfinding = true;
    }

    public static void stop() {
        isPathfinding = false;
        currentPath = null;
        resetKeys();
    }

    @SubscribeEvent
    public void onClientTick(TickEvent.ClientTickEvent event) {
        if (event.phase != TickEvent.Phase.END || mc.thePlayer == null || mc.theWorld == null) return;

        if (!isPathfinding || currentPath == null || currentPath.isEmpty()) {
            return;
        }

        if (currentPathIndex >= currentPath.size()) {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + "[Ghost] 目的地已到达。"));
            stop();
            return;
        }

        BlockPos targetNode = currentPath.get(currentPathIndex);
        Vec3 targetCenter = new Vec3(targetNode.getX() + 0.5, targetNode.getY(), targetNode.getZ() + 0.5);
        
        // --- 视角控制 ---
        float[] targetRots = RotationUtil.getRotations(targetCenter.addVector(0, mc.thePlayer.getEyeHeight(), 0));
        float[] smoothRots = RotationUtil.getSmoothRotations(
                mc.thePlayer.rotationYaw, 
                mc.thePlayer.rotationPitch, 
                targetRots[0], 
                targetRots[1], 
                ROTATION_SPEED
        );
        mc.thePlayer.rotationYaw = smoothRots[0];
        mc.thePlayer.rotationPitch = smoothRots[1];

        // --- 到达判定 ---
        double distSqFlat = Math.pow(mc.thePlayer.posX - targetCenter.xCoord, 2) + Math.pow(mc.thePlayer.posZ - targetCenter.zCoord, 2);
        if (distSqFlat < 0.25) { 
            currentPathIndex++;
            return;
        }

        // --- 移动控制 ---
        KeyBinding.setKeyBindState(mc.gameSettings.keyBindForward.getKeyCode(), true);
        mc.thePlayer.setSprinting(false); 

        // --- 跳跃控制 ---
        boolean needJump = false;
        double speed = Math.sqrt(mc.thePlayer.motionX * mc.thePlayer.motionX + mc.thePlayer.motionZ * mc.thePlayer.motionZ);

        // 如果在水中，始终尝试上浮
        if (mc.thePlayer.isInWater() || mc.thePlayer.isInLava()) {
            needJump = true; 
        }
        else if (mc.thePlayer.onGround) {
            // 上台阶判定：目标Y > 玩家脚下Y (取整)
            // 注意：因为 Pathfinder 现在正确处理了楼梯，路径点会位于楼梯上方
            if (targetNode.getY() > Math.floor(mc.thePlayer.posY)) {
                needJump = true;
            }
            // 防卡死判定
            else if (mc.thePlayer.isCollidedHorizontally && speed < 0.05) {
                needJump = true;
            }
        }
        
        KeyBinding.setKeyBindState(mc.gameSettings.keyBindJump.getKeyCode(), needJump);
    }

    private static void resetKeys() {
        if (mc.gameSettings != null) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindForward.getKeyCode(), false);
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindJump.getKeyCode(), false);
        }
    }
}

features/ghostblock/GhostBlockEventHandler.java:
package com.zihaomc.ghost.features.ghostblock;

import com.zihaomc.ghost.features.ghostblock.tasks.ClearTask;
import com.zihaomc.ghost.features.ghostblock.tasks.FillTask;
import com.zihaomc.ghost.features.ghostblock.tasks.LoadTask;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.world.EnumSkyBlock;
import net.minecraft.world.World;
import net.minecraftforge.event.entity.EntityJoinWorldEvent;
import net.minecraftforge.event.world.WorldEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

import java.io.File;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * 处理所有与 GhostBlock 功能相关的 Forge 事件。
 * 包括后台任务处理、自动放置逻辑、世界加载/卸载时的清理。
 */
public class GhostBlockEventHandler {

    // --- 事件相关状态 ---
    private static int lastTrackedDimension = 0;
    private static boolean isFirstJoin = true;

    // --- 自动放置相关状态 ---
    private static GhostBlockData.GhostBlockEntry pendingAutoPlaceEntry = null;
    private static BlockPos pendingAutoPlaceTargetPos = null;
    private static File pendingAutoPlaceFileRef = null;
    private static int autoPlaceTickDelayCounter = 0;
    private static final int AUTO_PLACE_DURATION_TICKS = 40; // 持续放置2秒
    private static final int AUTO_PLACE_MAX_ATTEMPT_TICKS = 100; // 最多等待5秒
    private static boolean autoPlaceInProgress = false;

    /**
     * 客户端 Tick 事件，用于处理后台任务队列和自动放置。
     */
    @SubscribeEvent
    public void onClientTick(TickEvent.ClientTickEvent event) {
        if (event.phase != TickEvent.Phase.END) return;
        
        processTaskQueues();
        processConfirmationsTimeout();
        handleAutoPlaceTick();
    }

    private void processTaskQueues() {
        synchronized (GhostBlockState.activeFillTasks) {
            Iterator<FillTask> taskIter = GhostBlockState.activeFillTasks.iterator();
            while (taskIter.hasNext()) {
                FillTask task = taskIter.next();
                if (task.processBatch()) {
                    taskIter.remove();
                }
            }
        }
        synchronized (GhostBlockState.activeLoadTasks) {
            Iterator<LoadTask> taskIter = GhostBlockState.activeLoadTasks.iterator();
            while (taskIter.hasNext()) {
                LoadTask task = taskIter.next();
                if (task.processBatch()) {
                    taskIter.remove();
                }
            }
        }
        synchronized (GhostBlockState.activeClearTasks) {
            Iterator<ClearTask> taskIter = GhostBlockState.activeClearTasks.iterator();
            while (taskIter.hasNext()) {
                ClearTask task = taskIter.next();
                if (task.processBatch()) {
                    taskIter.remove();
                }
            }
        }
    }

    private void processConfirmationsTimeout() {
        Iterator<Map.Entry<String, GhostBlockState.ClearConfirmation>> confirmIter = GhostBlockState.pendingConfirmations.entrySet().iterator();
        while (confirmIter.hasNext()) {
            Map.Entry<String, GhostBlockState.ClearConfirmation> entry = confirmIter.next();
            if (System.currentTimeMillis() - entry.getValue().timestamp > GhostBlockState.CONFIRMATION_TIMEOUT) {
                confirmIter.remove();
            }
        }
    }
    
    @SubscribeEvent
    public void onEntityJoinWorld(EntityJoinWorldEvent event) {
        if (!event.world.isRemote || !(event.entity instanceof EntityPlayer)) return;
        
        EntityPlayer player = Minecraft.getMinecraft().thePlayer;
        if (player == null || !event.entity.equals(player)) return;

        WorldClient world = (WorldClient) event.world;
        int currentDim = player.dimension;
        LogUtil.debug("log.debug.joinWorld.entry", currentDim, lastTrackedDimension);

        if (autoPlaceInProgress) {
            LogUtil.debug("log.debug.joinWorld.autoplaceInProgress");
            return;
        }
        if (pendingAutoPlaceEntry != null) {
            LogUtil.warn("log.warn.joinWorld.pendingEntry");
            cleanupPendingAutoPlace(true);
        }

        // 检查自动放置
        if (GhostConfig.AutoPlace.enableAutoPlaceOnJoin) {
            String autoPlaceFileName = GhostBlockHelper.getAutoPlaceSaveFileName(world);
            List<GhostBlockData.GhostBlockEntry> autoPlaceEntries = GhostBlockData.loadData(world, Collections.singletonList(autoPlaceFileName));

            if (!autoPlaceEntries.isEmpty()) {
                pendingAutoPlaceEntry = autoPlaceEntries.get(0);
                pendingAutoPlaceTargetPos = new BlockPos(pendingAutoPlaceEntry.x, pendingAutoPlaceEntry.y, pendingAutoPlaceEntry.z);
                pendingAutoPlaceFileRef = GhostBlockData.getDataFile(world, autoPlaceFileName);
                autoPlaceTickDelayCounter = 0;
                autoPlaceInProgress = true;
                LogUtil.debug("log.debug.joinWorld.pendingSet", pendingAutoPlaceTargetPos);
                return; 
            }
        }

        if (isFirstJoin) {
            LogUtil.debug("log.debug.joinWorld.standardFlow.firstJoin", currentDim);
            cleanupAndRestoreOnLoad(world);
            isFirstJoin = false;
        } else if (lastTrackedDimension != currentDim) {
            LogUtil.debug("log.debug.joinWorld.standardFlow.dimensionChange", lastTrackedDimension, currentDim);
            cancelAllTasks(player);
            cleanupAndRestoreOnLoad(world);
        } else {
            LogUtil.debug("log.debug.joinWorld.standardFlow.rejoinSameDim", currentDim);
            cleanupAndRestoreOnLoad(world);
        }
        lastTrackedDimension = currentDim;
    }

    @SubscribeEvent
    public void onWorldLoad(WorldEvent.Load event) {
        if (!event.world.isRemote || !(event.world instanceof WorldClient)) return;
        
        if (GhostConfig.AutoPlace.enableAutoPlaceOnJoin) {
            LogUtil.info("log.info.worldLoad.skipCleanup");
            return;
        }
        cleanupAndRestoreOnLoad((WorldClient) event.world);
    }
    
    @SubscribeEvent
    public void onWorldUnload(WorldEvent.Unload event) {
        if (!event.world.isRemote || !(event.world instanceof WorldClient)) return;
        
        WorldClient clientWorld = (WorldClient) event.world;
        LogUtil.info("log.info.worldUnload.entry", autoPlaceInProgress);

        if (pendingAutoPlaceEntry != null || autoPlaceInProgress) {
            cleanupPendingAutoPlace(true);
        }
        
        if (GhostConfig.AutoPlace.enableAutoPlaceOnJoin) {
            saveAutoPlaceDataOnUnload(clientWorld);
        }

        cleanupOnUnload(clientWorld);
        
        isFirstJoin = true;
        autoPlaceInProgress = false;
        LogUtil.info("log.info.worldUnload.standardCleanup.resettingState");
    }
    
    private void handleAutoPlaceTick() {
        if (!autoPlaceInProgress || pendingAutoPlaceEntry == null) return;

        autoPlaceTickDelayCounter++;
        EntityPlayer player = Minecraft.getMinecraft().thePlayer;
        WorldClient world = Minecraft.getMinecraft().theWorld;

        if (player == null || world == null || pendingAutoPlaceTargetPos == null || pendingAutoPlaceFileRef == null) {
            cleanupPendingAutoPlace(true);
            return;
        }

        int fileDimension = GhostBlockData.getDimensionFromFileName(pendingAutoPlaceFileRef.getName());
        if (fileDimension != Integer.MIN_VALUE && player.dimension != fileDimension) {
            cleanupPendingAutoPlace(true);
            return;
        }

        BlockPos centerActualPlacePos = pendingAutoPlaceTargetPos.down(1);

        if (autoPlaceTickDelayCounter <= AUTO_PLACE_DURATION_TICKS) {
            if (isPlayerInAutoPlaceRange(player, centerActualPlacePos)) {
                placeAutoPlatform(world, centerActualPlacePos);
            }
        }
        
        if (autoPlaceTickDelayCounter > AUTO_PLACE_MAX_ATTEMPT_TICKS) {
            cleanupPendingAutoPlace(true);
        }
    }
    
    private boolean isPlayerInAutoPlaceRange(EntityPlayer player, BlockPos platformCenter) {
        BlockPos playerCurrentBlockPos = player.getPosition();
        boolean isInHorizontalRange = Math.abs(playerCurrentBlockPos.getX() - platformCenter.getX()) <= 2 &&
                                      Math.abs(playerCurrentBlockPos.getZ() - platformCenter.getZ()) <= 2;
        boolean isVerticallyReasonable = playerCurrentBlockPos.getY() >= platformCenter.getY() - 2 &&
                                         playerCurrentBlockPos.getY() <= platformCenter.getY() + 5;
        return isInHorizontalRange && isVerticallyReasonable;
    }

    private void placeAutoPlatform(WorldClient world, BlockPos center) {
        Block ghostBlockToPlace = Block.getBlockFromName(pendingAutoPlaceEntry.blockId);
        if (ghostBlockToPlace == null || ghostBlockToPlace == Blocks.air) {
            cleanupPendingAutoPlace(true);
            return;
        }
        IBlockState stateToSet = ghostBlockToPlace.getStateFromMeta(pendingAutoPlaceEntry.metadata);

        for (int dx = -1; dx <= 1; dx++) {
            for (int dz = -1; dz <= 1; dz++) {
                BlockPos currentPlatformPos = center.add(dx, 0, dz);
                if (world.isAirBlock(currentPlatformPos)) {
                    world.setBlockState(currentPlatformPos, stateToSet, 2 | 16);
                    world.markBlockForUpdate(currentPlatformPos);
                }
            }
        }
        if (autoPlaceTickDelayCounter == 1 || (autoPlaceTickDelayCounter == AUTO_PLACE_DURATION_TICKS)) {
            Minecraft.getMinecraft().thePlayer.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.autoplace.platform_success", center.getX(), center.getY(), center.getZ()));
        }
        if (autoPlaceTickDelayCounter >= AUTO_PLACE_DURATION_TICKS) {
            cleanupPendingAutoPlace(true);
        }
    }

    private void cleanupPendingAutoPlace(boolean deleteFile) {
        if (deleteFile && pendingAutoPlaceFileRef != null && pendingAutoPlaceFileRef.exists()) {
            if (!pendingAutoPlaceFileRef.delete()) {
                LogUtil.error("log.error.autoplace.cleanup.file.deleteFailed", pendingAutoPlaceFileRef.getName());
            }
        }
        pendingAutoPlaceEntry = null;
        pendingAutoPlaceTargetPos = null;
        pendingAutoPlaceFileRef = null;
        autoPlaceTickDelayCounter = 0;
        boolean wasInProgress = autoPlaceInProgress;
        autoPlaceInProgress = false;
        
        if (wasInProgress && isFirstJoin) {
            WorldClient world = Minecraft.getMinecraft().theWorld;
            if (world != null) {
                cleanupAndRestoreOnLoad(world);
                isFirstJoin = false;
                lastTrackedDimension = world.provider.getDimensionId();
            }
        }
    }

    private void cleanupAndRestoreOnLoad(WorldClient world) {
        String autoFileName = GhostBlockHelper.getAutoClearFileName(world);
        File autoFile = GhostBlockData.getDataFile(world, autoFileName);

        if (autoFile.exists()) {
            LogUtil.info("log.worldLoad.foundClearFile", autoFileName);
            List<GhostBlockData.GhostBlockEntry> entries = GhostBlockData.loadData(world, Collections.singletonList(autoFileName));
            int restored = 0;
            int failed = 0;
            for (GhostBlockData.GhostBlockEntry entry : entries) {
                BlockPos pos = new BlockPos(entry.x, entry.y, entry.z);
                Block originalBlock = Block.getBlockFromName(entry.originalBlockId);
                if (originalBlock != null) {
                    world.setBlockState(pos, originalBlock.getStateFromMeta(entry.originalMetadata), 3);
                    restored++;
                } else {
                    failed++;
                }
            }
            LogUtil.info("log.worldLoad.restoreComplete", restored, failed);
            if (!autoFile.delete()) {
                LogUtil.error("log.error.worldLoad.clearFile.deleteFailed", autoFile.getPath());
            }
        }
    }

    private void saveAutoPlaceDataOnUnload(WorldClient clientWorld) {
        EntityPlayer player = Minecraft.getMinecraft().thePlayer;
        if (player == null || player.worldObj != clientWorld) return;

        BlockPos logicalPlayerFeetPos = new BlockPos(Math.floor(player.posX), Math.floor(player.posY - 1.0), Math.floor(player.posZ));
        String tempClearFileName = GhostBlockHelper.getAutoClearFileName(clientWorld);
        List<GhostBlockData.GhostBlockEntry> clearEntries = GhostBlockData.loadData(clientWorld, Collections.singletonList(tempClearFileName));

        Optional<GhostBlockData.GhostBlockEntry> ghostEntryAtLogicalFeet = clearEntries.stream()
                .filter(entry -> entry.x == logicalPlayerFeetPos.getX() && entry.y == logicalPlayerFeetPos.getY() && entry.z == logicalPlayerFeetPos.getZ())
                .findFirst();

        String autoPlaceSaveFileName = GhostBlockHelper.getAutoPlaceSaveFileName(clientWorld);
        File autoPlaceFileToSaveTo = GhostBlockData.getDataFile(clientWorld, autoPlaceSaveFileName);

        if (ghostEntryAtLogicalFeet.isPresent()) {
            GhostBlockData.saveData(clientWorld, Collections.singletonList(ghostEntryAtLogicalFeet.get()), autoPlaceSaveFileName, true);
            LogUtil.info("log.info.worldUnload.autoplace.saved", logicalPlayerFeetPos, ghostEntryAtLogicalFeet.get().blockId, autoPlaceSaveFileName);
        } else {
            if (autoPlaceFileToSaveTo.exists() && !autoPlaceFileToSaveTo.delete()) {
                LogUtil.error("log.error.worldUnload.autoplace.deleteFailed", autoPlaceFileToSaveTo.getName());
            }
        }
    }

    private void cleanupOnUnload(WorldClient clientWorld) {
        File tempClearFileObject = GhostBlockData.getDataFile(clientWorld, GhostBlockHelper.getAutoClearFileName(clientWorld));
        if (tempClearFileObject.exists()) {
            tempClearFileObject.delete();
        }

        String baseId = GhostBlockData.getWorldBaseIdentifier(clientWorld);
        int unloadedDim = clientWorld.provider.getDimensionId();
        File savesDir = new File(GhostBlockData.SAVES_DIR);
        final String undoPrefix = "undo_" + baseId + "_dim_" + unloadedDim + "_";
        File[] undoFiles = savesDir.listFiles((dir, name) -> name.startsWith(undoPrefix) && name.endsWith(".json"));
        if (undoFiles != null) {
            for (File file : undoFiles) file.delete();
        }
        
        cancelAllTasks(Minecraft.getMinecraft().thePlayer);
    }
    
    private void cancelAllTasks(ICommandSender feedbackSender) {
        int cancelledCount = 0;
        cancelledCount += GhostBlockState.activeFillTasks.size();
        GhostBlockState.activeFillTasks.forEach(FillTask::cancel);
        GhostBlockState.activeFillTasks.clear();
        
        cancelledCount += GhostBlockState.activeLoadTasks.size();
        GhostBlockState.activeLoadTasks.forEach(LoadTask::cancel);
        GhostBlockState.activeLoadTasks.clear();

        cancelledCount += GhostBlockState.activeClearTasks.size();
        GhostBlockState.activeClearTasks.forEach(ClearTask::cancel);
        GhostBlockState.activeClearTasks.clear();

        cancelledCount += GhostBlockState.pausedTasks.size();
        GhostBlockState.pausedTasks.clear();

        if (feedbackSender != null && cancelledCount > 0) {
            feedbackSender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.task.cancelled_world_change"));
        }
        LogUtil.info("log.info.tasks.cancelled.count", cancelledCount);
    }
}


features/ghostblock/GhostBlockHelper.java:
package com.zihaomc.ghost.features.ghostblock;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.BlockStateProxy;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.util.*;
import net.minecraft.world.EnumSkyBlock;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.event.ClickEvent;
import net.minecraft.event.HoverEvent;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * GhostBlock 功能的通用辅助工具类。
 * 包含：消息格式化、坐标解析、文件操作、方块设置等静态方法。
 */
public class GhostBlockHelper {

    // --- 颜色常量 ---
    public static final EnumChatFormatting LABEL_COLOR = EnumChatFormatting.GRAY;
    public static final EnumChatFormatting VALUE_COLOR = EnumChatFormatting.YELLOW;
    public static final EnumChatFormatting FINISH_COLOR = EnumChatFormatting.GREEN;

    /**
     * 创建翻译源切换按钮的文本组件。
     * 显示为 [G] [B] [M] 等缩写，鼠标悬停显示全称。
     */
    public static IChatComponent createProviderSwitchButtons(String sourceText, String currentProvider) {
        // 检查配置开关，如果关闭则不生成按钮
        if (!GhostConfig.Translation.showProviderSwitchButtons) {
            return new ChatComponentText("");
        }

        ChatComponentText buttons = new ChatComponentText(" "); // 稍微留点空隙
        String[] providers = {"GOOGLE", "BING", "MYMEMORY", "NIUTRANS"};
        
        // 转义原文中的引号，防止构建命令时格式错误
        String escapedText = sourceText.replace("\"", "\\\"");

        for (String provider : providers) {
            // 跳过当前正在使用的提供商
            if (provider.equalsIgnoreCase(currentProvider)) continue;

            // 获取缩写 (例如 GOOGLE -> G)
            String abbr = getProviderAbbreviation(provider);
            
            // 创建按钮文本组件
            ChatComponentText button = new ChatComponentText("[" + abbr + "] ");
            
            // 构建点击执行的命令: /gtranslate -p PROVIDER "原文"
            String command = "/gtranslate -p " + provider + " \"" + escapedText + "\"";
            
            // 构建独立的悬浮提示文本 (例如: "切换源: GOOGLE")
            String tooltipStr = LangUtil.translate("ghost.tooltip.switch_provider", provider);
            ChatComponentText tooltipComponent = new ChatComponentText(tooltipStr);
            tooltipComponent.getChatStyle().setColor(EnumChatFormatting.YELLOW);

            // 设置独立的样式
            ChatStyle style = new ChatStyle()
                    .setColor(EnumChatFormatting.DARK_GRAY) // 按钮本身显示为深灰色，不抢眼
                    .setBold(false)
                    .setChatClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, command))
                    .setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, tooltipComponent));
            
            button.setChatStyle(style);
            buttons.appendSibling(button);
        }
        return buttons;
    }

    /**
     * 获取提供商的单字母缩写
     */
    private static String getProviderAbbreviation(String provider) {
        switch (provider.toUpperCase()) {
            case "GOOGLE": return "G";
            case "BING": return "B";
            case "MYMEMORY": return "M";
            case "NIUTRANS": return "N";
            default: return provider.substring(0, 1).toUpperCase();
        }
    }

    /**
     * 格式化带[Ghost]前缀的消息（默认灰色）。
     */
    public static ChatComponentText formatMessage(String messageKey, Object... args) {
        return formatMessage(EnumChatFormatting.GRAY, messageKey, args);
    }

    /**
     * 格式化带[Ghost]前缀的消息（带指定颜色）。
     */
    public static ChatComponentText formatMessage(EnumChatFormatting contentColor, String messageKey, Object... args) {
        ChatComponentText prefix = new ChatComponentText(LangUtil.translate("ghost.generic.prefix.default"));
        prefix.setChatStyle(new ChatStyle().setColor(EnumChatFormatting.DARK_GRAY));
        ChatComponentText content = new ChatComponentText(LangUtil.translate(messageKey, args));
        content.setChatStyle(new ChatStyle().setColor(contentColor));
        prefix.appendSibling(content);
        return prefix;
    }

    /**
     * 解析方块状态字符串 (例如 "minecraft:stone:1" 或 "wool:11")。
     */
    public static BlockStateProxy parseBlockState(ICommandSender sender, String input) throws CommandException {
        String blockIdString = input;
        int meta = 0;

        // 查找最后一个冒号，尝试解析 metadata
        int lastColonIndex = input.lastIndexOf(':');
        if (lastColonIndex > 0) { 
            String potentialMeta = input.substring(lastColonIndex + 1);
            try {
                int parsedMeta = Integer.parseInt(potentialMeta);
                meta = parsedMeta;
                blockIdString = input.substring(0, lastColonIndex);
            } catch (NumberFormatException e) {
                // 如果不是数字，说明冒号是方块名称的一部分
            }
        }

        Block block;
        try {
            block = CommandBase.getBlockByText(sender, blockIdString);
        } catch (CommandException e) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_block_id", blockIdString));
        }

        if (block == null) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_block_id", blockIdString));
        }

        // 验证 metadata 是否有效
        try {
            block.getStateFromMeta(meta);
        } catch (IllegalArgumentException e) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_metadata", meta, block.getRegistryName()));
        }

        if (block == Blocks.air) meta = 0;
        
        LogUtil.debug("log.info.command.parse.success", block.getRegistryName(), Block.getIdFromBlock(block), meta);
        return new BlockStateProxy(Block.getIdFromBlock(block), meta);
    }
    
    /**
     * 解析命令参数中的坐标，支持相对坐标(~)。
     */
    public static BlockPos parseBlockPosLegacy(ICommandSender sender, String[] args, int index) throws CommandException {
        if (args.length < index + 3) {
            throw new WrongUsageException("ghostblock.commands.usage");
        }
        EntityPlayer player = sender instanceof EntityPlayer ? (EntityPlayer) sender : null;
        double baseX = (player != null) ? player.posX : 0.0D;
        double baseY = (player != null) ? player.posY : 0.0D;
        double baseZ = (player != null) ? player.posZ : 0.0D;
        double x = parseRelativeCoordinateLegacy(sender, args[index], baseX);
        double y = parseRelativeCoordinateLegacy(sender, args[index + 1], baseY);
        double z = parseRelativeCoordinateLegacy(sender, args[index + 2], baseZ);
        return new BlockPos(Math.floor(x), Math.floor(y), Math.floor(z));
    }

    private static double parseRelativeCoordinateLegacy(ICommandSender sender, String input, double base) throws CommandException {
        if (input.startsWith("~")) {
            String offsetStr = input.substring(1);
            if (offsetStr.isEmpty()) {
                return base;
            } else {
                try {
                    return base + Double.parseDouble(offsetStr);
                } catch (NumberFormatException e) {
                    throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_coordinate_format", input));
                }
            }
        } else {
            try {
                return Double.parseDouble(input);
            } catch (NumberFormatException e) {
                throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_coordinate_format", input));
            }
        }
    }

    public static boolean isNumber(String input) {
        if (input == null || input.isEmpty()) return false;
        try {
            Integer.parseInt(input);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    public static void validateBatchSize(int batchSize) throws CommandException {
        if (batchSize <= 0) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.error.batch_size_too_small"));
        }
    }

    /**
     * 获取当前世界/维度的自动清除文件名。
     */
    public static String getAutoClearFileName(WorldClient world) {
        return "clear_" + GhostBlockData.getWorldIdentifier(world);
    }
    
    /**
     * 获取自动放置功能专用的保存文件名。
     */
    public static String getAutoPlaceSaveFileName(net.minecraft.world.World world) {
        if (world == null) return "autoplace_unknown_world";
        return "autoplace_" + GhostBlockData.getWorldIdentifier(world);
    }
    
    /**
     * 获取所有可用的用户保存文件名（不含内部文件如 clear_, undo_）。
     */
    public static List<String> getAvailableFileNames() {
        List<String> files = new ArrayList<>();
        File savesDir = new File(GhostBlockData.SAVES_DIR);
        if (!savesDir.exists() || !savesDir.isDirectory()) {
            return files;
        }
        File[] jsonFiles = savesDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".json"));
        if (jsonFiles != null) {
            for (File file : jsonFiles) {
                String name = file.getName();
                String baseName = name.substring(0, name.length() - 5);
                if (!baseName.isEmpty() && !baseName.toLowerCase().startsWith("clear_") && !baseName.toLowerCase().startsWith("undo_")) {
                    files.add(baseName);
                }
            }
        }
        Collections.sort(files, String.CASE_INSENSITIVE_ORDER);
        return files;
    }
    
    /**
     * 检查坐标是否有效且所在区块的 ExtendedBlockStorage 已就绪。
     */
    public static boolean isBlockSectionReady(WorldClient world, BlockPos pos) {
        if (pos.getY() < 0 || pos.getY() >= 256) return false;
        if (!world.isBlockLoaded(pos)) return false; 
        
        Chunk chunk = world.getChunkFromBlockCoords(pos);
        int storageY = pos.getY() >> 4;
        
        return chunk.getBlockStorageArray()[storageY] != null;
    }

    /**
     * 在客户端世界设置一个幽灵方块。
     */
    public static void setGhostBlock(WorldClient world, BlockPos pos, BlockStateProxy state) throws CommandException {
        if (world.isRemote) {
            Block block = Block.getBlockById(state.blockId);
            if (block != null) {
                world.setBlockState(pos, block.getStateFromMeta(state.metadata), 3);
                world.checkLightFor(EnumSkyBlock.BLOCK, pos);
                world.checkLightFor(EnumSkyBlock.SKY, pos);
            } else {
                LogUtil.error("log.error.setGhostBlock.invalidId", state.blockId);
                throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_block"));
            }
        }
    }
    
    /**
     * 为坐标参数提供Tab补全建议。
     */
    public static List<String> getCoordinateSuggestions(ICommandSender sender, int coordinateIndex, BlockPos targetPos) {
        List<String> suggestions = new ArrayList<>();

        if (sender instanceof EntityPlayer) {
            EntityPlayer player = (EntityPlayer) sender;
            int playerCoord = 0;
            switch (coordinateIndex) {
                case 0: playerCoord = (int) Math.floor(player.posX); break;
                case 1: playerCoord = (int) Math.floor(player.posY); break;
                case 2: playerCoord = (int) Math.floor(player.posZ); break;
            }
            suggestions.add(String.valueOf(playerCoord));
        } else if (targetPos == null) {
            suggestions.add("0");
        }
        
        suggestions.add("~");

        if (targetPos != null) {
            switch (coordinateIndex) {
                case 0: suggestions.add(String.valueOf(targetPos.getX())); break;
                case 1: suggestions.add(String.valueOf(targetPos.getY())); break;
                case 2: suggestions.add(String.valueOf(targetPos.getZ())); break;
            }
        }

        return suggestions.stream().distinct().collect(Collectors.toList());
    }

    public static boolean hasFlag(String[] args, String... flags) {
        for (int i = 0; i < args.length - 1; i++) {
            for (String flag : flags) {
                if (args[i].equalsIgnoreCase(flag)) {
                    return true;
                }
            }
        }
        return false;
    }

    public static boolean containsIgnoreCase(List<String> list, String target) {
        if (target == null) return false;
        return list.stream().anyMatch(s -> target.equalsIgnoreCase(s));
    }
    
    public static String formatIdList(Collection<?> ids) {
        return String.join(", ", ids.stream().map(Object::toString).collect(Collectors.toList()));
    }
    
    /**
     * 创建带格式的进度消息组件。
     */
    public static IChatComponent createProgressMessage(String key, int percent, String progressBar) {
        String rawMessage = LangUtil.translate(key, "{0}", "{1}");
        String[] parts = rawMessage.split("\\{(\\d)\\}", -1);
        IChatComponent message = new ChatComponentText("");
        message.appendSibling(new ChatComponentText(LangUtil.translate("ghost.generic.prefix.default")).setChatStyle(new ChatStyle().setColor(EnumChatFormatting.DARK_GRAY)));
        if (parts.length > 0) message.appendSibling(new ChatComponentText(parts[0]).setChatStyle(new ChatStyle().setColor(LABEL_COLOR)));
        message.appendSibling(new ChatComponentText(percent + "%").setChatStyle(new ChatStyle().setColor(VALUE_COLOR)));
        if (parts.length > 1) message.appendSibling(new ChatComponentText(parts[1]).setChatStyle(new ChatStyle().setColor(LABEL_COLOR)));
        message.appendSibling(new ChatComponentText(progressBar));
        if (parts.length > 2) message.appendSibling(new ChatComponentText(parts[2]).setChatStyle(new ChatStyle().setColor(LABEL_COLOR)));
        return message;
    }
    
    /**
     * 创建进度条样式的字符串。
     */
    public static String createProgressBar(float progressPercent, int length) {
        int progress = (int) (progressPercent / 100 * length);
        progress = Math.min(progress, length);
        progress = Math.max(0, progress);
        StringBuilder sb = new StringBuilder();
        sb.append(EnumChatFormatting.GREEN);
        for (int i = 0; i < progress; i++) sb.append("=");
        if (progress < length) {
            sb.append(EnumChatFormatting.GOLD).append(">");
            sb.append(EnumChatFormatting.GRAY);
            for (int i = progress + 1; i < length; i++) sb.append("-");
        }
        return sb.toString();
    }
}


features/ghostblock/GhostBlockState.java:
package com.zihaomc.ghost.features.ghostblock;

import com.zihaomc.ghost.features.ghostblock.tasks.ClearTask;
import com.zihaomc.ghost.features.ghostblock.tasks.FillTask;
import com.zihaomc.ghost.features.ghostblock.tasks.LoadTask;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import net.minecraft.command.ICommandSender;
import net.minecraft.util.BlockPos;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 集中存储 GhostBlock 功能的所有状态。
 * 包括：活动任务、撤销历史、挂起的确认请求等。
 */
public class GhostBlockState {

    // --- 任务管理 ---
    public static final AtomicInteger taskIdCounter = new AtomicInteger(0);
    public static final Map<Integer, TaskSnapshot> pausedTasks = new HashMap<>();
    public static final List<FillTask> activeFillTasks = Collections.synchronizedList(new ArrayList<>());
    public static final List<LoadTask> activeLoadTasks = Collections.synchronizedList(new ArrayList<>());
    public static final List<ClearTask> activeClearTasks = Collections.synchronizedList(new ArrayList<>());

    // --- 撤销/重做 ---
    public static final List<UndoRecord> undoHistory = new ArrayList<>();

    // --- 清除确认 ---
    public static final Map<String, ClearConfirmation> pendingConfirmations = new HashMap<>();
    public static final int CONFIRMATION_TIMEOUT = 30 * 1000; // 30秒

    // --- 内部数据结构 ---

    /**
     * 代表一次可撤销的操作记录。
     */
    public static class UndoRecord {
        public enum OperationType {
            SET, FILL, LOAD, CLEAR_BLOCK, CLEAR_FILE
        }

        public final String undoFileName;
        public final Map<String, List<GhostBlockData.GhostBlockEntry>> fileBackups;
        public final OperationType operationType;
        public final Integer relatedTaskId;
        public final String commandString;
        public final String details;

        public UndoRecord(String undoFileName, Map<String, List<GhostBlockData.GhostBlockEntry>> fileBackups, OperationType type, Integer relatedTaskId, String commandString, String details) {
            this.undoFileName = undoFileName;
            this.fileBackups = fileBackups != null ? new HashMap<>(fileBackups) : new HashMap<>();
            this.operationType = type;
            this.relatedTaskId = relatedTaskId;
            this.commandString = commandString != null ? commandString : "";
            this.details = details != null ? details : "";
        }
    }

    /**
     * 代表一个待确认的清除文件操作。
     */
    public static class ClearConfirmation {
        public final long timestamp;
        public final List<File> targetFiles;

        public ClearConfirmation(List<File> targetFiles, long timestamp) {
            this.timestamp = timestamp;
            this.targetFiles = Collections.unmodifiableList(new ArrayList<>(targetFiles));
        }
    }

    /**
     * 方块状态的轻量级代理。
     */
    public static class BlockStateProxy {
        public final int blockId;
        public final int metadata;

        public BlockStateProxy(int blockId, int metadata) {
            this.blockId = blockId;
            this.metadata = metadata;
        }
    }

    /**
     * 用于保存已暂停任务的状态快照。
     */
    public static class TaskSnapshot {
        public final String type;
        public final List<BlockPos> remainingBlocks;
        public final List<GhostBlockData.GhostBlockEntry> remainingEntries;
        public final int batchSize;
        public final int total;
        public final BlockStateProxy state;
        public final boolean saveToFile;
        public final String saveFileName;
        public final ICommandSender sender;
        public final int taskId;
        public final List<GhostBlockData.GhostBlockEntry> entriesToSaveForUserFile;

        public TaskSnapshot(FillTask task) {
            this.type = "fill";
            this.remainingBlocks = new ArrayList<>(task.getRemainingBlocks());
            this.batchSize = task.getBatchSize();
            this.total = task.getTotalBlocks();
            this.state = task.getState();
            this.saveToFile = task.isSaveToFile();
            this.saveFileName = task.getSaveFileName();
            this.sender = task.getSender();
            this.taskId = task.getTaskId();
            this.remainingEntries = null;
            this.entriesToSaveForUserFile = task.getEntriesToSaveForUserFile() != null ? new ArrayList<>(task.getEntriesToSaveForUserFile()) : new ArrayList<>();
        }

        public TaskSnapshot(LoadTask task) {
            this.type = "load";
            this.remainingEntries = task.getRemainingEntries();
            this.batchSize = task.getBatchSize();
            this.total = task.getTotalEntries();
            this.state = null;
            this.saveToFile = false;
            this.saveFileName = null;
            this.sender = task.getSender();
            this.taskId = task.getTaskId();
            this.remainingBlocks = null;
            this.entriesToSaveForUserFile = null;
        }
    }
}


features/ghostblock/GhostBlockCommand.java:
package com.zihaomc.ghost.features.ghostblock;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.handlers.*;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.BlockPos;

import java.util.*;

/**
 * GhostBlock 命令的主类 (重构后)。
 * 它现在作为一个调度器（Dispatcher），将子命令分发给各自的处理器类。
 * 本身不再处理事件、维护状态或执行具体的命令逻辑。
 */
public class GhostBlockCommand extends CommandBase {

    /**
     * 一个映射，存储子命令名称与其对应的处理器实例。
     */
    private final Map<String, ICommandHandler> commandHandlers = new HashMap<>();

    /**
     * 一个有序的、用于 Tab 补全的列表。
     */
    private static final List<String> SUB_COMMANDS_FOR_TAB = Arrays.asList(
            "set",
            "fill",
            "load",
            "clear",
            "undo",
            "history",
            "cancel",
            "resume",
            "help"
    );

    /**
     * 构造函数，在创建命令实例时初始化并注册所有子命令的处理器。
     */
    public GhostBlockCommand() {
        commandHandlers.put("set", new SetHandler());
        commandHandlers.put("fill", new FillHandler());
        commandHandlers.put("load", new LoadHandler());
        commandHandlers.put("clear", new ClearHandler());
        commandHandlers.put("cancel", new CancelHandler());
        commandHandlers.put("resume", new ResumeHandler());
        commandHandlers.put("undo", new UndoHandler());
        commandHandlers.put("history", new HistoryHandler()); 
        commandHandlers.put("help", new HelpHandler());
        // confirm_clear 仍然是一个有效的命令处理器，但不会出现在 Tab 补全中
        commandHandlers.put("confirm_clear", new ConfirmClearHandler());
    }

    @Override
    public String getCommandName() {
        return "cghostblock";
    }

    @Override
    public List<String> getCommandAliases() {
        return Collections.singletonList("cgb");
    }

    @Override
    public String getCommandUsage(ICommandSender sender) {
        return LangUtil.translate("ghostblock.commands.usage");
    }
    
    @Override
    public int getRequiredPermissionLevel() {
        return 0; // 客户端命令
    }
    
    @Override
    public boolean canCommandSenderUseCommand(ICommandSender sender) {
        return true; // 对所有客户端玩家可用
    }

    @Override
    public void processCommand(ICommandSender sender, String[] args) throws CommandException {
        if (args.length == 0 || args[0].equalsIgnoreCase("help")) {
            commandHandlers.get("help").processCommand(sender, null, args);
            return;
        }
        
        String subCommand = args[0].toLowerCase();
        ICommandHandler handler = commandHandlers.get(subCommand);

        if (handler != null) {
            WorldClient world = Minecraft.getMinecraft().theWorld;
            // 检查子命令是否需要一个有效的世界实例
            boolean worldRequired = !Arrays.asList("help", "cancel", "resume", "history").contains(subCommand);
            
            if (worldRequired && world == null) {
                throw new CommandException(LangUtil.translate("ghostblock.commands.error.not_in_world"));
            }
            // 将处理逻辑委托给找到的处理器
            handler.processCommand(sender, world, args);
        } else {
            // 如果找不到对应的处理器，抛出用法错误
            throw new WrongUsageException(getCommandUsage(sender));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length == 1) {
            // 使用有序列表进行补全
            return getListOfStringsMatchingLastWord(args, SUB_COMMANDS_FOR_TAB);
        }

        String subCommand = args[0].toLowerCase();
        ICommandHandler handler = commandHandlers.get(subCommand);

        if (handler != null) {
            return handler.addTabCompletionOptions(sender, args, pos);
        }

        return Collections.emptyList();
    }
}

features/ghostblock/tasks/ClearTask.java:
package com.zihaomc.ghost.features.ghostblock.tasks;

import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.ICommandSender;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;

import java.io.File;
import java.util.List;

/**
 * 代表一个后台批量清除幽灵方块的任务。
 */
public class ClearTask {
    private final WorldClient world;
    private final List<GhostBlockData.GhostBlockEntry> entries;
    private int currentIndex;
    private final int batchSize;
    private final ICommandSender sender;
    private long lastUpdateTime = 0;
    private float lastReportedPercent = -1;
    private volatile boolean cancelled = false;
    private final int taskId;
    private final File autoClearFile;

    public ClearTask(WorldClient world, List<GhostBlockData.GhostBlockEntry> entries,
                     int batchSize, ICommandSender sender, int taskId,
                     File autoClearFile) {
        this.world = world;
        this.entries = entries;
        this.batchSize = batchSize;
        this.sender = sender;
        this.currentIndex = 0;
        this.taskId = taskId;
        this.autoClearFile = autoClearFile;
    }

    public boolean processBatch() {
        if (cancelled) {
            return true;
        }

        int endIndex = Math.min(currentIndex + batchSize, entries.size());

        for (int i = currentIndex; i < endIndex; i++) {
            if (cancelled) break; 
            
            GhostBlockData.GhostBlockEntry entry = entries.get(i);
            BlockPos pos = new BlockPos(entry.x, entry.y, entry.z);
            Block originalBlock = Block.getBlockFromName(entry.originalBlockId);
            if (originalBlock != null) { 
                try {
                    world.setBlockState(pos, originalBlock.getStateFromMeta(entry.originalMetadata), 3);
                    world.markBlockForUpdate(pos);
                } catch (Exception e) {
                    LogUtil.error("log.error.clear.task.restore.failed", pos, e.getMessage());
                }
            } else {
                LogUtil.error("log.error.clear.task.originalBlock.notFound", entry.originalBlockId, pos);
            }
        }
        currentIndex = endIndex;

        if (cancelled) return true;

        boolean finished = currentIndex >= entries.size();

        if (finished) {
            sendFinalProgress();
        } else {
            float currentPercent = (currentIndex * 100.0f) / entries.size();
            sendProgressIfNeeded(currentPercent, false);
        }
        return finished;
    }

    private void sendProgressIfNeeded(float currentPercent, boolean forceSend) {
        currentPercent = Math.round(currentPercent * 10) / 10.0f;
        boolean shouldSend = forceSend || Math.abs(currentPercent - lastReportedPercent) >= 0.1f || System.currentTimeMillis() - lastUpdateTime > 1000;

        if (shouldSend) {
            String progressBar = GhostBlockHelper.createProgressBar(currentPercent, 10);
            IChatComponent message = GhostBlockHelper.createProgressMessage("ghostblock.commands.clear.progress", (int) currentPercent, progressBar);
            sender.addChatMessage(message);
            lastReportedPercent = currentPercent;
            lastUpdateTime = System.currentTimeMillis();
        }
    }

    private void sendFinalProgress() {
        sendProgressIfNeeded(100.0f, true); 
        
        if (!cancelled) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(GhostBlockHelper.FINISH_COLOR, "ghostblock.commands.clear.finish", entries.size()));
        }

        if (autoClearFile != null && autoClearFile.exists()) {
            boolean deleted = autoClearFile.delete();
            LogUtil.info("log.info.clear.task.file.deleted", autoClearFile.getName(), deleted);
            if (!deleted && !cancelled) {
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED, "ghostblock.commands.clear.block.delete_failed", autoClearFile.getName()));
            }
        } else if (autoClearFile != null) {
            LogUtil.info("log.info.clear.task.file.notFound", autoClearFile.getName());
        }
    }

    public void cancel() {
        this.cancelled = true;
    }

    public int getTaskId() {
        return taskId;
    }
}


features/ghostblock/tasks/LoadTask.java:
package com.zihaomc.ghost.features.ghostblock.tasks;

import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.BlockPos;
import net.minecraft.util.IChatComponent;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * 代表一个后台批量从文件加载幽灵方块的任务。
 */
public class LoadTask {
    private volatile boolean cancelled = false;
    private final WorldClient world;
    private final List<GhostBlockData.GhostBlockEntry> entries;
    private int currentIndex;
    private final int batchSize;
    private final ICommandSender sender;
    private long lastUpdateTime = 0;
    private float lastReportedPercent = -1;
    private final int taskId;
    private final Set<Integer> previouslyWaitingForLoadOrProximityIndices = new HashSet<>();
    private static final double TASK_PLACEMENT_PROXIMITY_SQ = 32.0 * 32.0;
    
    public LoadTask(WorldClient world, List<GhostBlockData.GhostBlockEntry> entriesToLoad, int batchSize,
                    ICommandSender sender, int taskId) {
        this.world = world;
        this.entries = entriesToLoad != null ? new ArrayList<>(entriesToLoad) : new ArrayList<>();
        this.batchSize = Math.max(1, batchSize);
        this.sender = sender;
        this.currentIndex = 0;
        this.taskId = taskId;
        LogUtil.info("log.info.task.load.init", taskId, this.entries.size(), this.batchSize);
    }

    public boolean processBatch() {
        if (cancelled || entries.isEmpty() || currentIndex >= entries.size()) {
            if (!cancelled && !entries.isEmpty() && lastReportedPercent < 100.0f) {
                sendFinalProgress();
            }
            return true;
        }

        int successfullyProcessedThisTick = 0;
        EntityPlayer currentPlayer = (sender instanceof EntityPlayer) ? (EntityPlayer) sender : null;
        if (currentPlayer != null && (!currentPlayer.isEntityAlive() || currentPlayer.worldObj != this.world)) {
            LogUtil.info("log.info.task.load.playerInvalid", taskId);
            this.cancel();
            return true;
        }

        for (int i = 0; i < batchSize && currentIndex < entries.size(); ) {
            if (cancelled) break;

            GhostBlockData.GhostBlockEntry entry = entries.get(currentIndex);
            BlockPos pos = new BlockPos(entry.x, entry.y, entry.z);
            boolean canPlaceNow = checkPlacementConditions(pos, currentPlayer, currentIndex);
            
            if (canPlaceNow) {
                Block block = Block.getBlockFromName(entry.blockId);
                if (block != null) {
                    try {
                        IBlockState blockStateToSet = block.getStateFromMeta(entry.metadata);
                        world.setBlockState(pos, blockStateToSet, 3);
                        successfullyProcessedThisTick++;
                    } catch (Exception e) {
                        LogUtil.printStackTrace("log.warn.task.load.placeError", e, taskId, pos, currentIndex, e.getMessage());
                    }
                } else {
                    LogUtil.warn("log.warn.task.load.invalidBlock", taskId, entry.blockId, pos, currentIndex);
                }
                currentIndex++;
                i++;
            } else {
                if (pos.getY() < 0 || pos.getY() >= 256) {
                    LogUtil.debug("log.info.task.load.posInvalidY", taskId, pos.getY(), pos, currentIndex);
                    currentIndex++;
                    i++;
                } else {
                    break;
                }
            }
        }

        if (cancelled) return true;

        boolean finished = currentIndex >= entries.size();
        if (finished) {
            sendFinalProgress();
        } else {
            float currentPercent = entries.isEmpty() ? 100.0f : (currentIndex * 100.0f) / entries.size();
            boolean forceUpdate = successfullyProcessedThisTick > 0;
            sendProgressIfNeeded(currentPercent, forceUpdate);
        }
        return finished;
    }

    private boolean checkPlacementConditions(BlockPos pos, EntityPlayer player, int index) {
        if (pos.getY() < 0 || pos.getY() >= 256) {
            return false;
        }
        if (GhostBlockHelper.isBlockSectionReady(world, pos)) {
            if (player != null && player.getDistanceSqToCenter(pos) > TASK_PLACEMENT_PROXIMITY_SQ) {
                if (previouslyWaitingForLoadOrProximityIndices.add(index)) {
                    LogUtil.debug("log.info.task.load.posWaiting", taskId, pos, index, "玩家距离远");
                }
                return false;
            }
            previouslyWaitingForLoadOrProximityIndices.remove(index);
            return true;
        }
        if (previouslyWaitingForLoadOrProximityIndices.add(index)) {
            LogUtil.debug("log.info.task.load.posWaiting", taskId, pos, index, "isBlockLoaded=false");
        }
        return false;
    }

    private void sendProgressIfNeeded(float currentPercent, boolean forceSend) {
        if (entries.isEmpty()) currentPercent = 100.0f;
        currentPercent = Math.min(100.0f, Math.max(0.0f, currentPercent));
        currentPercent = Math.round(currentPercent * 10) / 10.0f;

        boolean shouldSend = forceSend || Math.abs(currentPercent - lastReportedPercent) >= 0.1f || System.currentTimeMillis() - lastUpdateTime > 1000;

        if (shouldSend && currentPercent <= 100.0f) {
            String progressBar = GhostBlockHelper.createProgressBar(currentPercent, 10);
            IChatComponent message = GhostBlockHelper.createProgressMessage("ghostblock.commands.load.progress", (int) Math.floor(currentPercent), progressBar);
            
            if (sender instanceof EntityPlayer) {
                EntityPlayer player = (EntityPlayer) sender;
                if (Minecraft.getMinecraft().theWorld == null || !player.isEntityAlive() || player.worldObj != Minecraft.getMinecraft().theWorld) {
                    if(!cancelled) LogUtil.info("log.info.task.load.playerLeft.progress", taskId);
                    this.cancel();
                    return;
                }
            }
            try {
                sender.addChatMessage(message);
            } catch (Exception e) {
                LogUtil.error("log.error.task.load.progress.sendFailed", taskId, e.getMessage());
            }
            lastReportedPercent = currentPercent;
            lastUpdateTime = System.currentTimeMillis();
        }
    }

    private void sendFinalProgress() {
        if (lastReportedPercent < 100.0f && !cancelled) {
            sendProgressIfNeeded(100.0f, true);
        }
        if (!cancelled) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(GhostBlockHelper.FINISH_COLOR, "ghostblock.commands.load.finish", entries.size()));
        } else {
            LogUtil.info("log.info.task.load.cancelled", taskId);
        }
    }
    
    public void cancel() {
        if (!this.cancelled) {
            LogUtil.info("log.info.task.load.markedCancelled", taskId);
            this.cancelled = true;
            previouslyWaitingForLoadOrProximityIndices.clear();
        }
    }
    
    public int getTaskId() { return taskId; }
    public List<GhostBlockData.GhostBlockEntry> getRemainingEntries() {
        return (entries != null && currentIndex < entries.size())
                ? new ArrayList<>(entries.subList(currentIndex, entries.size()))
                : new ArrayList<>();
    }
    public int getBatchSize() { return batchSize; }
    public int getTotalEntries() { return entries.size(); }
    public ICommandSender getSender() { return sender; }
}


features/ghostblock/tasks/FillTask.java:
package com.zihaomc.ghost.features.ghostblock.tasks;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.BlockStateProxy;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;

import java.util.*;

/**
 * 代表一个后台批量填充幽灵方块的任务。
 */
public class FillTask {
    final WorldClient world;
    final BlockStateProxy state;
    final List<BlockPos> remainingBlocks;
    final int batchSize;
    final boolean saveToFile;
    final String saveFileName;
    final ICommandSender sender;
    private final int totalBlocks;
    private int processedCount = 0;
    private long lastUpdateTime = 0;
    private float lastReportedPercent = -1;
    private volatile boolean cancelled = false;
    private final int taskId;
    private final List<GhostBlockData.GhostBlockEntry> entriesToSaveForUserFile;
    private final Set<BlockPos> previouslyWaitingForLoadOrProximity = new HashSet<>();
    private static final double TASK_PLACEMENT_PROXIMITY_SQ = 32.0 * 32.0;

    public FillTask(WorldClient world, BlockStateProxy state, List<BlockPos> allBlocks,
                    int batchSize, boolean saveToFile, String saveFileName, ICommandSender sender, int taskId,
                    List<GhostBlockData.GhostBlockEntry> entriesToSaveForUserFile) {
        this.world = world;
        this.state = state;
        this.remainingBlocks = new ArrayList<>(allBlocks);
        this.totalBlocks = this.remainingBlocks.size();
        this.batchSize = Math.max(1, batchSize);
        this.saveToFile = saveToFile;
        this.saveFileName = saveFileName;
        this.sender = sender;
        this.taskId = taskId;
        this.entriesToSaveForUserFile = entriesToSaveForUserFile != null ? new ArrayList<>(entriesToSaveForUserFile) : new ArrayList<>();
        this.processedCount = 0;
        LogUtil.info("log.info.task.fill.init", taskId, this.totalBlocks, this.batchSize);
    }

    public boolean processBatch() {
        if (cancelled) {
            return true;
        }

        Block block = Block.getBlockById(state.blockId);
        if (block == null) {
            if (processedCount == 0 && !cancelled) {
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED, "ghostblock.commands.error.invalid_block"));
                LogUtil.error("log.error.task.fill.invalidBlock", taskId, state.blockId);
                this.cancel();
            }
            return true;
        }

        int attemptsThisTick = 0;
        int successfullyProcessedThisTick = 0;
        Iterator<BlockPos> iterator = remainingBlocks.iterator();

        EntityPlayer currentPlayer = (sender instanceof EntityPlayer) ? (EntityPlayer) sender : null;
        if (currentPlayer != null && (!currentPlayer.isEntityAlive() || currentPlayer.worldObj != this.world)) {
            LogUtil.info("log.info.task.fill.playerInvalid", taskId);
            this.cancel();
            return true;
        }

        while (iterator.hasNext() && attemptsThisTick < batchSize) {
            if (cancelled) break;
            
            BlockPos pos = iterator.next();
            attemptsThisTick++;

            boolean canPlaceNow = checkPlacementConditions(pos, currentPlayer);

            if (canPlaceNow) {
                if (previouslyWaitingForLoadOrProximity.remove(pos)) {
                    LogUtil.debug("log.info.task.fill.posReady", taskId, pos);
                }
                try {
                    IBlockState blockStateToSet = block.getStateFromMeta(state.metadata);
                    world.setBlockState(pos, blockStateToSet, 3);
                    iterator.remove();
                    successfullyProcessedThisTick++;
                    processedCount++;
                } catch (Exception e) {
                    LogUtil.printStackTrace("log.warn.task.fill.placeError", e, taskId, pos, e.getMessage());
                    iterator.remove();
                }
            } else {
                if (pos.getY() < 0 || pos.getY() >= 256) {
                    LogUtil.debug("log.info.task.fill.posInvalidY", taskId, pos.getY(), pos);
                    iterator.remove();
                } else {
                    break;
                }
            }
        }

        if (cancelled) {
            return true;
        }

        boolean finished = remainingBlocks.isEmpty();

        if (finished) {
            LogUtil.info("log.info.task.fill.complete.log", taskId, processedCount, totalBlocks);
            sendFinalProgress();
        } else {
            float currentPercent = (totalBlocks == 0) ? 100.0f : (processedCount * 100.0f) / totalBlocks;
            boolean forceUpdate = successfullyProcessedThisTick > 0;
            sendProgressIfNeeded(currentPercent, forceUpdate);
        }
        return finished;
    }

    private boolean checkPlacementConditions(BlockPos pos, EntityPlayer player) {
        if (pos.getY() < 0 || pos.getY() >= 256) {
            return false;
        }
        if (GhostBlockHelper.isBlockSectionReady(world, pos)) {
            if (player != null) {
                if (player.getDistanceSqToCenter(pos) <= TASK_PLACEMENT_PROXIMITY_SQ) {
                    return true;
                } else {
                    if (previouslyWaitingForLoadOrProximity.add(pos)) {
                        LogUtil.debug("log.info.task.fill.posWaiting", taskId, pos, "玩家距离远");
                    }
                    return false;
                }
            }
            return true;
        }
        if (previouslyWaitingForLoadOrProximity.add(pos)) {
            LogUtil.debug("log.info.task.fill.posWaiting", taskId, pos, "isBlockLoaded=false");
        }
        return false;
    }

    private void sendProgressIfNeeded(float currentPercent, boolean forceSend) {
        if (totalBlocks == 0) currentPercent = 100.0f;
        currentPercent = Math.min(100.0f, Math.max(0.0f, currentPercent));
        currentPercent = Math.round(currentPercent * 10) / 10.0f;

        boolean shouldSend = forceSend || Math.abs(currentPercent - lastReportedPercent) >= 0.1f || System.currentTimeMillis() - lastUpdateTime > 1000;

        if (shouldSend && currentPercent <= 100.0f) {
            String progressBar = GhostBlockHelper.createProgressBar(currentPercent, 10);
            IChatComponent message = GhostBlockHelper.createProgressMessage("ghostblock.commands.fill.progress", (int) Math.floor(currentPercent), progressBar);
            
            if (sender instanceof EntityPlayer) {
                EntityPlayer player = (EntityPlayer) sender;
                if (Minecraft.getMinecraft().theWorld == null || !player.isEntityAlive() || player.worldObj != Minecraft.getMinecraft().theWorld) {
                    if(!cancelled) LogUtil.info("log.info.task.fill.playerLeft.progress", taskId);
                    this.cancel();
                    return;
                }
            }
            try {
                sender.addChatMessage(message);
            } catch (Exception e) {
                LogUtil.error("log.error.task.fill.progress.sendFailed", taskId, e.getMessage());
            }
            lastReportedPercent = currentPercent;
            lastUpdateTime = System.currentTimeMillis();
        }
    }

    private void sendFinalProgress() {
        if (lastReportedPercent < 100.0f && !cancelled) {
            sendProgressIfNeeded(100.0f, true);
        }

        if (saveToFile && !cancelled) {
            String actualSaveFileName = (saveFileName == null) ? GhostBlockData.getWorldIdentifier(world) : saveFileName;
            if (this.entriesToSaveForUserFile != null && !this.entriesToSaveForUserFile.isEmpty()) {
                LogUtil.debug("log.info.task.fill.save.userFile", taskId, this.entriesToSaveForUserFile.size(), actualSaveFileName);
                GhostBlockData.saveData(world, this.entriesToSaveForUserFile, actualSaveFileName, false);
                String displayName = (saveFileName == null) ? LangUtil.translate("ghostblock.displayname.default_file", GhostBlockData.getWorldIdentifier(world)) : saveFileName;
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.save.success", displayName));
            } else {
                LogUtil.warn("log.warn.task.fill.save.noEntries", taskId);
            }
        }

        if (!cancelled) {
            String finishKey = (totalBlocks == 1 && processedCount <= 1) ? "ghostblock.commands.fill.finish_single" : "ghostblock.commands.fill.finish";
            sender.addChatMessage(GhostBlockHelper.formatMessage(GhostBlockHelper.FINISH_COLOR, finishKey, processedCount));
        } else {
            LogUtil.info("log.info.task.fill.cancelled", taskId);
        }
    }

    public void cancel() {
        if (!this.cancelled) {
            LogUtil.info("log.info.task.fill.markedCancelled", taskId);
            this.cancelled = true;
            previouslyWaitingForLoadOrProximity.clear();
        }
    }

    public int getTaskId() { return taskId; }
    public List<BlockPos> getRemainingBlocks() { return remainingBlocks; }
    public int getBatchSize() { return batchSize; }
    public int getTotalBlocks() { return totalBlocks; }
    public BlockStateProxy getState() { return state; }
    public boolean isSaveToFile() { return saveToFile; }
    public String getSaveFileName() { return saveFileName; }
    public ICommandSender getSender() { return sender; }
    public List<GhostBlockData.GhostBlockEntry> getEntriesToSaveForUserFile() { return entriesToSaveForUserFile; }
}


features/ghostblock/handlers/FillHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.BlockStateProxy;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.UndoRecord;
import com.zihaomc.ghost.features.ghostblock.tasks.FillTask;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData.GhostBlockEntry;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.BlockPos;

import java.util.*;
import java.util.stream.Collectors;

public class FillHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        String fullCommand = "/cgb " + String.join(" ", args);
        
        if (args.length < 8) {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.cghostblock.fill.usage"));
        }
        
        BlockPos from = GhostBlockHelper.parseBlockPosLegacy(sender, args, 1);
        BlockPos to = GhostBlockHelper.parseBlockPosLegacy(sender, args, 4);
        BlockStateProxy state = GhostBlockHelper.parseBlockState(sender, args[7]);
        Block block = Block.getBlockById(state.blockId);

        if (block == null) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_block"));
        }

        boolean configForceBatch = GhostConfig.FillCommand.alwaysBatchFill;
        int configForcedSize = GhostConfig.FillCommand.forcedBatchSize;

        boolean useBatch = configForceBatch;
        int batchSize = 100;
        boolean userProvidedBatchFlag = false;
        boolean userProvidedBatchSize = false;

        boolean saveToFile = false;
        String saveFileName = null;
        boolean userProvidedSave = false;

        for (int i = 8; i < args.length; ) {
            String flag = args[i].toLowerCase();
            if (flag.equals("-b") || flag.equals("--batch")) {
                userProvidedBatchFlag = true;
                useBatch = true;
                i++;
                if (i < args.length && GhostBlockHelper.isNumber(args[i])) {
                    try {
                        batchSize = Integer.parseInt(args[i]);
                        GhostBlockHelper.validateBatchSize(batchSize);
                        userProvidedBatchSize = true;
                        i++;
                    } catch (NumberFormatException | CommandException e) {
                        throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_batch_size"));
                    }
                }
            } else if (flag.equals("-s") || flag.equals("--save")) {
                userProvidedSave = true;
                saveToFile = true;
                i++;
                if (i < args.length && !args[i].startsWith("-")) {
                    saveFileName = args[i];
                    if ("filename".equalsIgnoreCase(saveFileName) || saveFileName.trim().isEmpty()) {
                        saveFileName = null;
                    }
                    i++;
                } else {
                    saveFileName = null;
                }
            } else {
                throw new WrongUsageException(LangUtil.translate("ghostblock.commands.cghostblock.fill.usage"));
            }
        }

        if (useBatch && !userProvidedBatchSize) {
            batchSize = (configForceBatch && configForcedSize > 0) ? configForcedSize : 100;
        }
        if (!userProvidedSave && GhostConfig.SaveOptions.enableAutoSave) {
            saveToFile = true;
            saveFileName = GhostConfig.SaveOptions.defaultSaveFileName;
            if (saveFileName == null || saveFileName.trim().isEmpty() || saveFileName.equalsIgnoreCase("default")) {
                saveFileName = null;
            }
        }

        List<BlockPos> allBlocks = new ArrayList<>();
        int minX = Math.min(from.getX(), to.getX());
        int maxX = Math.max(from.getX(), to.getX());
        int minY = Math.min(from.getY(), to.getY());
        int maxY = Math.max(from.getY(), to.getY());
        int minZ = Math.min(from.getZ(), to.getZ());
        int maxZ = Math.max(from.getZ(), to.getZ());

        long volume = (long)(maxX - minX + 1) * (maxY - minY + 1) * (maxZ - minZ + 1);
        if (volume > Integer.MAX_VALUE) {
            LogUtil.warn("log.warn.fill.largeVolume", volume);
        }

        for (int x = minX; x <= maxX; x++) {
            for (int y = minY; y <= maxY; y++) {
                for (int z = minZ; z <= maxZ; z++) {
                    allBlocks.add(new BlockPos(x, y, z));
                }
            }
        }

        if (allBlocks.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.fill.empty_area"));
            return;
        }

        List<GhostBlockEntry> autoEntries = collectOriginalBlocks(world, allBlocks, state);
        if (!autoEntries.isEmpty()) {
            GhostBlockData.saveData(world, autoEntries, GhostBlockHelper.getAutoClearFileName(world), false);
        }

        boolean implicitBatchRequired = false;
        if (!useBatch && !allBlocks.isEmpty() && volume < 32768) {
            for (BlockPos pos : allBlocks) {
                if (!GhostBlockHelper.isBlockSectionReady(world, pos)) {
                    implicitBatchRequired = true;
                    if (!userProvidedBatchFlag) {
                        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.fill.implicit_batch_notice"));
                    }
                    break;
                }
            }
        } else if (volume >= 32768) {
            implicitBatchRequired = true;
            if (!useBatch) useBatch = true;
        }
        
        Integer taskId = (useBatch || implicitBatchRequired) ? GhostBlockState.taskIdCounter.incrementAndGet() : null;

        String baseId = GhostBlockData.getWorldBaseIdentifier(world);
        String undoFileName = "undo_" + baseId + "_dim_" + world.provider.getDimensionId() + "_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
        GhostBlockData.saveData(world, autoEntries, undoFileName, true);
        Map<String, List<GhostBlockEntry>> fileBackups = new HashMap<>();
        if (saveToFile) {
            String actualSaveFileName = (saveFileName == null) ? GhostBlockData.getWorldIdentifier(world) : saveFileName;
            List<GhostBlockEntry> existingEntries = GhostBlockData.loadData(world, Collections.singletonList(actualSaveFileName));
            fileBackups.put(actualSaveFileName, existingEntries);
        }
        
        String details = String.format("%d %s", allBlocks.size(), args[7]);

        GhostBlockState.undoHistory.add(0, new UndoRecord(undoFileName, fileBackups, UndoRecord.OperationType.FILL, taskId, fullCommand, details));


        if (taskId != null) {
            FillTask task = new FillTask(world, state, allBlocks, batchSize, saveToFile, saveFileName, sender, taskId, autoEntries);
            GhostBlockState.activeFillTasks.add(task);
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY, "ghostblock.commands.fill.batch_started", taskId, allBlocks.size(), batchSize));
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.AQUA, "ghostblock.commands.task.chunk_aware_notice"));
        } else {
            int count = 0;
            for(BlockPos pos : allBlocks) {
                GhostBlockHelper.setGhostBlock(world, pos, state);
                count++;
            }
            if (saveToFile) {
                String actualSaveFileName = (saveFileName == null) ? GhostBlockData.getWorldIdentifier(world) : saveFileName;
                if (!autoEntries.isEmpty()) {
                    GhostBlockData.saveData(world, autoEntries, actualSaveFileName, false);
                    String displayName = (saveFileName == null) ? LangUtil.translate("ghostblock.displayname.default_file", GhostBlockData.getWorldIdentifier(world)) : saveFileName;
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.save.success", displayName));
                }
            }
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.cghostblock.fill.success", count));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        int currentArgIndex = args.length - 1;
        if (currentArgIndex >= 1 && currentArgIndex <= 3) {
            return CommandBase.getListOfStringsMatchingLastWord(args, GhostBlockHelper.getCoordinateSuggestions(sender, currentArgIndex - 1, Minecraft.getMinecraft().objectMouseOver != null ? Minecraft.getMinecraft().objectMouseOver.getBlockPos() : null));
        } else if (currentArgIndex >= 4 && currentArgIndex <= 6) {
            return CommandBase.getListOfStringsMatchingLastWord(args, GhostBlockHelper.getCoordinateSuggestions(sender, currentArgIndex - 4, Minecraft.getMinecraft().objectMouseOver != null ? Minecraft.getMinecraft().objectMouseOver.getBlockPos() : null));
        } else if (currentArgIndex == 7) {
            return CommandBase.getListOfStringsMatchingLastWord(args, Block.blockRegistry.getKeys());
        } else if (currentArgIndex >= 8) {
            String prevArg = args[currentArgIndex - 1].toLowerCase();
            String prefix = args[currentArgIndex].toLowerCase();
            if (prevArg.equals("-s") || prevArg.equals("--save")) {
                List<String> suggestions = new ArrayList<>(GhostBlockHelper.getAvailableFileNames());
                suggestions.add(0, "filename");
                return CommandBase.getListOfStringsMatchingLastWord(args, suggestions);
            }
            if (prevArg.equals("-b") || prevArg.equals("--batch")) {
                if (!GhostBlockHelper.isNumber(prefix)) {
                    return CommandBase.getListOfStringsMatchingLastWord(args, Arrays.asList("100", "500", "1000"));
                }
            }
            List<String> suggestions = new ArrayList<>();
            if (!GhostBlockHelper.hasFlag(args, "-b", "--batch") && !(prevArg.equals("-b") || prevArg.equals("--batch"))) {
                suggestions.add("-b");
            }
            if (!GhostBlockHelper.hasFlag(args, "-s", "--save") && !(prevArg.equals("-s") || prevArg.equals("--save"))) {
                suggestions.add("-s");
            }
            return CommandBase.getListOfStringsMatchingLastWord(args, suggestions);
        }
        return Collections.emptyList();
    }
    
    private List<GhostBlockEntry> collectOriginalBlocks(WorldClient world, List<BlockPos> blocks, BlockStateProxy state) {
        List<GhostBlockEntry> entries = new ArrayList<>();
        Block ghostBlock = (state != null) ? Block.getBlockById(state.blockId) : null;
        String ghostBlockId = (ghostBlock != null) ? ghostBlock.getRegistryName().toString() : "minecraft:air";
        int ghostMeta = (state != null) ? state.metadata : 0;
        String autoFileName = GhostBlockHelper.getAutoClearFileName(world);
        List<GhostBlockEntry> existingEntries = GhostBlockData.loadData(world, Collections.singletonList(autoFileName));
        Set<String> existingKeys = existingEntries.stream().map(e -> e.x + "," + e.y + "," + e.z).collect(Collectors.toSet());
        for (BlockPos pos : blocks) {
            String key = pos.getX() + "," + pos.getY() + "," + pos.getZ();
            if (existingKeys.contains(key)) continue;
            IBlockState originalState = world.getBlockState(pos);
            Block originalBlock = originalState.getBlock();
            entries.add(new GhostBlockEntry(pos, ghostBlockId, ghostMeta,
                    originalBlock.getRegistryName().toString(), originalBlock.getMetaFromState(originalState)));
        }
        return entries;
    }
}


features/ghostblock/handlers/LoadHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.UndoRecord;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.BlockStateProxy;
import com.zihaomc.ghost.features.ghostblock.tasks.LoadTask;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData.GhostBlockEntry;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.BlockPos;

import java.util.*;
import java.util.stream.Collectors;

public class LoadHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        String fullCommand = "/cgb " + String.join(" ", args);
        
        List<String> fileNames = new ArrayList<>();
        int loadBatchSize = 100;
        boolean useBatch = false;
        boolean explicitFilesProvided = false;

        for (int i = 1; i < args.length; i++) {
            String arg = args[i];
            if (arg.equalsIgnoreCase("-b") || arg.equalsIgnoreCase("--batch")) {
                useBatch = true;
                i++;
                if (i < args.length && GhostBlockHelper.isNumber(args[i])) {
                    try {
                        loadBatchSize = Integer.parseInt(args[i]);
                        GhostBlockHelper.validateBatchSize(loadBatchSize);
                    } catch (NumberFormatException | CommandException e) {
                        throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_batch_size"));
                    }
                } else {
                    i--;
                    loadBatchSize = 100;
                }
            } else if (!arg.startsWith("-")) {
                explicitFilesProvided = true;
                if (!arg.toLowerCase().startsWith("clear_") && !arg.toLowerCase().startsWith("undo_")) {
                    fileNames.add(arg);
                } else {
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.load.ignored_internal_file", arg));
                }
            } else {
                throw new WrongUsageException(LangUtil.translate("ghostblock.commands.cghostblock.load.usage"));
            }
        }

        if (!explicitFilesProvided || fileNames.isEmpty()) {
            String defaultFile = GhostBlockData.getWorldIdentifier(world);
            if (!defaultFile.toLowerCase().startsWith("clear_") && !defaultFile.toLowerCase().startsWith("undo_")) {
                fileNames.clear();
                fileNames.add(null);
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY, "ghostblock.commands.load.using_default_file"));
            } else {
                throw new CommandException(LangUtil.translate("ghostblock.commands.load.error.default_is_internal"));
            }
        }

        List<GhostBlockEntry> entries = GhostBlockData.loadData(world, fileNames);
        if (entries.isEmpty()) {
            String fileDescription = (fileNames.contains(null)) ? LangUtil.translate("ghostblock.displayname.default_file", GhostBlockData.getWorldIdentifier(world)) : String.join(", ", fileNames.stream().filter(Objects::nonNull).collect(Collectors.toList()));
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.load.empty_or_missing", fileDescription));
            return;
        }

        List<GhostBlockEntry> autoSaveEntries = collectOriginalBlocksForAutoSave(world, entries);
        if (!autoSaveEntries.isEmpty()) {
            GhostBlockData.saveData(world, autoSaveEntries, GhostBlockHelper.getAutoClearFileName(world), false);
        }

        boolean implicitBatchRequired = false;
        if (!useBatch && !entries.isEmpty()) {
            for (GhostBlockEntry entry : entries) {
                if (!GhostBlockHelper.isBlockSectionReady(world, new BlockPos(entry.x, entry.y, entry.z))) {
                    implicitBatchRequired = true;
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.load.implicit_batch_notice"));
                    break;
                }
            }
        }
        
        Integer taskId = (useBatch || implicitBatchRequired) ? GhostBlockState.taskIdCounter.incrementAndGet() : null;

        String baseId = GhostBlockData.getWorldBaseIdentifier(world);
        String undoFileName = "undo_" + baseId + "_dim_" + world.provider.getDimensionId() + "_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
        GhostBlockData.saveData(world, autoSaveEntries, undoFileName, true);
        
        String fileDescription = fileNames.contains(null) ? 
            LangUtil.translate("ghostblock.displayname.default_file_simple") : 
            String.join(", ", fileNames);
        String details = String.format("%d %s", entries.size(), fileDescription);

        GhostBlockState.undoHistory.add(0, new UndoRecord(undoFileName, new HashMap<>(), UndoRecord.OperationType.LOAD, taskId, fullCommand, details));

        if (taskId != null) {
            int actualBatchSize = useBatch ? loadBatchSize : 100;
            GhostBlockState.activeLoadTasks.add(new LoadTask(world, entries, actualBatchSize, sender, taskId));
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY,"ghostblock.commands.load.batch_started", taskId, entries.size(), actualBatchSize));
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.AQUA, "ghostblock.commands.task.chunk_aware_notice"));
        } else {
            int successCount = 0;
            int failCount = 0;
            int skippedCount = 0;
            for (GhostBlockEntry entry : entries) {
                BlockPos pos = new BlockPos(entry.x, entry.y, entry.z);
                if (world.isBlockLoaded(pos)) {
                    Block block = Block.getBlockFromName(entry.blockId);
                    if (block != null) {
                        try {
                            GhostBlockHelper.setGhostBlock(world, pos, new BlockStateProxy(Block.getIdFromBlock(block), entry.metadata));
                            successCount++;
                        } catch (Exception e) {
                            failCount++;
                        }
                    } else {
                        failCount++;
                    }
                } else {
                    skippedCount++;
                }
            }
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.load.complete", successCount, entries.size()));
            if (failCount > 0) sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED, "ghostblock.commands.load.failed", failCount));
            if (skippedCount > 0) sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.task.sync_skipped", skippedCount));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        int currentArgIndex = args.length - 1;
        String prevArg = (currentArgIndex > 0) ? args[currentArgIndex - 1].toLowerCase() : "";
        String prefix = args[currentArgIndex].toLowerCase();
        if (prevArg.equals("-b") || prevArg.equals("--batch")) {
            if (!GhostBlockHelper.isNumber(prefix)) {
                return CommandBase.getListOfStringsMatchingLastWord(args, Arrays.asList("100", "500", "1000"));
            }
        }
        List<String> suggestions = new ArrayList<>();
        List<String> allFiles = GhostBlockHelper.getAvailableFileNames();
        List<String> enteredFiles = new ArrayList<>();
        for (int i = 1; i < args.length -1 ; i++) {
            String current = args[i];
            String previous = (i>0) ? args[i-1] : "";
            if (!current.startsWith("-") && !( (previous.equalsIgnoreCase("-b") || previous.equalsIgnoreCase("--batch")) && GhostBlockHelper.isNumber(current) )) {
                enteredFiles.add(current);
            }
        }
        allFiles.stream().filter(file -> !GhostBlockHelper.containsIgnoreCase(enteredFiles, file)).forEach(suggestions::add);
        if (!GhostBlockHelper.hasFlag(args, "-b", "--batch") && !(prevArg.equals("-b") || prevArg.equals("--batch"))) {
            suggestions.add("-b");
        }
        return CommandBase.getListOfStringsMatchingLastWord(args, suggestions);
    }
    
    private List<GhostBlockEntry> collectOriginalBlocksForAutoSave(WorldClient world, List<GhostBlockEntry> entriesToLoad) {
        List<GhostBlockEntry> validAutoSaveEntries = new ArrayList<>();
        String autoFileName = GhostBlockHelper.getAutoClearFileName(world);
        List<GhostBlockEntry> existingAutoEntries = GhostBlockData.loadData(world, Collections.singletonList(autoFileName));
        Set<String> existingKeys = existingAutoEntries.stream().map(e -> e.x + "," + e.y + "," + e.z).collect(Collectors.toSet());
        for (GhostBlockEntry loadedEntry : entriesToLoad) {
            BlockPos pos = new BlockPos(loadedEntry.x, loadedEntry.y, loadedEntry.z);
            String key = pos.getX() + "," + pos.getY() + "," + pos.getZ();
            if (!existingKeys.contains(key)) {
                IBlockState originalState = world.getBlockState(pos);
                Block originalBlock = originalState.getBlock();
                validAutoSaveEntries.add(new GhostBlockEntry(pos, loadedEntry.blockId, loadedEntry.metadata,
                        originalBlock.getRegistryName().toString(), originalBlock.getMetaFromState(originalState)));
            }
        }
        return validAutoSaveEntries;
    }
}


features/ghostblock/handlers/ICommandHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.util.BlockPos;

import java.util.List;

public interface ICommandHandler {
    void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException;
    List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos);
}

features/ghostblock/handlers/SetHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.BlockStateProxy;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.UndoRecord;
import com.zihaomc.ghost.features.ghostblock.tasks.FillTask;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData.GhostBlockEntry;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.BlockPos;

import java.util.*;
import java.util.stream.Collectors;

public class SetHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        String fullCommand = "/cgb " + String.join(" ", args);
        
        if (args.length < 5) {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.cghostblock.set.usage"));
        }
        
        BlockPos pos = GhostBlockHelper.parseBlockPosLegacy(sender, args, 1);
        BlockStateProxy state = GhostBlockHelper.parseBlockState(sender, args[4]);
        Block block = Block.getBlockById(state.blockId);
        
        if (block == null) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_block"));
        }

        String saveFileName = null;
        boolean saveToFile = false;
        boolean userProvidedSave = false;
        if (args.length > 5) {
            if (args[5].equalsIgnoreCase("-s") || args[5].equalsIgnoreCase("--save")) {
                userProvidedSave = true;
                saveToFile = true;
                if (args.length > 6) {
                    saveFileName = args[6];
                    if ("filename".equalsIgnoreCase(saveFileName) || saveFileName.trim().isEmpty()) {
                        saveFileName = null;
                    }
                }
                if (args.length > 7) {
                    throw new WrongUsageException(LangUtil.translate("ghostblock.commands.cghostblock.set.usage"));
                }
            } else {
                throw new WrongUsageException(LangUtil.translate("ghostblock.commands.cghostblock.set.usage"));
            }
        }

        if (!userProvidedSave && GhostConfig.SaveOptions.enableAutoSave) {
            saveToFile = true;
            saveFileName = GhostConfig.SaveOptions.defaultSaveFileName;
            if (saveFileName == null || saveFileName.trim().isEmpty() || saveFileName.equalsIgnoreCase("default")) {
                saveFileName = null;
            }
        }

        List<BlockPos> positions = Collections.singletonList(pos);
        List<GhostBlockEntry> autoEntries = collectOriginalBlocks(world, positions, state);
        if (!autoEntries.isEmpty()) {
            GhostBlockData.saveData(world, autoEntries, GhostBlockHelper.getAutoClearFileName(world), false);
        }

        boolean sectionIsReady = GhostBlockHelper.isBlockSectionReady(world, pos);
        Integer taskId = (!sectionIsReady) ? GhostBlockState.taskIdCounter.incrementAndGet() : null;

        String baseId = GhostBlockData.getWorldBaseIdentifier(world);
        String undoFileName = "undo_" + baseId + "_dim_" + world.provider.getDimensionId() + "_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
        GhostBlockData.saveData(world, autoEntries, undoFileName, true);
        Map<String, List<GhostBlockEntry>> fileBackups = new HashMap<>();
        if (saveToFile) {
            String actualSaveFileName = (saveFileName == null) ? GhostBlockData.getWorldIdentifier(world) : saveFileName;
            List<GhostBlockEntry> existingEntries = GhostBlockData.loadData(world, Collections.singletonList(actualSaveFileName));
            fileBackups.put(actualSaveFileName, existingEntries);
        }

        String details = String.format("%d,%d,%d %s", pos.getX(), pos.getY(), pos.getZ(), args[4]);
        
        GhostBlockState.undoHistory.add(0, new UndoRecord(undoFileName, fileBackups, UndoRecord.OperationType.SET, taskId, fullCommand, details));


        if (taskId == null) {
            if (saveToFile) {
                String actualSaveFileName = (saveFileName == null) ? GhostBlockData.getWorldIdentifier(world) : saveFileName;
                IBlockState currentOriginalState = world.getBlockState(pos);
                Block currentOriginalBlock = currentOriginalState.getBlock();
                List<GhostBlockEntry> userEntryToSave = Collections.singletonList(
                        new GhostBlockEntry(pos, block.getRegistryName().toString(), state.metadata,
                                currentOriginalBlock.getRegistryName().toString(), currentOriginalBlock.getMetaFromState(currentOriginalState)));
                GhostBlockData.saveData(world, userEntryToSave, actualSaveFileName, false);
                String displayName = (saveFileName == null) ? LangUtil.translate("ghostblock.displayname.default_file", GhostBlockData.getWorldIdentifier(world)) : saveFileName;
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.save.success", displayName));
            }
            GhostBlockHelper.setGhostBlock(world, pos, state);
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.cghostblock.set.success", pos.getX(), pos.getY(), pos.getZ()));
        } else {
            List<GhostBlockEntry> entryForTaskSave = new ArrayList<>();
            if (saveToFile && !autoEntries.isEmpty()) {
                entryForTaskSave.add(autoEntries.get(0));
            }
            FillTask task = new FillTask(world, state, positions, 1, saveToFile, saveFileName, sender, taskId, entryForTaskSave);
            GhostBlockState.activeFillTasks.add(task);
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.cghostblock.set.deferred", pos.getX(), pos.getY(), pos.getZ()));
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.AQUA, "ghostblock.commands.task.chunk_aware_notice"));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        int currentArgIndex = args.length - 1;
        if (currentArgIndex >= 1 && currentArgIndex <= 3) {
            return CommandBase.getListOfStringsMatchingLastWord(args, GhostBlockHelper.getCoordinateSuggestions(sender, currentArgIndex - 1, Minecraft.getMinecraft().objectMouseOver != null ? Minecraft.getMinecraft().objectMouseOver.getBlockPos() : null));
        } else if (currentArgIndex == 4) {
            return CommandBase.getListOfStringsMatchingLastWord(args, Block.blockRegistry.getKeys());
        } else if (currentArgIndex == 5) {
            if (!GhostBlockHelper.hasFlag(args, "-s", "--save")) {
                return CommandBase.getListOfStringsMatchingLastWord(args, Arrays.asList("-s", "--save"));
            }
        } else if (currentArgIndex == 6) {
            String prevArg = args[currentArgIndex - 1];
            if (prevArg.equalsIgnoreCase("-s") || prevArg.equalsIgnoreCase("--save")) {
                List<String> suggestions = new ArrayList<>(GhostBlockHelper.getAvailableFileNames());
                suggestions.add(0, "filename");
                return CommandBase.getListOfStringsMatchingLastWord(args, suggestions);
            }
        }
        return Collections.emptyList();
    }
    
    private List<GhostBlockEntry> collectOriginalBlocks(WorldClient world, List<BlockPos> blocks, BlockStateProxy state) {
        List<GhostBlockEntry> entries = new ArrayList<>();
        Block ghostBlock = (state != null) ? Block.getBlockById(state.blockId) : null;
        String ghostBlockId = (ghostBlock != null) ? ghostBlock.getRegistryName().toString() : "minecraft:air";
        int ghostMeta = (state != null) ? state.metadata : 0;

        String autoFileName = GhostBlockHelper.getAutoClearFileName(world);
        List<GhostBlockEntry> existingEntries = GhostBlockData.loadData(world, Collections.singletonList(autoFileName));
        Set<String> existingKeys = existingEntries.stream().map(e -> e.x + "," + e.y + "," + e.z).collect(Collectors.toSet());

        for (BlockPos pos : blocks) {
            String key = pos.getX() + "," + pos.getY() + "," + pos.getZ();
            if (existingKeys.contains(key)) continue;
            IBlockState originalState = world.getBlockState(pos);
            Block originalBlock = originalState.getBlock();
            entries.add(new GhostBlockEntry(pos, ghostBlockId, ghostMeta,
                    originalBlock.getRegistryName().toString(), originalBlock.getMetaFromState(originalState)));
        }
        return entries;
    }
}


features/ghostblock/handlers/HistoryHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.UndoRecord;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.event.HoverEvent;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;

import java.util.Collections;
import java.util.List;

public class HistoryHandler implements ICommandHandler {
    
    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        if (GhostBlockState.undoHistory.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.undo.empty"));
            return;
        }

        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GOLD, "ghostblock.commands.history.header"));
        int limit = Math.min(10, GhostBlockState.undoHistory.size());

        for (int i = 0; i < limit; i++) {
            UndoRecord record = GhostBlockState.undoHistory.get(i);
            String description;

            switch (record.operationType) {
                case SET:
                    String[] setDetails = record.details.split(" ");
                    description = LangUtil.translate("ghostblock.commands.history.entry.desc.set", setDetails[0], setDetails[1]);
                    break;
                case FILL:
                    String[] fillDetails = record.details.split(" ");
                    description = LangUtil.translate("ghostblock.commands.history.entry.desc.fill", fillDetails[0], fillDetails[1]);
                    break;
                case LOAD:
                    String[] loadDetails = record.details.split(" ", 2);
                    description = LangUtil.translate("ghostblock.commands.history.entry.desc.load", loadDetails[0], loadDetails[1]);
                    break;
                case CLEAR_BLOCK:
                    description = LangUtil.translate("ghostblock.commands.history.entry.desc.clear_block", record.details);
                    break;
                case CLEAR_FILE:
                    description = LangUtil.translate("ghostblock.commands.history.entry.desc.clear_file", record.details);
                    break;
                default:
                    description = "Unknown Operation";
                    break;
            }

            ChatComponentText lineComponent = new ChatComponentText(
                LangUtil.translate("ghostblock.commands.history.entry.format", i + 1, description)
            );
            
            ChatComponentText hoverText = new ChatComponentText(record.commandString);
            hoverText.getChatStyle().setColor(EnumChatFormatting.GRAY);
            HoverEvent hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverText);
            lineComponent.setChatStyle(new ChatStyle().setChatHoverEvent(hoverEvent));

            sender.addChatMessage(lineComponent);
        }

        if (GhostBlockState.undoHistory.size() > limit) {
             sender.addChatMessage(new ChatComponentText("  " + EnumChatFormatting.GRAY + "..."));
        }
        
        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY, "ghostblock.commands.history.usage_hint"));
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        return Collections.emptyList();
    }
}

features/ghostblock/handlers/ClearHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.ClearConfirmation;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.UndoRecord;
import com.zihaomc.ghost.features.ghostblock.tasks.ClearTask;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData.GhostBlockEntry;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.event.ClickEvent;
import net.minecraft.event.ClickEvent.Action;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

public class ClearHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        if (args.length < 2) {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.clear.usage"));
        }
        String clearType = args[1].toLowerCase();
        if ("file".equals(clearType)) {
            handleClearFile(sender, world, args);
        } else if ("block".equals(clearType)) {
            handleClearBlock(sender, world, args);
        } else {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.clear.usage"));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        int currentArgIndex = args.length - 1;
        if (currentArgIndex == 1) {
            return CommandBase.getListOfStringsMatchingLastWord(args, Arrays.asList("file", "block"));
        }
        if (currentArgIndex >= 2) {
            String clearType = args[1].toLowerCase();
            if ("file".equals(clearType)) {
                List<String> allFiles = GhostBlockHelper.getAvailableFileNames();
                List<String> enteredFiles = Arrays.asList(args).subList(2, args.length -1);
                List<String> availableForCompletion = allFiles.stream().filter(file -> !GhostBlockHelper.containsIgnoreCase(enteredFiles, file)).collect(Collectors.toList());
                return CommandBase.getListOfStringsMatchingLastWord(args, availableForCompletion);
            } else if ("block".equals(clearType)) {
                List<String> suggestions = new ArrayList<>();
                String lastFullArg = (args.length > 2) ? args[args.length - 2].toLowerCase() : "";
                boolean hasBatchFlag = GhostBlockHelper.hasFlag(args, "-b", "--batch");
                boolean hasConfirmFlag = GhostBlockHelper.hasFlag(args, "confirm");
                if (lastFullArg.equals("-b") || lastFullArg.equals("--batch")) {
                    if (!GhostBlockHelper.isNumber(args[args.length-1])) {
                        suggestions.addAll(Arrays.asList("100", "500", "1000"));
                    }
                    if (!hasConfirmFlag) suggestions.add("confirm");
                } else {
                    if (!hasBatchFlag) suggestions.add("-b");
                    if (!hasConfirmFlag) suggestions.add("confirm");
                }
                return CommandBase.getListOfStringsMatchingLastWord(args, suggestions);
            }
        }
        return Collections.emptyList();
    }

    private void handleClearFile(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        if (args.length < 3) {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.clear.usage.file_missing_args"));
        }
        List<String> fileNames = Arrays.asList(args).subList(2, args.length);
        List<File> targetFiles = new ArrayList<>();
        List<String> missingFiles = new ArrayList<>();
        List<String> validFileNamesForMessage = new ArrayList<>();

        for (String fileName : fileNames) {
            String baseFileName = fileName.toLowerCase().endsWith(".json") ? fileName.substring(0, fileName.length() - 5) : fileName;
            if (baseFileName.startsWith("clear_") || baseFileName.startsWith("undo_")) {
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.load.ignored_internal_file", fileName));
                continue;
            }
            File file = GhostBlockData.getDataFile(world, baseFileName);
            if (file.exists()) {
                targetFiles.add(file);
                validFileNamesForMessage.add(baseFileName);
            } else {
                missingFiles.add(fileName);
            }
        }

        if (targetFiles.isEmpty()) {
            if (!missingFiles.isEmpty()) {
                 throw new CommandException(LangUtil.translate("ghostblock.commands.clear.missing_files", String.join(", ", missingFiles)));
            } else {
                 throw new CommandException(LangUtil.translate("ghostblock.commands.clear.error.no_valid_files_to_delete"));
            }
        }
        if (!missingFiles.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, LangUtil.translate("ghostblock.commands.clear.missing_files", String.join(", ", missingFiles))));
        }

        String confirmCommand = "/cgb confirm_clear " + String.join(" ", validFileNamesForMessage);
        IChatComponent message = new ChatComponentText("")
                .appendSibling(new ChatComponentText(EnumChatFormatting.GOLD + LangUtil.translate("ghostblock.commands.clear.confirm.question") + "\n"))
                .appendSibling(new ChatComponentText(EnumChatFormatting.WHITE + String.join(", ", validFileNamesForMessage) + "\n"))
                .appendSibling(new ChatComponentText(LangUtil.translate("ghostblock.commands.clear.confirm.button"))
                        .setChatStyle(new ChatStyle().setColor(EnumChatFormatting.RED).setBold(true)
                                .setChatClickEvent(new ClickEvent(Action.RUN_COMMAND, confirmCommand))));

        sender.addChatMessage(message);
        GhostBlockState.pendingConfirmations.put(sender.getName(), new ClearConfirmation(targetFiles, System.currentTimeMillis()));
    }

    private void handleClearBlock(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        String fullCommand = "/cgb " + String.join(" ", args);
        
        boolean batchMode = false;
        int batchSize = 100;
        boolean confirmed = false;

        for (int i = 2; i < args.length; ) {
            String flag = args[i].toLowerCase();
            if (flag.equals("-b") || flag.equals("--batch")) {
                batchMode = true;
                i++;
                if (i < args.length && GhostBlockHelper.isNumber(args[i])) {
                    try {
                        batchSize = Integer.parseInt(args[i]);
                        GhostBlockHelper.validateBatchSize(batchSize);
                        i++;
                    } catch (NumberFormatException | CommandException e) {
                         throw new CommandException(LangUtil.translate("ghostblock.commands.error.invalid_batch_size"));
                    }
                }
            } else if (flag.equals("confirm")) {
                confirmed = true;
                i++;
            } else {
                throw new WrongUsageException(LangUtil.translate("ghostblock.commands.clear.usage.block"));
            }
        }

        String autoFileName = GhostBlockHelper.getAutoClearFileName(world);
        List<GhostBlockEntry> entries = GhostBlockData.loadData(world, Collections.singletonList(autoFileName));
        File autoFile = GhostBlockData.getDataFile(world, autoFileName);

        if (entries.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.clear.block.no_blocks"));
            return;
        }

        if (!confirmed) {
            sendConfirmationMessage(sender, batchMode, batchSize);
        } else {
            Integer taskId = batchMode ? GhostBlockState.taskIdCounter.incrementAndGet() : null;

            String details = String.valueOf(entries.size());
            
            createClearUndoRecord(world, entries, taskId, fullCommand, details);

            if (taskId != null) {
                GhostBlockState.activeClearTasks.add(new ClearTask(world, entries, batchSize, sender, taskId, autoFile));
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY,"ghostblock.commands.clear.batch_started", taskId, entries.size(), batchSize));
            } else {
                clearAllGhostBlocksSync(sender, world, entries);
                if (autoFile.exists() && !autoFile.delete()) {
                    LogUtil.error("log.error.worldLoad.clearFile.deleteFailed", autoFile.getPath());
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED, "ghostblock.commands.clear.block.delete_failed", autoFile.getName()));
                }
            }
        }
    }
    
    private void clearAllGhostBlocksSync(ICommandSender sender, WorldClient world, List<GhostBlockEntry> entries) {
        int restored = 0;
        int failed = 0;
        for (GhostBlockEntry entry : entries) {
            try {
                BlockPos pos = new BlockPos(entry.x, entry.y, entry.z);
                Block originalBlock = Block.getBlockFromName(entry.originalBlockId);
                if (originalBlock == null) {
                    failed++;
                    continue;
                }
                world.setBlockState(pos, originalBlock.getStateFromMeta(entry.originalMetadata), 3);
                world.markBlockForUpdate(pos);
                restored++;
            } catch (Exception e) {
                failed++;
                LogUtil.printStackTrace("log.error.clear.task.restore.failed", e, entry.x + "," + entry.y + "," + entry.z, e.getMessage());
            }
        }
        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.clear.block.success", restored));
        if (failed > 0) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED, "ghostblock.commands.clear.block.partial_fail", restored, failed));
        }
    }
    
    private void createClearUndoRecord(WorldClient world, List<GhostBlockEntry> clearedEntries, Integer taskId, String commandString, String details) {
        String baseId = GhostBlockData.getWorldBaseIdentifier(world);
        String undoFileName = "undo_clear_block_" + baseId + "_dim_" + world.provider.getDimensionId() + "_" + System.currentTimeMillis();
        GhostBlockData.saveData(world, clearedEntries, undoFileName, true);
        GhostBlockState.undoHistory.add(0, new UndoRecord(undoFileName, new HashMap<>(), UndoRecord.OperationType.CLEAR_BLOCK, taskId, commandString, details));
        LogUtil.info("log.info.undo.created.clearBlock", undoFileName);
    }

    private void sendConfirmationMessage(ICommandSender sender, boolean batchMode, int batchSize) {
        StringBuilder confirmCommand = new StringBuilder("/cgb clear block");
        if (batchMode) confirmCommand.append(" -b ").append(batchSize);
        confirmCommand.append(" confirm");
        IChatComponent message = new ChatComponentText("")
                .appendSibling(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghostblock.commands.clear.block.confirm.question") + "\n"))
                .appendSibling(new ChatComponentText(LangUtil.translate("ghostblock.commands.clear.block.confirm.button"))
                        .setChatStyle(new ChatStyle().setColor(EnumChatFormatting.RED).setBold(true)
                                .setChatClickEvent(new ClickEvent(Action.RUN_COMMAND, confirmCommand.toString()))));
        sender.addChatMessage(message);
    }
}


features/ghostblock/handlers/CancelHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.TaskSnapshot;
import com.zihaomc.ghost.features.ghostblock.tasks.ClearTask;
import com.zihaomc.ghost.features.ghostblock.tasks.FillTask;
import com.zihaomc.ghost.features.ghostblock.tasks.LoadTask;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumChatFormatting;

import java.util.*;
import java.util.stream.Collectors;

public class CancelHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        if (args.length < 2) {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.cancel.usage"));
        }

        List<Integer> successIds = new ArrayList<>();
        List<String> invalidIds = new ArrayList<>();

        for (int i = 1; i < args.length; i++) {
            String taskIdStr = args[i];
            try {
                int taskId = Integer.parseInt(taskIdStr);
                boolean found = cancelTask(taskId);
                if (found) {
                    successIds.add(taskId);
                } else {
                    invalidIds.add(taskIdStr);
                }
            } catch (NumberFormatException e) {
                invalidIds.add(taskIdStr);
            }
        }

        if (!successIds.isEmpty()) {
            String successMsg = LangUtil.translate("ghostblock.commands.cancel.success.multi",
                    successIds.size(), GhostBlockHelper.formatIdList(successIds));
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, successMsg));
        }

        if (!invalidIds.isEmpty()) {
            String errorMsg = LangUtil.translate("ghostblock.commands.cancel.invalid_ids",
                    GhostBlockHelper.formatIdList(invalidIds));
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED, errorMsg));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        List<String> taskIds = new ArrayList<>();
        synchronized(GhostBlockState.activeFillTasks) { GhostBlockState.activeFillTasks.forEach(t -> taskIds.add(String.valueOf(t.getTaskId()))); }
        synchronized(GhostBlockState.activeLoadTasks) { GhostBlockState.activeLoadTasks.forEach(t -> taskIds.add(String.valueOf(t.getTaskId()))); }
        synchronized(GhostBlockState.activeClearTasks) { GhostBlockState.activeClearTasks.forEach(t -> taskIds.add(String.valueOf(t.getTaskId()))); }
        taskIds.addAll(GhostBlockState.pausedTasks.keySet().stream().map(String::valueOf).collect(Collectors.toList()));
        
        List<String> existingTaskIds = Arrays.asList(args).subList(1, args.length - 1);
        taskIds.removeIf(existingTaskIds::contains);

        return CommandBase.getListOfStringsMatchingLastWord(args, taskIds);
    }
    
    private boolean cancelTask(int taskId) {
        boolean found = false;

        synchronized (GhostBlockState.activeFillTasks) {
            Iterator<FillTask> fillIter = GhostBlockState.activeFillTasks.iterator();
            while (fillIter.hasNext()) {
                FillTask task = fillIter.next();
                if (task.getTaskId() == taskId) {
                    task.cancel();
                    GhostBlockState.pausedTasks.put(taskId, new TaskSnapshot(task));
                    fillIter.remove();
                    found = true;
                    LogUtil.info("log.info.task.cancel.fill", taskId);
                    return true;
                }
            }
        }

        synchronized (GhostBlockState.activeLoadTasks) {
            Iterator<LoadTask> loadIter = GhostBlockState.activeLoadTasks.iterator();
            while (loadIter.hasNext()) {
                LoadTask task = loadIter.next();
                if (task.getTaskId() == taskId) {
                    task.cancel();
                    GhostBlockState.pausedTasks.put(taskId, new TaskSnapshot(task));
                    loadIter.remove();
                    found = true;
                    LogUtil.info("log.info.task.cancel.load", taskId);
                    return true;
                }
            }
        }

        synchronized (GhostBlockState.activeClearTasks) {
            Iterator<ClearTask> clearIter = GhostBlockState.activeClearTasks.iterator();
            while (clearIter.hasNext()) {
                ClearTask task = clearIter.next();
                if (task.getTaskId() == taskId) {
                    task.cancel();
                    clearIter.remove();
                    found = true;
                    LogUtil.info("log.info.task.cancel.clear", taskId);
                    return true;
                }
            }
        }

        if (GhostBlockState.pausedTasks.containsKey(taskId)) {
            GhostBlockState.pausedTasks.remove(taskId);
            found = true;
        }

        return found;
    }
}

features/ghostblock/handlers/ConfirmClearHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.ClearConfirmation;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.UndoRecord;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData.GhostBlockEntry;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumChatFormatting;

import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

public class ConfirmClearHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        if (!(sender instanceof EntityPlayer)) {
            throw new CommandException("commands.generic.player.unsupported");
        }
        if (args.length < 2) {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.clear.usage"));
        }

        List<String> filesToConfirm = Arrays.asList(args).subList(1, args.length);
        ClearConfirmation confirmation = GhostBlockState.pendingConfirmations.get(sender.getName());

        if (confirmation == null || System.currentTimeMillis() - confirmation.timestamp > GhostBlockState.CONFIRMATION_TIMEOUT) {
            GhostBlockState.pendingConfirmations.remove(sender.getName());
            throw new CommandException(LangUtil.translate("ghostblock.commands.clear.confirm_expired"));
        }

        Set<String> confirmationBaseFileNames = confirmation.targetFiles.stream()
                .map(f -> f.getName().replace(".json", ""))
                .collect(Collectors.toSet());
        Set<String> commandBaseFileNames = filesToConfirm.stream()
                .map(s -> s.replace(".json", ""))
                .collect(Collectors.toSet());

        if (!confirmationBaseFileNames.equals(commandBaseFileNames)) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.clear.confirm_expired"));
        }
        
        String descriptiveCommand = "/cgb clear file " + String.join(" ", commandBaseFileNames);
        String details = String.join(", ", commandBaseFileNames);

        Map<String, List<GhostBlockEntry>> fileBackups = new HashMap<>();
        for (String baseFileName : commandBaseFileNames) {
            List<GhostBlockEntry> entries = GhostBlockData.loadData(world, Collections.singletonList(baseFileName));
            fileBackups.put(baseFileName, entries);
        }

        String baseId = GhostBlockData.getWorldBaseIdentifier(world);
        String undoFileName = "undo_clear_file_" + baseId + "_dim_" + world.provider.getDimensionId() + "_" + System.currentTimeMillis();
        GhostBlockState.undoHistory.add(0, new UndoRecord(undoFileName, fileBackups, UndoRecord.OperationType.CLEAR_FILE, null, descriptiveCommand, details));
        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY,"ghostblock.commands.undo.record_created_clear"));

        List<String> deletedFiles = new ArrayList<>();
        List<String> failedFiles = new ArrayList<>();

        for (File file : confirmation.targetFiles) {
            if (file.exists()) {
                if (file.delete()) {
                    deletedFiles.add(file.getName());
                } else {
                    failedFiles.add(file.getName());
                }
            } else {
                LogUtil.info("log.info.clear.file.alreadyDeleted", file.getName());
            }
        }

        GhostBlockState.pendingConfirmations.remove(sender.getName());

        if (!deletedFiles.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN,
                    "ghostblock.commands.clear.success", String.join(", ", deletedFiles)));
        }
        if (!failedFiles.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED,
                    "ghostblock.commands.clear.failed", String.join(", ", failedFiles)));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        return Collections.emptyList();
    }
}


features/ghostblock/handlers/HelpHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockCommand;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;

import java.util.Collections;
import java.util.List;

public class HelpHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        displayHelp(sender);
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        return Collections.emptyList();
    }

    private void displayHelp(ICommandSender sender) {
        EnumChatFormatting hl = EnumChatFormatting.GOLD;
        EnumChatFormatting tx = EnumChatFormatting.GRAY;
        EnumChatFormatting sc = EnumChatFormatting.AQUA;
        EnumChatFormatting us = EnumChatFormatting.YELLOW;

        String commandName = new GhostBlockCommand().getCommandName();
        String commandAliases = String.join(", ", new GhostBlockCommand().getCommandAliases());

        sender.addChatMessage(new ChatComponentText(hl + LangUtil.translate("ghostblock.commands.cghostblock.help.header")));
        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.cghostblock.help.description")));
        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.cghostblock.help.usage.main") + ": " + us + "/" + commandName + " <set|fill|load|clear|...|help> [参数...]"));

        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommands.header")));
        sender.addChatMessage(formatHelpLine(sc + "help", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.help")));
        sender.addChatMessage(formatHelpLine(sc + "set", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.set") + us + " " + LangUtil.translate("ghostblock.commands.cghostblock.set.usage")));
        sender.addChatMessage(formatHelpLine(sc + "fill", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.fill") + us + " " + LangUtil.translate("ghostblock.commands.cghostblock.fill.usage")));
        sender.addChatMessage(formatHelpLine(sc + "load", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.load") + us + " " + LangUtil.translate("ghostblock.commands.cghostblock.load.usage")));
        sender.addChatMessage(formatHelpLine(sc + "clear", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.clear") + us + " " + LangUtil.translate("ghostblock.commands.clear.usage")));
        sender.addChatMessage(formatHelpLine(sc + "cancel", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.cancel") + us + " " + LangUtil.translate("ghostblock.commands.cancel.usage")));
        sender.addChatMessage(formatHelpLine(sc + "resume", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.resume") + us + " " + LangUtil.translate("ghostblock.commands.resume.usage")));
        sender.addChatMessage(formatHelpLine(sc + "undo", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.undo") + us + " " + LangUtil.translate("ghostblock.commands.undo.usage")));
        sender.addChatMessage(formatHelpLine(sc + "history", tx + LangUtil.translate("ghostblock.commands.cghostblock.help.subcommand.history") + us + " " + LangUtil.translate("ghostblock.commands.history.usage")));


        sender.addChatMessage(new ChatComponentText(tx + LangUtil.translate("ghostblock.commands.cghostblock.help.aliases") + ": " + hl + commandAliases));
    }

    private IChatComponent formatHelpLine(String command, String description) {
        ChatComponentText line = new ChatComponentText("  ");
        ChatComponentText cmdComp = new ChatComponentText(command);
        ChatComponentText descComp = new ChatComponentText(" - " + description);
        line.appendSibling(cmdComp);
        line.appendSibling(descComp);
        return line;
    }
}

features/ghostblock/handlers/ResumeHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.TaskSnapshot;
import com.zihaomc.ghost.features.ghostblock.tasks.FillTask;
import com.zihaomc.ghost.features.ghostblock.tasks.LoadTask;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumChatFormatting;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class ResumeHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        if (args.length < 2) {
            throw new WrongUsageException(LangUtil.translate("ghostblock.commands.resume.usage"));
        }

        int taskId;
        try {
            taskId = Integer.parseInt(args[1]);
        } catch (NumberFormatException e) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.resume.invalid_id", args[1]));
        }

        TaskSnapshot snapshot = GhostBlockState.pausedTasks.get(taskId);
        if (snapshot == null) {
            boolean isRunning = GhostBlockState.activeFillTasks.stream().anyMatch(t -> t.getTaskId() == taskId);
            if (!isRunning) isRunning = GhostBlockState.activeLoadTasks.stream().anyMatch(t -> t.getTaskId() == taskId);
            
            if (isRunning) {
                throw new CommandException(LangUtil.translate("ghostblock.commands.resume.error.already_running", taskId));
            } else {
                throw new CommandException(LangUtil.translate("ghostblock.commands.resume.invalid_id", taskId));
            }
        }

        if ("fill".equals(snapshot.type)) {
            FillTask newTask = new FillTask(world, snapshot.state, snapshot.remainingBlocks, snapshot.batchSize,
                    snapshot.saveToFile, snapshot.saveFileName, snapshot.sender, snapshot.taskId, snapshot.entriesToSaveForUserFile);
            GhostBlockState.activeFillTasks.add(newTask);
            GhostBlockState.pausedTasks.remove(taskId);
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.resume.success", taskId));
        } else if ("load".equals(snapshot.type)) {
            LoadTask newTask = new LoadTask(world, snapshot.remainingEntries, snapshot.batchSize, snapshot.sender, snapshot.taskId);
            GhostBlockState.activeLoadTasks.add(newTask);
            GhostBlockState.pausedTasks.remove(taskId);
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.resume.success", taskId));
        } else {
            GhostBlockState.pausedTasks.remove(taskId);
            throw new CommandException(LangUtil.translate("ghostblock.commands.resume.invalid_type"));
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        List<String> pausedIds = GhostBlockState.pausedTasks.keySet().stream().map(String::valueOf).collect(Collectors.toList());
        return CommandBase.getListOfStringsMatchingLastWord(args, pausedIds);
    }
}

features/ghostblock/handlers/UndoHandler.java:
package com.zihaomc.ghost.features.ghostblock.handlers;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.UndoRecord;
import com.zihaomc.ghost.features.ghostblock.GhostBlockState.BlockStateProxy;
import com.zihaomc.ghost.features.ghostblock.tasks.ClearTask;
import com.zihaomc.ghost.features.ghostblock.tasks.FillTask;
import com.zihaomc.ghost.features.ghostblock.tasks.LoadTask;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData.GhostBlockEntry;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.world.World;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

public class UndoHandler implements ICommandHandler {

    @Override
    public void processCommand(ICommandSender sender, WorldClient world, String[] args) throws CommandException {
        if (GhostBlockState.undoHistory.isEmpty()) {
            throw new CommandException(LangUtil.translate("ghostblock.commands.undo.empty"));
        }

        int index = 1; 
        if (args.length > 1) {
            try {
                index = Integer.parseInt(args[1]);
                if (index <= 0 || index > GhostBlockState.undoHistory.size()) {
                    throw new CommandException(LangUtil.translate("ghostblock.commands.undo.invalid_index", GhostBlockState.undoHistory.size()));
                }
            } catch (NumberFormatException e) {
                throw new WrongUsageException(LangUtil.translate("ghostblock.commands.undo.usage.extended"));
            }
        }

        UndoRecord record = GhostBlockState.undoHistory.remove(index - 1);

        if (record.relatedTaskId != null) {
            cancelRelatedTask(record.relatedTaskId);
        }

        restoreUserFileBackups(sender, world, record);
        handleCoreUndo(sender, world, record);
        deleteUndoDataFile(record, world);
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length == 2) {
            List<String> suggestions = new ArrayList<>();
            for (int i = 1; i <= GhostBlockState.undoHistory.size(); i++) {
                suggestions.add(String.valueOf(i));
            }
            return CommandBase.getListOfStringsMatchingLastWord(args, suggestions);
        }
        return Collections.emptyList();
    }
    
    private void cancelRelatedTask(int taskId) {
        boolean cancelled = false;
        synchronized (GhostBlockState.activeFillTasks) {
            for (FillTask task : GhostBlockState.activeFillTasks) {
                if (task.getTaskId() == taskId) {
                    task.cancel();
                    cancelled = true;
                    break;
                }
            }
        }
        if (!cancelled) {
            synchronized (GhostBlockState.activeLoadTasks) {
                for (LoadTask task : GhostBlockState.activeLoadTasks) {
                    if (task.getTaskId() == taskId) {
                        task.cancel();
                        cancelled = true;
                        break;
                    }
                }
            }
        }
        if (!cancelled) {
            synchronized (GhostBlockState.activeClearTasks) {
                for (ClearTask task : GhostBlockState.activeClearTasks) {
                    if (task.getTaskId() == taskId) {
                        task.cancel();
                        cancelled = true;
                        break;
                    }
                }
            }
        }
        if (cancelled) {
            LogUtil.info("log.info.undo.taskCancelled", taskId);
        }
    }

    private void restoreUserFileBackups(ICommandSender sender, WorldClient world, UndoRecord record) {
        if (record.fileBackups != null && !record.fileBackups.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY, "ghostblock.commands.undo.restoring_user_files"));
            for (Map.Entry<String, List<GhostBlockEntry>> entry : record.fileBackups.entrySet()) {
                String fileName = entry.getKey();
                List<GhostBlockEntry> backupEntries = entry.getValue();
                GhostBlockData.saveData(world, backupEntries, fileName, true);
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY,"ghostblock.commands.undo.user_file_restored", fileName));
            }
        }
    }

    private void handleCoreUndo(ICommandSender sender, WorldClient world, UndoRecord record) throws CommandException {
        File undoDataFile = GhostBlockData.getDataFile(world, record.undoFileName);
        List<GhostBlockEntry> entriesFromUndoFile = new ArrayList<>();
        if (undoDataFile.exists()) {
            entriesFromUndoFile = GhostBlockData.loadData(world, Collections.singletonList(record.undoFileName));
        }

        switch (record.operationType) {
            case SET:
                undoSetOperation(sender, world, entriesFromUndoFile);
                break;
            case CLEAR_BLOCK:
                undoClearOperation(sender, world, record, entriesFromUndoFile);
                break;
        }
    }
    
    private void undoSetOperation(ICommandSender sender, WorldClient world, List<GhostBlockEntry> entriesFromUndoFile) throws CommandException {
        if (entriesFromUndoFile.isEmpty()) {
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.undo.error.data_file_empty"));
            return;
        }
        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY, "ghostblock.commands.undo.restoring_blocks"));
        AtomicInteger restoredCount = new AtomicInteger();
        List<BlockPos> affectedPositions = new ArrayList<>();

        entriesFromUndoFile.forEach(entry -> {
            BlockPos pos = new BlockPos(entry.x, entry.y, entry.z);
            Block originalBlock = Block.getBlockFromName(entry.originalBlockId);
            if (originalBlock != null) {
                try {
                    world.setBlockState(pos, originalBlock.getStateFromMeta(entry.originalMetadata), 3);
                    world.markBlockForUpdate(pos);
                    restoredCount.incrementAndGet();
                    affectedPositions.add(pos);
                } catch (Exception e) {
                    LogUtil.error("log.error.undo.restore.set.failed", pos, e.getMessage());
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED,"ghostblock.commands.undo.error.restore_failed", pos.getX(), pos.getY(), pos.getZ(), e.getMessage()));
                }
            } else {
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED,"ghostblock.commands.undo.error_block_lookup", entry.originalBlockId, pos.getX(), pos.getY(), pos.getZ()));
            }
        });

        removeEntriesFromAutoClearFile(world, affectedPositions);
        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.undo.success_set", restoredCount.get()));
    }
    
    private void undoClearOperation(ICommandSender sender, WorldClient world, UndoRecord record, List<GhostBlockEntry> entriesFromUndoFile) throws CommandException {
        if (record.undoFileName.startsWith("undo_clear_file_")) {
            if (record.fileBackups != null && !record.fileBackups.isEmpty()) {
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghostblock.commands.undo.success_clear_file"));
            } else {
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghostblock.commands.undo.warning.no_files_to_restore"));
            }
        } else {
            if (entriesFromUndoFile.isEmpty()) {
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.YELLOW, "ghost.commands.undo.error.data_file_empty_ghost"));
                return;
            }
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY, "ghost.commands.undo.restoring_ghost_blocks"));
            AtomicInteger restoredCount = new AtomicInteger();
            List<GhostBlockEntry> restoredGhostEntries = new ArrayList<>();

            entriesFromUndoFile.forEach(entry -> {
                BlockPos pos = new BlockPos(entry.x, entry.y, entry.z);
                Block ghostBlock = Block.getBlockFromName(entry.blockId);
                if (ghostBlock != null && ghostBlock != Block.getBlockFromName("minecraft:air")) {
                    try {
                        GhostBlockHelper.setGhostBlock(world, pos, new BlockStateProxy(Block.getIdFromBlock(ghostBlock), entry.metadata));
                        restoredCount.incrementAndGet();
                        restoredGhostEntries.add(entry);
                    } catch (Exception e) {
                        LogUtil.error("log.error.undo.restore.clear.failed", pos, e.getMessage());
                        sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED,"ghost.commands.undo.error.restore_ghost_failed", pos.getX(), pos.getY(), pos.getZ(), e.getMessage()));
                    }
                } else {
                    sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.RED,"ghost.commands.undo.error_block_lookup", entry.blockId, pos.getX(), pos.getY(), pos.getZ()));
                }
            });

            if (!restoredGhostEntries.isEmpty()) {
                String autoFileName = GhostBlockHelper.getAutoClearFileName(world);
                GhostBlockData.saveData(world, restoredGhostEntries, autoFileName, false);
                sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GRAY,"ghost.commands.undo.auto_file_restored", restoredGhostEntries.size()));
            }
            sender.addChatMessage(GhostBlockHelper.formatMessage(EnumChatFormatting.GREEN, "ghost.commands.undo.success_clear", restoredCount.get()));
        }
    }

    private void deleteUndoDataFile(UndoRecord record, WorldClient world) {
        File undoDataFile = GhostBlockData.getDataFile(world, record.undoFileName);
        if (undoDataFile.exists()) {
            if (!undoDataFile.delete()) {
                LogUtil.error("log.error.undo.deleteFile.failed", undoDataFile.getPath());
            } else {
                LogUtil.info("log.info.undo.deleteFile.success", undoDataFile.getPath());
            }
        } else {
            LogUtil.info("log.info.undo.deleteFile.notFound", record.undoFileName);
        }
    }
    
    private void removeEntriesFromAutoClearFile(World world, List<BlockPos> positionsToRemove) {
        if (positionsToRemove.isEmpty()) return;
        String autoFileName = GhostBlockHelper.getAutoClearFileName((WorldClient) world);
        GhostBlockData.removeEntriesFromFile(world, autoFileName, positionsToRemove);
        LogUtil.info("log.info.undo.autoClearFile.updated", autoFileName, positionsToRemove.size());
    }
}


features/ghostblock/data/GhostBlockData.java:
package com.zihaomc.ghost.features.ghostblock.data;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.multiplayer.ServerData;
import net.minecraft.server.integrated.IntegratedServer;
import net.minecraft.util.BlockPos;
import net.minecraft.world.World;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class GhostBlockData {

    public static final Gson GSON = new Gson();
    // 注意：为了保持兼容性，配置文件的物理存储路径(config/Ghost/...)不需要改变
    // 这样玩家更新Mod后，旧数据依然存在
    private static final String CONFIG_DIR = "config/Ghost/GhostBlock/";
    public static final String SAVES_DIR = CONFIG_DIR + "saves/";
    private static final String FILE_EXTENSION = ".json";

    public static class GhostBlockEntry {
        public final int x, y, z;
        public final String blockId;
        public final int metadata;
        public final String originalBlockId;
        public final int originalMetadata;

        public GhostBlockEntry(BlockPos pos, String blockId, int metadata,
                               String originalBlockId, int originalMetadata) {
            this.x = pos.getX();
            this.y = pos.getY();
            this.z = pos.getZ();
            this.blockId = blockId;
            this.metadata = metadata;
            this.originalBlockId = originalBlockId;
            this.originalMetadata = originalMetadata;
        }
    }

    public static File getDataFile(World world, String fileName) {
        File savesDir = new File(SAVES_DIR);
        if (!savesDir.exists()) {
            savesDir.mkdirs();
        }

        if (fileName == null || fileName.isEmpty()) {
            return new File(savesDir, getWorldIdentifier(world) + FILE_EXTENSION);
        } else {
            return new File(savesDir, fileName + FILE_EXTENSION);
        }
    }

    public static void saveData(World world, List<GhostBlockEntry> entries, String fileName, boolean overwrite) {
        File file = getDataFile(world, fileName);
        file.getParentFile().mkdirs();

        List<GhostBlockEntry> entriesToSave;

        if (overwrite) {
            entriesToSave = new ArrayList<>(entries);
        } else {
            List<GhostBlockEntry> existingEntries = new ArrayList<>();
            if (file.exists()) {
                existingEntries = loadDataInternal(file);
            }

            Map<String, GhostBlockEntry> entryMap = new LinkedHashMap<>();
            for (GhostBlockEntry entry : existingEntries) {
                String key = entry.x + "," + entry.y + "," + entry.z;
                entryMap.put(key, entry);
            }
            for (GhostBlockEntry entry : entries) {
                String key = entry.x + "," + entry.y + "," + entry.z;
                entryMap.put(key, entry);
            }
            entriesToSave = new ArrayList<>(entryMap.values());
        }

        if (entriesToSave.isEmpty()) {
            if (file.exists()) {
                if (!file.delete()) {
                    LogUtil.error("log.error.data.deleteEmpty.failed", file.getPath());
                } else {
                    LogUtil.info("log.info.data.deleteEmpty.success", file.getPath());
                }
            }
            return;
        }

        try (Writer writer = new FileWriter(file)) {
            GSON.toJson(entriesToSave, writer);
        } catch (IOException e) {
            LogUtil.printStackTrace("log.error.data.save.failed", e, file.getPath());
        }
    }

    private static List<GhostBlockEntry> loadDataInternal(File file) {
        if (!file.exists()) {
            return new ArrayList<>();
        }
        try (Reader reader = new FileReader(file)) {
            java.lang.reflect.Type listType = new TypeToken<List<GhostBlockEntry>>() {}.getType();
            List<GhostBlockEntry> entries = GSON.fromJson(reader, listType);
            return entries != null ? entries : new ArrayList<>();
        } catch (Exception e) {
            LogUtil.printStackTrace("log.error.data.load.internal.failed", e, file.getPath());
            return new ArrayList<>();
        }
    }

    public static List<GhostBlockEntry> loadData(World world, List<String> fileNames) {
        List<GhostBlockEntry> allEntries = new ArrayList<>();
        for (String fileName : fileNames) {
            File file = getDataFile(world, fileName);
            if (!file.exists()) {
                if (fileName != null) {
                    LogUtil.info("log.info.data.load.notFound", fileName);
                }
                continue;
            }
            try (Reader reader = new FileReader(file)) {
                List<GhostBlockEntry> entries = GSON.fromJson(reader, new TypeToken<List<GhostBlockEntry>>() {}.getType());
                allEntries.addAll(entries);
            } catch (Exception e) {
                String displayName = (fileName == null) ? "default file" : fileName;
                LogUtil.printStackTrace("log.error.data.load.failed", e, displayName);
            }
        }
        return allEntries;
    }

    public static String getWorldBaseIdentifier(World world) {
        if (world.isRemote) {
            Minecraft mc = Minecraft.getMinecraft();
            if (mc.isSingleplayer()) {
                IntegratedServer server = mc.getIntegratedServer();
                return server != null ?
                        "singleplayer_" + sanitizeFileName(server.getWorldName()) :
                        "singleplayer_unknown";
            } else {
                ServerData server = mc.getCurrentServerData();
                if (server != null) {
                    String serverIP = server.serverIP;
                    String host = serverIP;
                    int port = 25565;

                    if (serverIP.startsWith("[")) {
                        int closingBracket = serverIP.indexOf(']');
                        if (closingBracket != -1) {
                            host = serverIP.substring(1, closingBracket);
                            String portPart = serverIP.substring(closingBracket + 1);
                            if (portPart.startsWith(":")) {
                                try {
                                    port = Integer.parseInt(portPart.substring(1));
                                } catch (NumberFormatException ignored) {
                                }
                            }
                        }
                    } else {
                        int colonIndex = serverIP.lastIndexOf(':');
                        if (colonIndex != -1) {
                            try {
                                port = Integer.parseInt(serverIP.substring(colonIndex + 1));
                                host = serverIP.substring(0, colonIndex);
                            } catch (NumberFormatException ignored) {
                            }
                        }
                    }
                    return "server_" + sanitizeFileName(host + "_" + port);
                }
            }
        }
        return "unknown";
    }

    public static int getDimensionFromFileName(String fileName) {
        if (fileName == null) {
            LogUtil.error("log.error.data.getDim.nullFilename");
            return Integer.MIN_VALUE;
        }
        int dimIndex = fileName.lastIndexOf("_dim_");
        if (dimIndex != -1) {
            String dimStrWithExtension = fileName.substring(dimIndex + 5);
            String dimStr = dimStrWithExtension;
            if (dimStrWithExtension.toLowerCase().endsWith(".json")) {
                dimStr = dimStrWithExtension.substring(0, dimStrWithExtension.length() - 5);
            }
            try {
                return Integer.parseInt(dimStr);
            } catch (NumberFormatException e) {
                LogUtil.error("log.error.data.getDim.parseFailed", fileName, dimStr);
            }
        }
        LogUtil.warn("log.warn.data.getDim.notFound", fileName);
        return Integer.MIN_VALUE;
    }

    public static String getWorldIdentifier(World world) {
        return getWorldBaseIdentifier(world) + "_dim_" + world.provider.getDimensionId();
    }

    private static String sanitizeFileName(String name) {
        return name.replaceAll("[^a-zA-Z0-9_-]", "_");
    }

    public static void removeEntriesFromFile(World world, String fileName, List<BlockPos> positionsToRemove) {
        File file = getDataFile(world, fileName);
        if (!file.exists()) {
            return;
        }

        List<GhostBlockEntry> existingEntries = loadData(world, Collections.singletonList(fileName));

        Set<String> removalKeys = positionsToRemove.stream()
                .map(pos -> pos.getX() + "," + pos.getY() + "," + pos.getZ())
                .collect(Collectors.toSet());

        List<GhostBlockEntry> newEntries = existingEntries.stream()
                .filter(entry -> !removalKeys.contains(entry.x + "," + entry.y + "," + entry.z))
                .collect(Collectors.toList());

        if (newEntries.isEmpty()) {
            file.delete();
        } else {
            try (Writer writer = new FileWriter(file)) {
                GSON.toJson(newEntries, writer);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

features/gameplay/FastPistonBreakingHandler.java:
package com.zihaomc.ghost.features.gameplay;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.item.ItemStack;
import net.minecraft.item.ItemTool;
import net.minecraft.potion.Potion;
import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class FastPistonBreakingHandler {

    private static final boolean DEBUG_HANDLER_SPEED = true;
    
    // 我们认定的、正确的活塞硬度
    private static final float CORRECT_PISTON_HARDNESS = 1.5f;
    // 游戏API返回的、不正确的活塞硬度
    private static final float INCORRECT_PISTON_HARDNESS = 0.5f;

    @SubscribeEvent
    public void onPlayerBreakSpeed(PlayerEvent.BreakSpeed event) {
        if (!GhostConfig.GameplayTweaks.fastPistonBreaking || event.entityPlayer == null) {
            return;
        }

        Block targetBlock = event.state.getBlock();
        if (targetBlock != Blocks.piston && targetBlock != Blocks.sticky_piston) {
            return;
        }

        ItemStack heldItem = event.entityPlayer.getHeldItem();
        if (heldItem == null || !(heldItem.getItem() instanceof ItemPickaxe)) {
            return;
        }
        
        EntityPlayer player = event.entityPlayer;

        if (DEBUG_HANDLER_SPEED) {
            LogUtil.debug("log.debug.fastpiston.recalculating");
            LogUtil.debug("log.debug.fastpiston.originalSpeed", event.newSpeed);
        }

        // 步骤 1: 计算理论上的总挖掘速度 (s*m)
        float s = ((ItemTool) heldItem.getItem()).getToolMaterial().getEfficiencyOnProperMaterial();
        int l = EnchantmentHelper.getEnchantmentLevel(Enchantment.efficiency.effectId, heldItem);
        if (l > 0) {
            s += (float) (l * l + 1);
        }
        
        float m = 1.0f;
        if (player.isPotionActive(Potion.digSpeed)) {
            int amplifier = player.getActivePotionEffect(Potion.digSpeed).getAmplifier();
            m *= 1.0F + (amplifier + 1) * 0.2F;
        }
        if (player.isPotionActive(Potion.digSlowdown)) {
            // ... (省略疲劳、水下等计算，因为在常规场景下 m=1 或仅受急迫影响)
        }
        
        float sm = s * m;
        if (DEBUG_HANDLER_SPEED) LogUtil.debug("log.debug.fastpiston.calculatedSM", sm);

        // 步骤 2: 校正速度值以适应游戏错误的硬度
        // 我们需要设置的 newSpeed，应该满足: newSpeed / (错误的硬度) = (我们计算的速度) / (正确的硬度)
        // newSpeed = (我们计算的速度) * (错误的硬度 / 正确的硬度)
        float correctionFactor = INCORRECT_PISTON_HARDNESS / CORRECT_PISTON_HARDNESS; // 0.5 / 1.5 = 1/3
        float correctedSpeed = sm * correctionFactor;
        
        if (DEBUG_HANDLER_SPEED) {
            LogUtil.debug("log.debug.fastpiston.correctionFactor", correctionFactor);
            LogUtil.debug("log.debug.fastpiston.finalSpeed", correctedSpeed);
        }

        // 步骤 3: 直接用我们校正后的速度覆盖事件的速度
        event.newSpeed = correctedSpeed;
    }
}

features/chat/ChatInputHandler.java:
package com.zihaomc.ghost.features.chat;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiChat;
import net.minecraft.client.gui.GuiTextField;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.client.event.GuiScreenEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.ReflectionHelper;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

public class ChatInputHandler {

    private static Field chatInputField = null;
    private static Field defaultInputFieldTextField = null;
    
    private static int chatHistoryIndex = -1;
    private static String originalChatText = null;
    private static GuiChat activeGuiChatInstance = null;

    public ChatInputHandler() {
        initializeReflectionFields();
    }

    private void initializeReflectionFields() {
        try {
            chatInputField = ReflectionHelper.findField(GuiChat.class, "field_146415_a", "inputField");
            chatInputField.setAccessible(true);
            
            defaultInputFieldTextField = ReflectionHelper.findField(GuiChat.class, "field_146409_v", "defaultInputFieldText");
            defaultInputFieldTextField.setAccessible(true);
        } catch (Exception e) {
            LogUtil.error("log.error.reflection.inputField");
        }
    }

    /**
     * 修复窗口调整大小时聊天内容丢失的问题。
     */
    @SubscribeEvent
    public void onGuiOpen(GuiOpenEvent event) {
        if (!GhostConfig.GuiTweaks.fixGuiStateLossOnResize) return;
        
        if (event.gui != null && event.gui.getClass() == GuiChat.class) {
            String startingText = "";
            try {
                if (defaultInputFieldTextField != null) {
                    startingText = (String) defaultInputFieldTextField.get(event.gui);
                }
                if ((startingText == null || startingText.isEmpty()) && chatInputField != null) {
                    GuiTextField textField = (GuiTextField) chatInputField.get(event.gui);
                    if (textField != null) startingText = textField.getText();
                }
            } catch (Exception ignored) {}

            if (startingText == null) startingText = "";
            event.gui = new GuiChatWrapper(startingText);
        }
    }

    /**
     * 键盘输入：Twitch拦截 & 历史记录滚动。
     */
    @SubscribeEvent
    public void onGuiKeyboardInput(GuiScreenEvent.KeyboardInputEvent.Pre event) {
        if (!(event.gui instanceof GuiChat)) return;

        // 1. Twitch 拦截
        if (GhostConfig.ChatFeatures.disableTwitchAtKey && Keyboard.getEventCharacter() == '@') {
            event.setCanceled(true);
            try {
                if (chatInputField != null) {
                    GuiTextField inputField = (GuiTextField) chatInputField.get(event.gui);
                    if (inputField != null) inputField.writeText("@");
                }
            } catch (Exception e) {
                LogUtil.printStackTrace("log.error.gui.twitchkey.failed", e);
            }
            return;
        }

        // 2. 历史记录滚动 (Shift + 上下)
        if (!GhostConfig.ChatFeatures.enableCommandHistoryScroll) return;
        
        GuiChat currentChatGui = (GuiChat) event.gui;
        updateActiveInstance(currentChatGui);

        if (Keyboard.getEventKeyState() && net.minecraft.client.gui.GuiScreen.isShiftKeyDown()) {
            int keyCode = Keyboard.getEventKey();
            if (keyCode == Keyboard.KEY_UP || keyCode == Keyboard.KEY_DOWN) {
                handleHistoryScroll(currentChatGui, (keyCode == Keyboard.KEY_UP) ? -1 : 1);
                event.setCanceled(true);
            }
        }
    }

    /**
     * 鼠标输入：历史记录滚动 (Shift + 滚轮)。
     */
    @SubscribeEvent
    public void onGuiMouseInput(GuiScreenEvent.MouseInputEvent.Pre event) {
        if (!GhostConfig.ChatFeatures.enableCommandHistoryScroll || !(event.gui instanceof GuiChat)) return;
        
        int wheelDelta = Mouse.getEventDWheel();
        if (wheelDelta != 0 && net.minecraft.client.gui.GuiScreen.isShiftKeyDown()) {
            updateActiveInstance((GuiChat) event.gui);
            handleHistoryScroll((GuiChat) event.gui, (wheelDelta > 0) ? -1 : 1);
            event.setCanceled(true);
        }
    }

    private void updateActiveInstance(GuiChat currentChatGui) {
        if (activeGuiChatInstance == null || activeGuiChatInstance != currentChatGui) {
            activeGuiChatInstance = currentChatGui;
            chatHistoryIndex = -1;
            originalChatText = null;
        }
    }

    private void handleHistoryScroll(GuiChat gui, int delta) {
        try {
            if (chatInputField == null) return;
            GuiTextField inputField = (GuiTextField) chatInputField.get(gui);
            if (inputField == null) return;
            
            List<String> sentMessages = Minecraft.getMinecraft().ingameGUI.getChatGUI().getSentMessages();
            if (sentMessages == null || sentMessages.isEmpty()) return;
            
            if (chatHistoryIndex == -1) originalChatText = inputField.getText();

            chatHistoryIndex += delta;
            
            if (chatHistoryIndex < -1) chatHistoryIndex = sentMessages.size() - 1;
            else if (chatHistoryIndex >= sentMessages.size()) chatHistoryIndex = -1;
            
            String newText = (chatHistoryIndex >= 0) ? sentMessages.get(chatHistoryIndex) : (originalChatText != null ? originalChatText : "");
            inputField.setText(newText);
            inputField.setCursorPositionEnd();
        } catch (Exception e) {
            LogUtil.printStackTrace("log.error.gui.mouse.failed", e);
        }
    }
}

features/chat/CommandSuggestionHandler.java:
package com.zihaomc.ghost.features.chat;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.ChatLine;
import net.minecraft.client.gui.GuiNewChat;
import net.minecraft.event.ClickEvent;
import net.minecraft.event.HoverEvent;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatComponentTranslation;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;
import net.minecraftforge.client.event.ClientChatReceivedEvent;
import net.minecraftforge.event.CommandEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.relauncher.ReflectionHelper;

import java.lang.reflect.Field;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class CommandSuggestionHandler {

    private static String lastCommand = null;
    private static final Set<Integer> processedMessageHashes = new HashSet<>();
    
    private static Field drawnChatLinesField = null;
    private static Field chatComponentField = null;

    public CommandSuggestionHandler() {
        initializeReflectionFields();
    }

    private void initializeReflectionFields() {
        if (drawnChatLinesField == null) { 
            try { 
                drawnChatLinesField = ReflectionHelper.findField(GuiNewChat.class, "field_146253_i", "drawnChatLines"); 
                drawnChatLinesField.setAccessible(true); 
            } catch (Exception e) { 
                LogUtil.error("log.error.reflection.drawnChatLines"); 
            } 
        }
        if (chatComponentField == null) { 
            try { 
                chatComponentField = ReflectionHelper.findField(ChatLine.class, "field_74541_b", "chatComponent", "lineString"); 
                chatComponentField.setAccessible(true); 
            } catch (Exception e) { 
                LogUtil.error("log.error.reflection.chatComponent"); 
            } 
        }
    }

    @SubscribeEvent
    public void onCommand(CommandEvent event) {
        if (!GhostConfig.ChatFeatures.enableChatSuggestions) return;
        try {
            StringBuilder commandBuilder = new StringBuilder("/").append(event.command.getCommandName());
            if (event.parameters != null) {
                for (String param : event.parameters) commandBuilder.append(" ").append(param);
            }
            lastCommand = commandBuilder.toString();
        } catch (Exception e) {
            lastCommand = null;
        }
    }

    @SubscribeEvent
    public void onClientChatReceived(ClientChatReceivedEvent event) {
        if (event.type == 2 || !GhostConfig.ChatFeatures.enableChatSuggestions) return;
        
        int messageHash = System.identityHashCode(event.message);
        if (processedMessageHashes.contains(messageHash)) return;

        if (event.message instanceof ChatComponentTranslation) {
            ChatComponentTranslation translation = (ChatComponentTranslation) event.message;
            String key = translation.getKey();
            if ("commands.generic.unknownCommand".equals(key) || "commands.generic.notFound".equals(key)) {
                Minecraft mc = Minecraft.getMinecraft();
                List<String> sentMessages = mc.ingameGUI.getChatGUI().getSentMessages();
                if (sentMessages != null && !sentMessages.isEmpty()) {
                    String lastSentMsg = sentMessages.get(sentMessages.size() - 1);
                    if (lastSentMsg != null && lastSentMsg.startsWith("/")) {
                        appendSuggestButton(event.message, lastSentMsg);
                        processedMessageHashes.add(messageHash);
                    }
                }
            }
        }
    }

    @SubscribeEvent
    public void onClientTick(TickEvent.ClientTickEvent event) {
        if (event.phase != TickEvent.Phase.END) return;
        Minecraft mc = Minecraft.getMinecraft();

        if (!GhostConfig.ChatFeatures.enableChatSuggestions || lastCommand == null) return;
        if (mc.ingameGUI == null || mc.ingameGUI.getChatGUI() == null || drawnChatLinesField == null || chatComponentField == null) return;
        
        processTickFallback(mc, lastCommand);
    }

    private void processTickFallback(Minecraft mc, String commandToProcess) {
        GuiNewChat chatGUI = mc.ingameGUI.getChatGUI();
        try {
            @SuppressWarnings("unchecked")
            final List<ChatLine> drawnChatLines = (List<ChatLine>) drawnChatLinesField.get(chatGUI);
            if (drawnChatLines == null || drawnChatLines.isEmpty()) return;
            
            boolean commandProcessedThisTick = false;
            for (int i = drawnChatLines.size() - 1; i >= 0; i--) {
                ChatLine currentChatLine = drawnChatLines.get(i);
                IChatComponent currentComponent = (IChatComponent) chatComponentField.get(currentChatLine);
                int currentComponentHash = System.identityHashCode(currentComponent);
                
                if (processedMessageHashes.contains(currentComponentHash)) continue;
                
                if (currentComponent instanceof ChatComponentTranslation) {
                    String key = ((ChatComponentTranslation) currentComponent).getKey();
                    if ("commands.generic.unknownCommand".equals(key) || "commands.generic.notFound".equals(key)) continue;
                }
                
                ChatLine targetBottomLine = currentChatLine;
                int bottomIndex = i;
                
                for (int j = i - 1; j >= 0; j--) {
                    ChatLine previousLine = drawnChatLines.get(j);
                    IChatComponent previousComponent = (IChatComponent) chatComponentField.get(previousLine);
                    int previousHash = System.identityHashCode(previousComponent);
                    boolean prevIsError = false;
                    if (previousComponent instanceof ChatComponentTranslation) {
                        String prevKey = ((ChatComponentTranslation) previousComponent).getKey();
                        prevIsError = "commands.generic.unknownCommand".equals(prevKey) || "commands.generic.notFound".equals(prevKey);
                    }
                    if (processedMessageHashes.contains(previousHash) || prevIsError) break;
                    else {
                        targetBottomLine = previousLine;
                        bottomIndex = j;
                    }
                }
                
                IChatComponent bottomComponent = (IChatComponent) chatComponentField.get(targetBottomLine);
                boolean alreadyHasButton = bottomComponent.getSiblings().stream().anyMatch(s -> s instanceof ChatComponentText && ((ChatComponentText) s).getUnformattedText().contains(LangUtil.translate("ghostblock.commands.suggest.text", "\u21A9")));
                
                if (!alreadyHasButton) {
                    if (appendSuggestButton(bottomComponent, commandToProcess)) {
                        Set<Integer> hashesToMark = new HashSet<>();
                        for (int k = i; k >= bottomIndex; k--) hashesToMark.add(System.identityHashCode(chatComponentField.get(drawnChatLines.get(k))));
                        processedMessageHashes.addAll(hashesToMark);
                        commandProcessedThisTick = true;
                        break;
                    }
                } else {
                    Set<Integer> hashesToMark = new HashSet<>();
                    for (int k = i; k >= bottomIndex; k--) hashesToMark.add(System.identityHashCode(chatComponentField.get(drawnChatLines.get(k))));
                    processedMessageHashes.addAll(hashesToMark);
                }
            }
            if (commandProcessedThisTick) lastCommand = null;
        } catch (Exception e) {
            LogUtil.printStackTrace("log.error.tick.fallback.failed", e);
            lastCommand = null;
        }
    }

    private boolean appendSuggestButton(IChatComponent targetComponent, String commandToSuggest) {
        if (targetComponent == null || commandToSuggest == null) return false;
        try {
            String suggestText = LangUtil.translate("ghostblock.commands.suggest.text", " \u21A9");
            ChatComponentText suggestComponent = new ChatComponentText(suggestText);
            ClickEvent clickEvent = new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, commandToSuggest);
            IChatComponent hoverComponent = new ChatComponentText(LangUtil.translate("ghostblock.commands.suggest.hovertext", commandToSuggest))
                    .setChatStyle(new ChatStyle().setColor(EnumChatFormatting.GRAY));
            HoverEvent hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverComponent);
            ChatStyle buttonStyle = new ChatStyle()
                    .setColor(EnumChatFormatting.AQUA)
                    .setBold(true)
                    .setChatClickEvent(clickEvent)
                    .setChatHoverEvent(hoverEvent);
            suggestComponent.setChatStyle(buttonStyle);
            targetComponent.appendSibling(suggestComponent);
            return true;
        } catch (Exception e) {
            LogUtil.printStackTrace("log.error.chat.attachSuggestButton.failed", e);
            return false;
        }
    }
}

features/chat/GuiChatWrapper.java:
package com.zihaomc.ghost.features.chat;

import net.minecraft.client.gui.GuiChat;
import net.minecraft.client.gui.GuiTextField;

import java.io.IOException;

/**
 * 一个继承自原生GuiChat的包装类。
 * 通过重写initGui方法，从根本上解决因窗口调整导致的文本丢失问题。
 */
public class GuiChatWrapper extends GuiChat {

    // 用于在initGui重建期间临时保存文本的变量
    private String textToRestore = "";
    private int cursorPositionToRestore = 0;

    /**
     * 构造函数，用于从已有的文本初始化
     * @param startingText 聊天框打开时预设的文本
     */
    public GuiChatWrapper(String startingText) {
        super(startingText);
        this.textToRestore = startingText;
        this.cursorPositionToRestore = startingText.length();
    }

    /**
     * 这是解决问题的核心。
     * 每当窗口大小调整，这个方法都会被调用。
     */
    @Override
    public void initGui() {
        // 1. 在原生逻辑运行之前，从旧的inputField（如果存在）中保存文本和光标位置
        if (this.inputField != null) {
            this.textToRestore = this.inputField.getText();
            this.cursorPositionToRestore = this.inputField.getCursorPosition();
        }

        // 2. 调用父类（原生GuiChat）的initGui方法。
        //    这一步会创建一个全新的、空的inputField，替换掉旧的。
        super.initGui();

        // 3. 在原生逻辑运行之后，将我们保存的文本和光标位置恢复到这个 *新* 的inputField上。
        if (this.inputField != null) {
            this.inputField.setText(this.textToRestore);
            // 确保光标位置在文本长度范围内
            int newCursorPos = Math.min(this.textToRestore.length(), this.cursorPositionToRestore);
            this.inputField.setCursorPosition(newCursorPos);
        }
    }

    /**
     * 我们还需要重写onGuiClosed，以确保在关闭时，
     * textToRestore被清空，避免在下次正常打开时（非重建）恢复旧文本。
     */
    @Override
    public void onGuiClosed() {
        super.onGuiClosed();
        this.textToRestore = "";
        this.cursorPositionToRestore = 0;
    }
}

features/translation/SignTranslationHandler.java:
package com.zihaomc.ghost.features.translation;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.LangUtil;
import net.minecraft.block.BlockSign;
import net.minecraft.client.Minecraft;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.tileentity.TileEntitySign;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;
import net.minecraftforge.event.entity.player.PlayerInteractEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.Arrays;
import java.util.stream.Collectors;

public class SignTranslationHandler {

    @SubscribeEvent
    public void onPlayerInteract(PlayerInteractEvent event) {
        if (event.action != PlayerInteractEvent.Action.RIGHT_CLICK_BLOCK || !event.world.isRemote || (!GhostConfig.Translation.enableSignTranslation && !GhostConfig.Translation.enableAutomaticTranslation)) {
            return;
        }

        if (event.world.getBlockState(event.pos).getBlock() instanceof BlockSign) {
            
            TileEntity tileEntity = event.world.getTileEntity(event.pos);
            if (tileEntity instanceof TileEntitySign) {
                TileEntitySign sign = (TileEntitySign) tileEntity;

                String combinedText = Arrays.stream(sign.signText)
                        .map(IChatComponent::getUnformattedText)
                        .collect(Collectors.joining(" "))
                        .trim();

                if (!combinedText.isEmpty()) {
                    Minecraft.getMinecraft().thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GRAY + LangUtil.translate("ghost.sign.translating")));

                    new Thread(() -> {
                        final String result = TranslationUtil.translate(combinedText);
                        Minecraft.getMinecraft().addScheduledTask(() -> {
                            // 安全检查：确保玩家仍在游戏中，以防止在切换世界时崩溃
                            if (Minecraft.getMinecraft().thePlayer == null) {
                                return;
                            }
                        
                            ChatComponentText resultMessage = new ChatComponentText("");
                            
                            if (result.startsWith(TranslationUtil.ERROR_PREFIX)) {
                                // 错误消息
                                String errorContent = result.substring(TranslationUtil.ERROR_PREFIX.length());
                                ChatComponentText errorPrefix = new ChatComponentText(LangUtil.translate("ghost.generic.prefix.default"));
                                errorPrefix.getChatStyle().setColor(EnumChatFormatting.RED);
                                ChatComponentText errorText = new ChatComponentText(errorContent);
                                errorText.getChatStyle().setColor(EnumChatFormatting.RED);
                                resultMessage.appendSibling(errorPrefix).appendSibling(errorText);
                            } else {
                                // 成功消息
                                ChatComponentText prefix = new ChatComponentText(LangUtil.translate("ghost.sign.prefix.translation") + " ");
                                prefix.getChatStyle().setColor(EnumChatFormatting.AQUA);
                                ChatComponentText content = new ChatComponentText(result);
                                resultMessage.appendSibling(prefix).appendSibling(content);
                            }
                            
                            Minecraft.getMinecraft().thePlayer.addChatMessage(resultMessage);
                        });
                    }).start();

                    event.setCanceled(true);
                }
            }
        }
    }
}

features/translation/TranslationCacheManager.java:
package com.zihaomc.ghost.features.translation;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.zihaomc.ghost.utils.LogUtil;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 管理物品翻译的持久化缓存。
 * 负责将翻译结果和隐藏状态从文件加载到内存，以及在游戏关闭时将其保存回文件。
 */
public class TranslationCacheManager {

    private static final String CONFIG_DIR = "config/Ghost/";
    private static final String CACHE_FILE_NAME = "translation_cache.json";
    private static final String HIDDEN_ITEMS_FILE_NAME = "hidden_translations.json";
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static File getCacheFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) {
            configDir.mkdirs();
        }
        return new File(configDir, CACHE_FILE_NAME);
    }

    private static File getHiddenItemsFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) {
            configDir.mkdirs();
        }
        return new File(configDir, HIDDEN_ITEMS_FILE_NAME);
    }

    public static Map<String, List<String>> loadCache() {
        File cacheFile = getCacheFile();
        if (!cacheFile.exists()) {
            LogUtil.info("log.info.cache.file.notFound");
            return new ConcurrentHashMap<>();
        }

        try (Reader reader = new FileReader(cacheFile)) {
            Type type = new TypeToken<ConcurrentHashMap<String, List<String>>>(){}.getType();
            Map<String, List<String>> loadedMap = GSON.fromJson(reader, type);

            if (loadedMap != null) {
                return new ConcurrentHashMap<>(loadedMap);
            }
        } catch (IOException | com.google.gson.JsonSyntaxException e) {
            LogUtil.error("log.error.cache.loadFailed", e.getMessage());
        }

        return new ConcurrentHashMap<>();
    }

    public static Set<String> loadHiddenItems() {
        File hiddenFile = getHiddenItemsFile();
        if (!hiddenFile.exists()) {
            LogUtil.info("log.info.hidden.file.notFound");
            return Collections.newSetFromMap(new ConcurrentHashMap<>());
        }

        try (Reader reader = new FileReader(hiddenFile)) {
            Type type = new TypeToken<Set<String>>(){}.getType();
            Set<String> loadedSet = GSON.fromJson(reader, type);
            if (loadedSet != null) {
                // 创建一个由 ConcurrentHashMap 支持的新 Set，然后将加载的数据添加进去。
                Set<String> concurrentSet = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
                concurrentSet.addAll(loadedSet);
                return concurrentSet;
            }
        } catch (IOException | com.google.gson.JsonSyntaxException e) {
            LogUtil.error("log.error.hidden.loadFailed", e.getMessage());
        }
        return Collections.newSetFromMap(new ConcurrentHashMap<>());
    }


    public static void saveCache(Map<String, List<String>> cache) {
        if (cache == null || cache.isEmpty()) {
            File cacheFile = getCacheFile();
            // 如果缓存为空但文件存在，则删除文件以保持同步
            if(cacheFile.exists()) {
                cacheFile.delete();
            }
            LogUtil.info("log.info.cache.save.skipped");
            return;
        }

        File cacheFile = getCacheFile();
        try (Writer writer = new FileWriter(cacheFile)) {
            GSON.toJson(cache, writer);
        } catch (IOException e) {
            LogUtil.error("log.error.cache.saveFailed", e.getMessage());
        }
    }

    public static void saveHiddenItems(Set<String> hiddenItems) {
        if (hiddenItems == null) {
            return;
        }
        
        File hiddenFile = getHiddenItemsFile();
        // 如果列表为空但文件存在，删除它
        if(hiddenItems.isEmpty()) {
            if(hiddenFile.exists()){
                hiddenFile.delete();
            }
            return;
        }

        try (Writer writer = new FileWriter(hiddenFile)) {
            GSON.toJson(hiddenItems, writer);
            LogUtil.info("log.info.hidden.saved", hiddenItems.size());
        } catch (IOException e) {
            LogUtil.error("log.error.hidden.saveFailed", e.getMessage());
        }
    }
}

features/translation/TranslationUtil.java:
package com.zihaomc.ghost.features.translation;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.utils.LogUtil;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.CookieHandler;
import java.net.CookieManager;
import java.net.CookiePolicy;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * 统一翻译工具类 (极速优化版)。
 * 特性：
 * 1. 多源支持 (Google GTX, Bing Web, MyMemory, NiuTrans)
 * 2. 智能域名切换 (Bing cn/www)
 * 3. 智能重试机制 (MyMemory)
 * 4. LRU 内存缓存 (防止重复请求)
 * 5. 线程池管理 (防止卡顿)
 * 6. Bing Token 预热 (加速首次翻译)
 */
public class TranslationUtil {

    private static final Gson GSON = new Gson();
    public static final String ERROR_PREFIX = "GHOST_TRANSLATION_ERROR:";

    // --- 线程池优化 ---
    // 使用缓存线程池，复用线程，减少 new Thread() 的开销，显著提升高频翻译时的性能
    private static final ExecutorService THREAD_POOL = Executors.newCachedThreadPool();

    // --- 内存缓存 (LRU) ---
    private static final int CACHE_SIZE = 500;
    private static final Map<String, String> MEMORY_CACHE = Collections.synchronizedMap(
        new LinkedHashMap<String, String>(CACHE_SIZE + 1, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > CACHE_SIZE;
            }
        }
    );

    // --- 必应翻译专用 ---
    private static String bingBaseHost = "www.bing.com";
    private static String bingIG = null;
    private static String bingIID = null;
    private static String bingKey = null;
    private static String bingToken = null;
    private static long bingTokenTime = 0;
    
    private static final String USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";
    private static final Pattern BING_IG_PATTERN = Pattern.compile("IG:\"([A-F0-9]+)\"");
    private static final Pattern BING_PARAMS_PATTERN = Pattern.compile("params_AbusePreventionHelper\\s*=\\s*\\[([0-9]+),\\s*\"([^\"]+)\",\\s*[^]]+\\]");

    static {
        CookieManager cookieManager = new CookieManager();
        cookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ALL);
        CookieHandler.setDefault(cookieManager);
        
        // --- 预热优化 ---
        // 在类加载时（游戏启动或首次调用时）就在后台悄悄获取 Bing Token
        // 这样玩家第一次点击翻译时就不需要等待 Token 获取，直接秒翻
        runAsynchronously(() -> {
            try {
                // 优先尝试 cn，因为国内用户更多
                String tempHost = "cn.bing.com"; 
                fetchTokensFromHost(tempHost);
                // 如果获取成功，直接把当前 Host 设为 cn，避免之后的自动切换尝试
                bingBaseHost = tempHost; 
                // LogUtil.info("Bing token pre-fetched successfully from " + tempHost);
            } catch (Exception e) {
                // cn 失败则尝试 www，静默失败也无所谓，反正真正翻译时会重试
                try {
                    fetchTokensFromHost("www.bing.com");
                    bingBaseHost = "www.bing.com";
                } catch (Exception ignored) {}
            }
        });
    }

    /**
     * 统一的异步执行入口，替代 new Thread().start()
     * 使用线程池管理，效率更高
     */
    public static void runAsynchronously(Runnable task) {
        THREAD_POOL.submit(task);
    }

    public static String translate(String sourceText) {
        return translate(sourceText, null);
    }

    public static String translate(String sourceText, String providerOverride) {
        if (sourceText == null || sourceText.trim().isEmpty()) return sourceText;

        String provider = (providerOverride != null) ? providerOverride.toUpperCase() : GhostConfig.Translation.translationProvider.toUpperCase();
        
        String cacheKey = provider + "|" + GhostConfig.Translation.translationSourceLang + "|" + GhostConfig.Translation.translationTargetLang + "|" + sourceText;
        
        if (MEMORY_CACHE.containsKey(cacheKey)) {
            return MEMORY_CACHE.get(cacheKey);
        }

        String result;
        try {
            switch (provider) {
                case "GOOGLE":
                    result = translateGoogleGTX(sourceText);
                    break;
                case "BING":
                    result = translateBingWeb(sourceText);
                    break;
                case "MYMEMORY":
                    result = translateMyMemory(sourceText);
                    break;
                case "NIUTRANS":
                default:
                    result = translateNiuTrans(sourceText);
                    break;
            }
        } catch (Exception e) {
            LogUtil.printStackTrace("log.error.translation.exception", e, e.getMessage());
            return sourceText; 
        }

        if (result != null) {
            if (result.startsWith(ERROR_PREFIX) || result.contains("Please select two distinct languages")) {
                return sourceText;
            }
            MEMORY_CACHE.put(cacheKey, result);
        }
        
        return result;
    }

    // --- Google GTX (优化版: 使用 clients5 节点) ---
    private static String translateGoogleGTX(String sourceText) throws Exception {
        String[] langs = mapLanguageCodes("GOOGLE");
        String encodedText = URLEncoder.encode(sourceText, "UTF-8");
        
        // 优化：使用 clients5.google.com，通常比 translate.googleapis.com 响应更快且限制更少
        // client=dict-chrome-ex 是浏览器扩展使用的标识
        String urlStr = "https://clients5.google.com/translate_a/t?client=dict-chrome-ex&sl=" + langs[0] + "&tl=" + langs[1] + "&q=" + encodedText;
        
        HttpURLConnection conn = createConnection(urlStr, "GET");
        conn.setRequestProperty("User-Agent", USER_AGENT);

        if (conn.getResponseCode() == 200) {
            String response = readResponse(conn);
            // clients5 返回的格式通常比较简单，有时是嵌套数组
            JsonElement root = GSON.fromJson(response, JsonElement.class);
            
            if (root.isJsonArray()) {
                JsonArray rootArray = root.getAsJsonArray();
                if (rootArray.size() > 0) {
                    JsonElement firstItem = rootArray.get(0);
                    // 格式 1: [["翻译结果", "原文", ...]]
                    if (firstItem.isJsonArray()) {
                         return firstItem.getAsJsonArray().get(0).getAsString();
                    } 
                    // 格式 2: ["翻译结果"]
                    else if (firstItem.isJsonPrimitive()) {
                         return firstItem.getAsString();
                    }
                }
            }
        }
        return ERROR_PREFIX + LangUtil.translate("ghost.error.translation.api_response", "Google", conn.getResponseCode());
    }

    // --- MyMemory ---
    private static String translateMyMemory(String sourceText) throws Exception {
        String[] langs = mapLanguageCodes("MYMEMORY");
        String fromLang = langs[0];
        String toLang = langs[1];

        boolean containsChinese = sourceText.codePoints().anyMatch(codepoint ->
                Character.UnicodeScript.of(codepoint) == Character.UnicodeScript.HAN);

        if ("Autodetect".equals(fromLang) && "zh-CN".equals(toLang) && containsChinese) {
            fromLang = "en";
        }
        
        String result = performMyMemoryRequest(sourceText, fromLang, toLang);

        if (result != null && result.contains("Please select two distinct languages")) {
             if (!"en".equals(fromLang)) {
                 return performMyMemoryRequest(sourceText, "en", toLang);
             }
             return result;
        }
        return result;
    }

    private static String performMyMemoryRequest(String sourceText, String fromLang, String toLang) throws Exception {
        String encodedText = URLEncoder.encode(sourceText, "UTF-8");
        String urlStr = "https://api.mymemory.translated.net/get?q=" + encodedText + "&langpair=" + fromLang + "|" + toLang;

        HttpURLConnection conn = createConnection(urlStr, "GET");

        if (conn.getResponseCode() == 200) {
            String response = readResponse(conn);
            JsonObject json = GSON.fromJson(response, JsonObject.class);

            if (json.has("responseData")) {
                JsonElement responseData = json.get("responseData");
                if (!responseData.isJsonNull()) {
                    return responseData.getAsJsonObject().get("translatedText").getAsString();
                }
            }
            if (json.has("responseDetails")) {
                return json.get("responseDetails").getAsString();
            }
        }
        return ERROR_PREFIX + LangUtil.translate("ghost.error.translation.api_response", "MyMemory", conn.getResponseCode());
    }

    // --- Bing Web ---
    private static String translateBingWeb(String sourceText) {
        try {
            return performBingTranslationInternal(sourceText);
        } catch (Exception e) {
            toggleBingHost();
            bingIG = null;
            try {
                return performBingTranslationInternal(sourceText);
            } catch (Exception ex) {
                return ERROR_PREFIX + LangUtil.translate("ghost.error.translation.bing.failed_domains");
            }
        }
    }

    private static String performBingTranslationInternal(String sourceText) throws Exception {
        // 这里会检查 Token 是否过期 (10分钟)
        refreshBingTokenIfNeeded();
        
        if (bingIG == null || bingKey == null || bingToken == null) {
            throw new Exception(LangUtil.translate("ghost.error.translation.bing.tokens"));
        }

        String[] langs = mapLanguageCodes("BING");
        
        String urlStr = "https://" + bingBaseHost + "/ttranslatev3?isVertical=1&&IG=" + bingIG + "&IID=" + bingIID;
        HttpURLConnection conn = createConnection(urlStr, "POST");
        conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        conn.setRequestProperty("User-Agent", USER_AGENT);
        
        String postData = "fromLang=" + langs[0] + "&to=" + langs[1] + "&token=" + bingToken + "&key=" + bingKey + "&text=" + URLEncoder.encode(sourceText, "UTF-8");
        
        try (OutputStream os = conn.getOutputStream()) {
            os.write(postData.getBytes(StandardCharsets.UTF_8));
        }

        if (conn.getResponseCode() == 200) {
            String response = readResponse(conn);
            JsonArray jsonArray = GSON.fromJson(response, JsonArray.class);
            if (jsonArray != null && jsonArray.size() > 0) {
                JsonObject firstObj = jsonArray.get(0).getAsJsonObject();
                if (firstObj.has("translations")) {
                    return firstObj.getAsJsonArray("translations").get(0).getAsJsonObject().get("text").getAsString();
                }
            }
            throw new Exception(LangUtil.translate("ghost.error.translation.bing.empty"));
        }
        throw new Exception(LangUtil.translate("ghost.error.translation.api_response", "Bing", conn.getResponseCode()));
    }

    private static void refreshBingTokenIfNeeded() {
        // 检查 Token 是否为 null 或者是否已经超过 10 分钟
        if (bingIG == null || (System.currentTimeMillis() - bingTokenTime > 600000)) {
            try {
                fetchTokensFromHost(bingBaseHost);
            } catch (Exception e) {
                // 仅记录错误，不抛出异常，让调用者（performBingTranslationInternal）处理
                // 如果这里失败，performBingTranslationInternal 会检测到 bingIG 仍为 null 并抛出异常，触发外层的域名切换
                LogUtil.error("ghost.log.bing.token_error", e.getMessage());
            }
        }
    }

    private static void fetchTokensFromHost(String host) throws Exception {
        String urlStr = "https://" + host + "/translator";
        HttpURLConnection conn = createConnection(urlStr, "GET");
        conn.setRequestProperty("User-Agent", USER_AGENT);
        
        if (conn.getResponseCode() == 200) {
            String html = readResponse(conn);
            Matcher igMatcher = BING_IG_PATTERN.matcher(html);
            if (igMatcher.find()) {
                bingIG = igMatcher.group(1);
                bingIID = bingIG + ".1";
            }
            Matcher paramMatcher = BING_PARAMS_PATTERN.matcher(html);
            if (paramMatcher.find()) {
                bingKey = paramMatcher.group(1);
                bingToken = paramMatcher.group(2);
            }
            
            if (bingIG != null && bingKey != null && bingToken != null) {
                bingTokenTime = System.currentTimeMillis();
            } else {
                throw new Exception("Token parse failed on " + host);
            }
        } else {
            throw new Exception("HTTP " + conn.getResponseCode() + " on " + host);
        }
    }

    private static void toggleBingHost() {
        bingBaseHost = "www.bing.com".equals(bingBaseHost) ? "cn.bing.com" : "www.bing.com";
        LogUtil.info("ghost.log.bing.switch_host", bingBaseHost);
    }

    // --- NiuTrans ---
    private static String translateNiuTrans(String sourceText) throws Exception {
        String apiKey = GhostConfig.Translation.niuTransApiKey;
        if (apiKey == null || apiKey.trim().isEmpty()) {
            return ERROR_PREFIX + LangUtil.translate("ghost.error.translation.no_api_key");
        }
        
        Map<String, String> params = new HashMap<>();
        params.put("from", GhostConfig.Translation.translationSourceLang);
        params.put("to", GhostConfig.Translation.translationTargetLang);
        params.put("apikey", apiKey);
        params.put("src_text", URLEncoder.encode(sourceText, "UTF-8"));
        
        String urlParameters = params.entrySet().stream().map(e -> e.getKey() + "=" + e.getValue()).collect(Collectors.joining("&"));
        byte[] postData = urlParameters.getBytes(StandardCharsets.UTF_8);
        HttpURLConnection conn = createConnection("https://api.niutrans.com/NiuTransServer/translation", "POST");
        try (OutputStream os = conn.getOutputStream()) { os.write(postData); }
        
        if (conn.getResponseCode() == 200) {
            String response = readResponse(conn);
            JsonObject json = GSON.fromJson(response, JsonObject.class);
            if (json.has("tgt_text")) return json.get("tgt_text").getAsString();
            if (json.has("error_msg")) return ERROR_PREFIX + json.get("error_msg").getAsString();
        }
        return ERROR_PREFIX + LangUtil.translate("ghost.error.translation.api_response", "NiuTrans", conn.getResponseCode());
    }

    // --- Helpers ---
    
    private static String[] mapLanguageCodes(String provider) {
        String s = GhostConfig.Translation.translationSourceLang;
        String t = GhostConfig.Translation.translationTargetLang;

        if ("BING".equals(provider)) {
            if ("zh".equals(t)) t = "zh-Hans";
            if ("auto".equals(s)) s = "auto-detect";
        } else if ("MYMEMORY".equals(provider)) {
            if ("zh".equals(t)) t = "zh-CN";
            if ("auto".equals(s)) s = "Autodetect";
        }
        return new String[]{s, t};
    }

    private static HttpURLConnection createConnection(String urlStr, String method) throws Exception {
        URL url = new URL(urlStr);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod(method);
        conn.setConnectTimeout(3000); // 3秒连接超时
        conn.setReadTimeout(5000);    // 5秒读取超时
        conn.setRequestProperty("Connection", "keep-alive"); // 开启 Keep-Alive
        if ("POST".equals(method)) {
            conn.setDoOutput(true);
        }
        return conn;
    }

    private static String readResponse(HttpURLConnection conn) throws Exception {
        try (BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = in.readLine()) != null) {
                response.append(line);
            }
            return response.toString();
        }
    }
}

features/translation/CacheSavingHandler.java:
package com.zihaomc.ghost.features.translation;

import com.zihaomc.ghost.utils.LogUtil;
import net.minecraftforge.event.world.WorldEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

/**
 * 一个专门的事件处理器，用于在正确的时机保存持久化缓存。
 */
public class CacheSavingHandler {

    /**
     * 当一个世界被卸载时（例如退出单人游戏或从服务器断开），触发此事件。
     * 这是保存客户端缓存的理想时机。
     * @param event 世界卸载事件
     */
    @SubscribeEvent
    public void onWorldUnload(WorldEvent.Unload event) {
        // 确保我们只在客户端世界卸载时执行操作
        if (event.world.isRemote) {
            LogUtil.info("log.info.cache.saving");
            // 调用 ItemTooltipTranslationHandler 中的静态保存方法
            ItemTooltipTranslationHandler.saveCacheToFile();
        }
    }
}

features/translation/ChatTranslationHandler.java:
package com.zihaomc.ghost.features.translation;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper; 
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.event.ClickEvent;
import net.minecraft.event.HoverEvent;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;
import net.minecraft.util.IChatComponent;
import net.minecraftforge.client.event.ClientChatReceivedEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.HashSet;
import java.util.Set;

public class ChatTranslationHandler {

    private static final Set<Integer> processedMessageHashes = new HashSet<>();

    @SubscribeEvent
    public void onClientChatReceived(ClientChatReceivedEvent event) {
        if (event.type == 2) return;
        
        if (!GhostConfig.Translation.enableAutomaticTranslation && !GhostConfig.Translation.enableChatTranslation) {
            return;
        }

        int messageHash = System.identityHashCode(event.message);
        if (processedMessageHashes.contains(messageHash)) return;

        String unformattedText = event.message.getUnformattedText();
        String translatedPrefix = LangUtil.translate("ghost.generic.prefix.translation");

        if (unformattedText.startsWith(translatedPrefix)) {
            processedMessageHashes.add(messageHash);
            return;
        }

        if ((event.type == 0 || event.type == 1) && !unformattedText.trim().isEmpty()) {
            if (GhostConfig.Translation.enableAutomaticTranslation) {
                triggerAutomaticChatTranslation(unformattedText);
                processedMessageHashes.add(messageHash);
            } else if (GhostConfig.Translation.enableChatTranslation) {
                appendTranslateButton(event.message, unformattedText);
                processedMessageHashes.add(messageHash);
            }
        }
    }

    private void triggerAutomaticChatTranslation(String originalText) {
        String currentProvider = GhostConfig.Translation.translationProvider.toUpperCase();
        
        TranslationUtil.runAsynchronously(() -> {
            final String result = TranslationUtil.translate(originalText, currentProvider);
            
            Minecraft.getMinecraft().addScheduledTask(() -> {
                if (Minecraft.getMinecraft().thePlayer == null) return;
            
                if (!result.startsWith(TranslationUtil.ERROR_PREFIX)) {
                    ChatComponentText resultMessage = new ChatComponentText("");
                    ChatComponentText resultPrefix = new ChatComponentText(LangUtil.translate("ghost.generic.prefix.translation") + " ");
                    resultPrefix.getChatStyle().setColor(EnumChatFormatting.AQUA);
                    
                    ChatComponentText providerTag = new ChatComponentText(EnumChatFormatting.YELLOW + "[" + currentProvider + "] " + EnumChatFormatting.RESET);
                    ChatComponentText resultContent = new ChatComponentText(result);
                    
                    resultMessage.appendSibling(resultPrefix)
                                 .appendSibling(providerTag)
                                 .appendSibling(resultContent);
                    
                    // --- 修改点：使用 GhostBlockHelper ---
                    resultMessage.appendSibling(GhostBlockHelper.createProviderSwitchButtons(originalText, currentProvider));
                    
                    Minecraft.getMinecraft().thePlayer.addChatMessage(resultMessage);
                }
            });
        });
    }

    private void appendTranslateButton(IChatComponent targetComponent, String textToTranslate) {
        try {
            String buttonText = String.format(" %s", LangUtil.translate("ghostblock.chat.button.translate"));
            ChatComponentText buttonComponent = new ChatComponentText(buttonText);
            
            String command = "/gtranslate \"" + textToTranslate.replace("\"", "\\\"") + "\"";
            
            ClickEvent clickEvent = new ClickEvent(ClickEvent.Action.RUN_COMMAND, command);
            String hoverText = LangUtil.translate("ghostblock.chat.button.translate.hover");
            IChatComponent hoverComponent = new ChatComponentText(hoverText).setChatStyle(new ChatStyle().setColor(EnumChatFormatting.GRAY));
            HoverEvent hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, hoverComponent);
            
            ChatStyle buttonStyle = new ChatStyle()
                    .setColor(EnumChatFormatting.GREEN)
                    .setChatClickEvent(clickEvent)
                    .setChatHoverEvent(hoverEvent);
            buttonComponent.setChatStyle(buttonStyle);
            targetComponent.appendSibling(buttonComponent);
        } catch (Exception e) {
            LogUtil.error("log.error.chat.attachButton.failed", e.getMessage());
        }
    }
}

features/translation/TranslateCommand.java:
package com.zihaomc.ghost.features.translation;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.ghostblock.GhostBlockHelper;
import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.client.Minecraft;
import net.minecraft.command.CommandBase;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class TranslateCommand extends CommandBase {

    @Override
    public String getCommandName() {
        return "gtranslate";
    }

    @Override
    public List<String> getCommandAliases() {
        return Collections.singletonList("gt");
    }

    @Override
    public String getCommandUsage(ICommandSender sender) {
        return LangUtil.translate("ghostblock.commands.gtranslate.usage");
    }
    
    @Override
    public int getRequiredPermissionLevel() {
        return 0;
    }

    @Override
    public boolean canCommandSenderUseCommand(ICommandSender sender) {
        return true;
    }

    @Override
    public void processCommand(ICommandSender sender, String[] args) throws WrongUsageException {
        if (args.length == 0) {
            throw new WrongUsageException(getCommandUsage(sender));
        }

        String providerOverride = null;
        String sourceText;
        
        if (args.length >= 3 && (args[0].equalsIgnoreCase("-p") || args[0].equalsIgnoreCase("--provider"))) {
            providerOverride = args[1];
            sourceText = String.join(" ", Arrays.copyOfRange(args, 2, args.length));
        } else {
            sourceText = String.join(" ", args);
        }
        
        final String finalProvider = (providerOverride != null) ? providerOverride.toUpperCase() : GhostConfig.Translation.translationProvider.toUpperCase();
        final String finalSourceText = sourceText;

        ChatComponentText translatingMessage = new ChatComponentText("");
        ChatComponentText prefix = new ChatComponentText(LangUtil.translate("ghost.generic.prefix.default"));
        prefix.setChatStyle(new ChatStyle().setColor(EnumChatFormatting.DARK_GRAY));
        ChatComponentText content = new ChatComponentText(LangUtil.translate("ghostblock.commands.gtranslate.translating", sourceText));
        content.setChatStyle(new ChatStyle().setColor(EnumChatFormatting.GRAY));
        translatingMessage.appendSibling(prefix);
        translatingMessage.appendSibling(content);
        sender.addChatMessage(translatingMessage);

        TranslationUtil.runAsynchronously(() -> {
            final String result = TranslationUtil.translate(finalSourceText, finalProvider);
            
            Minecraft.getMinecraft().addScheduledTask(() -> {
                if (Minecraft.getMinecraft().thePlayer == null) {
                    return;
                }
                
                ChatComponentText resultMessage = new ChatComponentText("");
                
                if (result.startsWith(TranslationUtil.ERROR_PREFIX)) {
                    String errorContent = result.substring(TranslationUtil.ERROR_PREFIX.length());
                    ChatComponentText errorPrefix = new ChatComponentText(LangUtil.translate("ghost.generic.prefix.default"));
                    errorPrefix.getChatStyle().setColor(EnumChatFormatting.RED);
                    ChatComponentText errorText = new ChatComponentText(errorContent);
                    errorText.getChatStyle().setColor(EnumChatFormatting.RED);
                    resultMessage.appendSibling(errorPrefix).appendSibling(errorText);
                } else {
                    ChatComponentText resultPrefix = new ChatComponentText(LangUtil.translate("ghost.generic.prefix.translation") + " ");
                    resultPrefix.getChatStyle().setColor(EnumChatFormatting.AQUA);
                    
                    ChatComponentText providerTag = new ChatComponentText(EnumChatFormatting.YELLOW + "[" + finalProvider + "] " + EnumChatFormatting.RESET);
                    
                    ChatComponentText resultContent = new ChatComponentText(result);
                    
                    resultMessage.appendSibling(resultPrefix)
                                 .appendSibling(providerTag)
                                 .appendSibling(resultContent);
                                 
                    // --- 修改点：使用 GhostBlockHelper ---
                    resultMessage.appendSibling(GhostBlockHelper.createProviderSwitchButtons(finalSourceText, finalProvider));
                }
                
                sender.addChatMessage(resultMessage);
            });
        });
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length == 1) {
            String placeholder = LangUtil.translate("ghostblock.commands.gtranslate.placeholder");
            return getListOfStringsMatchingLastWord(args, "-p", "--provider", placeholder);
        }
        if (args.length == 2 && (args[0].equalsIgnoreCase("-p") || args[0].equalsIgnoreCase("--provider"))) {
            return getListOfStringsMatchingLastWord(args, "GOOGLE", "BING", "MYMEMORY", "NIUTRANS");
        }
        return null;
    }
}

features/translation/ItemTooltipTranslationHandler.java:
package com.zihaomc.ghost.features.translation;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.handlers.KeybindHandler;
import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.utils.ColorFormatting;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.util.EnumChatFormatting;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.event.entity.player.ItemTooltipEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class ItemTooltipTranslationHandler {

    public static Map<String, List<String>> translationCache;
    public static final Set<String> pendingTranslations = Collections.newSetFromMap(new ConcurrentHashMap<>());
    public static Set<String> hiddenTranslations;

    /** 存储当前悬停物品的原始带格式名称 */
    public static String lastHoveredItemOriginalName = null;
    /** 存储当前悬停物品的原始带格式 Lore */
    public static List<String> lastHoveredItemOriginalLore = null;

    /** 存储当前悬停物品去除了格式的纯文本名称 */
    public static String lastHoveredItemName = null;
    /** 存储当前悬停物品去除了格式的纯文本 Lore */
    public static List<String> lastHoveredItemLore = null;

    /** 用于剥离颜色代码的正则表达式 */
    private static final Pattern STRIP_COLOR_PATTERN = Pattern.compile("(?i)§[0-9A-FK-OR]");

    /**
     * 从文件加载翻译缓存和隐藏列表。
     */
    public static void loadCacheFromFile() {
        translationCache = TranslationCacheManager.loadCache();
        hiddenTranslations = TranslationCacheManager.loadHiddenItems();
        LogUtil.info("log.info.cache.loaded", translationCache.size());
        LogUtil.info("log.info.hidden.loaded", hiddenTranslations.size());
    }

    /**
     * 将翻译缓存和隐藏列表保存到文件。
     */
    public static void saveCacheToFile() {
        LogUtil.info("log.info.cache.saving.count", translationCache.size());
        TranslationCacheManager.saveCache(translationCache);
        TranslationCacheManager.saveHiddenItems(hiddenTranslations);
        LogUtil.info("log.info.cache.saved");
    }

    /**
     * 核心事件：处理物品 Tooltip 的显示。
     */
    @SubscribeEvent
    public void onItemTooltip(ItemTooltipEvent event) {
        if ((!GhostConfig.Translation.enableItemTranslation && !GhostConfig.Translation.enableAutomaticTranslation) || event.itemStack == null || event.toolTip.isEmpty()) {
            resetHoveredItem();
            return;
        }

        // 步骤 1: 存储原始的、带格式的文本
        lastHoveredItemOriginalName = event.toolTip.get(0);
        
        // 步骤 2: 存储去除格式后的纯文本，用作缓存的 Key 和翻译请求的内容
        String unformattedItemName = STRIP_COLOR_PATTERN.matcher(lastHoveredItemOriginalName).replaceAll("");
        if (unformattedItemName.trim().isEmpty()) {
            resetHoveredItem();
            return;
        }
        lastHoveredItemName = unformattedItemName;
        
        // 同样处理 Lore 部分
        if (event.toolTip.size() > 1) {
            lastHoveredItemOriginalLore = new ArrayList<>(event.toolTip.subList(1, event.toolTip.size()));
            lastHoveredItemLore = lastHoveredItemOriginalLore.stream()
                .map(line -> STRIP_COLOR_PATTERN.matcher(line).replaceAll(""))
                .collect(Collectors.toList());
        } else {
            lastHoveredItemOriginalLore = new ArrayList<>();
            lastHoveredItemLore = new ArrayList<>();
        }

        String keyName = Keyboard.getKeyName(KeybindHandler.translateItemKey.getKeyCode());

        // 如果物品正在翻译中，显示提示
        if (pendingTranslations.contains(unformattedItemName)) {
            event.toolTip.add(EnumChatFormatting.GRAY + LangUtil.translate("ghost.tooltip.translating"));
            return;
        }
        
        // 如果缓存中没有此物品
        if (!translationCache.containsKey(unformattedItemName)) {
            if (GhostConfig.Translation.enableAutomaticTranslation) {
                // 自动翻译模式下，触发翻译流程
                new KeybindHandler().handleToggleOrTranslatePress();
                event.toolTip.add(EnumChatFormatting.GRAY + LangUtil.translate("ghost.tooltip.translating"));
            } else if (!GhostConfig.Translation.hideTranslationKeybindTooltip) {
                // 手动模式下，显示翻译提示
                event.toolTip.add(EnumChatFormatting.DARK_GRAY + LangUtil.translate("ghost.tooltip.translate", keyName));
            }
            return;
        }

        // 如果缓存中存在此物品，获取翻译结果
        List<String> cachedLines = translationCache.get(unformattedItemName);
        // 检查是否是错误信息
        if (cachedLines != null && !cachedLines.isEmpty() && cachedLines.get(0).startsWith(EnumChatFormatting.RED.toString())) {
            event.toolTip.add("");
            event.toolTip.add(cachedLines.get(0));
            if (!GhostConfig.Translation.hideTranslationKeybindTooltip) {
                event.toolTip.add(EnumChatFormatting.DARK_GRAY + LangUtil.translate("ghost.tooltip.retryAndClear", keyName, keyName, keyName));
            }
            return;
        }

        // 决定是否应该显示翻译
        boolean isHidden = hiddenTranslations.contains(unformattedItemName);
        boolean shouldBeVisible = GhostConfig.Translation.autoShowCachedTranslation ? !isHidden : isHidden;

        if (shouldBeVisible) {
            if (GhostConfig.Translation.showTranslationOnly) {
                // 仅显示翻译模式
                event.toolTip.clear();
                if (cachedLines != null && !cachedLines.isEmpty()) {
                    // 直接添加已经格式化好的翻译文本
                    event.toolTip.addAll(cachedLines);
                }
                event.toolTip.add("");
                if (!GhostConfig.Translation.hideTranslationKeybindTooltip) {
                    event.toolTip.add(EnumChatFormatting.DARK_GRAY + LangUtil.translate("ghost.tooltip.hideAndClear", keyName, keyName, keyName));
                }
            } else {
                // 在原文下方附加翻译
                displayTranslation(event, cachedLines, keyName);
            }
        } else {
            // 如果翻译被隐藏，显示“显示翻译”的提示
            if (!GhostConfig.Translation.hideTranslationKeybindTooltip) {
                event.toolTip.add(EnumChatFormatting.DARK_GRAY + LangUtil.translate("ghost.tooltip.showAndClear", keyName, keyName, keyName));
            }
        }
    }

    /**
     * 在 Tooltip 的末尾附加翻译内容。
     */
    private void displayTranslation(ItemTooltipEvent event, List<String> translatedLines, String keyName) {
        event.toolTip.add("");
        event.toolTip.add(EnumChatFormatting.GOLD + LangUtil.translate("ghost.tooltip.header"));
        if (translatedLines != null) {
            // 直接添加已经格式化好的翻译文本
            event.toolTip.addAll(translatedLines);
        }
        if (!GhostConfig.Translation.hideTranslationKeybindTooltip) {
            event.toolTip.add(EnumChatFormatting.DARK_GRAY + LangUtil.translate("ghost.tooltip.hideAndClear", keyName, keyName, keyName));
        }
    }
    
    /**
     * 当 GUI 关闭时，重置悬停物品信息。
     */
    @SubscribeEvent
    public void onGuiClosed(GuiOpenEvent event) {
        if (event.gui == null) {
            resetHoveredItem();
        }
    }

    /**
     * 清理所有与当前悬停物品相关的信息。
     */
    private void resetHoveredItem() {
        lastHoveredItemName = null;
        lastHoveredItemLore = null;
        lastHoveredItemOriginalName = null;
        lastHoveredItemOriginalLore = null;
    }
}

features/autocraft/AutoCraftRecipe.java:
package com.zihaomc.ghost.features.autocraft;

import net.minecraft.item.Item;

/**
 * 代表一个自动合成配方的定义。
 * 存储了合成一个物品所需的所有信息，如输入名称和数量。
 */
public class AutoCraftRecipe {
    /**
     * 配方的唯一标识符，用于命令中。
     */
    public final String recipeKey;

    /**
     * 输入材料在游戏内显示的无格式名称。
     */
    public final String ingredientDisplayName;

    /**
     * 合成一个成品所需的输入材料数量。
     */
    public final int requiredAmount;

    public AutoCraftRecipe(String recipeKey, String ingredientDisplayName, int requiredAmount) {
        this.recipeKey = recipeKey;
        this.ingredientDisplayName = ingredientDisplayName;
        this.requiredAmount = requiredAmount;
    }
}

features/autocraft/AutoCraftRecipeManager.java:
package com.zihaomc.ghost.features.autocraft;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.utils.LogUtil;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 自动合成配方的中央管理器。
 * 负责从配置文件加载、注册、存储和查询所有可用的合成配方。
 */
public class AutoCraftRecipeManager {

    private static final String CONFIG_DIR = "config/Ghost/";
    private static final String RECIPES_FILE_NAME = "autocraft_recipes.json";
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    private static final Map<String, AutoCraftRecipe> recipes = new ConcurrentHashMap<>();

    private static class RecipeDefinition {
        String recipeKey;
        String ingredientDisplayName;
        int requiredAmount;
    }

    public static void initialize() {
        File recipesFile = getRecipesFile();
        if (!recipesFile.exists()) {
            createDefaultRecipesFile(recipesFile);
        }
        loadRecipesFromFile(recipesFile);
    }

    public static void reloadRecipes() {
        recipes.clear();
        loadRecipesFromFile(getRecipesFile());
    }

    public static void saveRecipes() {
        File file = getRecipesFile();
        List<RecipeDefinition> definitions = recipes.values().stream()
            .map(recipe -> {
                RecipeDefinition def = new RecipeDefinition();
                def.recipeKey = recipe.recipeKey;
                def.ingredientDisplayName = recipe.ingredientDisplayName;
                def.requiredAmount = recipe.requiredAmount;
                return def;
            })
            .collect(Collectors.toList());
        
        try (Writer writer = new FileWriter(file)) {
            addFileHeader(writer);
            for (int i = 0; i < definitions.size(); i++) {
                writer.write(GSON.toJson(definitions.get(i)));
                if (i < definitions.size() - 1) {
                    writer.write(",\n");
                }
            }
            writer.write("\n]");
        } catch (IOException e) {
            LogUtil.error("Failed to save auto-craft recipes file.");
            e.printStackTrace();
        }
    }

    private static void loadRecipesFromFile(File file) {
        try (Reader reader = new FileReader(file)) {
            Type type = new TypeToken<List<RecipeDefinition>>(){}.getType();
            List<RecipeDefinition> definitions = GSON.fromJson(reader, type);

            if (definitions != null) {
                for (RecipeDefinition def : definitions) {
                    registerRecipe(new AutoCraftRecipe(
                        def.recipeKey,
                        def.ingredientDisplayName,
                        def.requiredAmount
                    ));
                }
            }
        } catch (Exception e) {
            LogUtil.error(LangUtil.translate("ghost.autocraft.error.recipe_file_read_error"));
            e.printStackTrace();
        }
    }

    private static void createDefaultRecipesFile(File file) {
        List<RecipeDefinition> defaultRecipes = new ArrayList<>();
        
        RecipeDefinition mithril = new RecipeDefinition();
        mithril.recipeKey = "mithril";
        mithril.ingredientDisplayName = "Mithril";
        mithril.requiredAmount = 320;
        defaultRecipes.add(mithril);

        RecipeDefinition handStone = new RecipeDefinition();
        handStone.recipeKey = "handstone";
        handStone.ingredientDisplayName = "Hand Stone";
        handStone.requiredAmount = 576;
        defaultRecipes.add(handStone);

        try (Writer writer = new FileWriter(file)) {
            addFileHeader(writer);
            for (int i = 0; i < defaultRecipes.size(); i++) {
                writer.write(GSON.toJson(defaultRecipes.get(i)));
                if (i < defaultRecipes.size() - 1) {
                    writer.write(",\n");
                }
            }
            writer.write("\n]");
        } catch (IOException e) {
            LogUtil.error("Failed to create default auto-craft recipes file.");
            e.printStackTrace();
        }
    }

    private static void addFileHeader(Writer writer) throws IOException {
        String fileHeader = "[\n  // 这是自动合成的配方文件。\n" +
                            "  // 你可以在这里添加或修改配方，也可以使用 /autocraft add|remove 命令。\n" +
                            "  // recipeKey: 命令中使用的唯一名称, e.g., /autocraft start <recipeKey>\n" +
                            "  // ingredientDisplayName: 材料的游戏内显示名称 (空格请用下划线代替, e.g., Hand_Stone)\n" +
                            "  // requiredAmount: 合成一个成品需要的材料总数\n" +
                            "  // 修改后，请在游戏中输入 /autocraft reload 来重新加载。\n";
        writer.write(fileHeader);
    }
    
    private static File getRecipesFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) {
            configDir.mkdirs();
        }
        return new File(configDir, RECIPES_FILE_NAME);
    }

    public static void registerRecipe(AutoCraftRecipe recipe) {
        if (recipe != null && recipe.recipeKey != null) {
            recipes.put(recipe.recipeKey.toLowerCase(), recipe);
        }
    }

    public static void removeRecipe(String key) {
        if (key != null) {
            recipes.remove(key.toLowerCase());
        }
    }

    public static AutoCraftRecipe getRecipe(String key) {
        return recipes.get(key.toLowerCase());
    }

    public static Collection<AutoCraftRecipe> getAllRecipes() {
        return Collections.unmodifiableCollection(recipes.values());
    }

    public static Collection<String> getAllRecipeKeys() {
        return Collections.unmodifiableSet(recipes.keySet());
    }
}

features/autocraft/AutoCraftHandler.java:
package com.zihaomc.ghost.features.autocraft;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.inventory.GuiChest;
import net.minecraft.entity.player.InventoryPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.inventory.ContainerChest;
import net.minecraft.inventory.Slot;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.EnumChatFormatting;
import net.minecraftforge.client.event.ClientChatReceivedEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

/**
 * 自动合成功能的核心处理器。
 * 使用状态机来管理从获取材料到合成物品的全过程。
 */
public class AutoCraftHandler {

    private enum State {
        IDLE,
        STARTING,
        CHECK_SUPPLIES,
        GET_SUPPLIES,
        WAITING_FOR_STASH_MESSAGE, // 等待服务器/pickupstash命令的确认消息
        CHECK_SUPPLIES_AFTER_STASH, // 收到消息后进行最终检查
        OPEN_MENU,
        WAIT_FOR_MENU_GUI,
        CLICK_CRAFT_TABLE,
        WAIT_FOR_CRAFT_GUI,
        DO_CRAFT,
        WAIT_FOR_ITEM_PLACEMENT,
        WAIT_FOR_CRAFT_RESULT,
        TAKE_PRODUCT,
        WAIT_FOR_SLOT_CLEAR
    }

    private static final Minecraft mc = Minecraft.getMinecraft();
    private static boolean active = false;
    private static State currentState = State.IDLE;
    private static State lastState = State.IDLE;
    private static int tickCounter = 0;
    private static int timeoutCounter = 0;
    
    /**
     * 追踪当前循环中已经放入合成槽的材料数量。
     */
    private static int ingredientsPlaced = 0;

    private static int slotToWatch = -1;
    private static int stackSizeToWatch = -1;
    
    private static int retryCount = 0;
    private static final int MAX_RETRIES = 3;

    /**
     * 当前正在执行的合成配方。
     */
    private static AutoCraftRecipe activeRecipe = null;

    private static final String CRAFT_GUI_NAME = "Craft Item";
    private static final String SKYBLOCK_MENU_NAME = "SkyBlock Menu";

    private static final int CRAFT_RESULT_SLOT = 23;
    private static final int CRAFT_TABLE_SLOT = 31;
    private static final int WAIT_TIMEOUT_TICKS = 60;
    private static final int PLACEMENT_TIMEOUT_TICKS = 40;
    private static final int STASH_MESSAGE_TIMEOUT_TICKS = 80; // 等待/pickupstash消息的超时时间，4秒
    private static final int INVENTORY_SYNC_TIMEOUT_TICKS = 60; // 取出物品后等待库存同步的最大时间，3秒

    /**
     * 根据指定的配方启动自动合成。
     * @param recipe 要执行的配方。
     */
    public static void start(AutoCraftRecipe recipe) {
        if (currentState != State.IDLE) {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + LangUtil.translate("ghost.autocraft.status.running")));
            return;
        }
        active = true;
        activeRecipe = recipe;
        retryCount = 0;
        ingredientsPlaced = 0;
        setState(State.STARTING);
        tickCounter = 0;
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + LangUtil.translate("ghost.autocraft.status.enabled_for", activeRecipe.recipeKey)));
        LogUtil.info("[AutoCraft] Service started for recipe: " + activeRecipe.recipeKey);
    }

    /**
     * 停止自动合成。
     */
    public static void stop() {
        if (currentState == State.IDLE) {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + LangUtil.translate("ghost.autocraft.status.not_running")));
            return;
        }
        if (mc.currentScreen != null) {
            mc.thePlayer.closeScreen();
        }
        active = false;
        activeRecipe = null;
        setState(State.IDLE);
        tickCounter = 0;
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghost.autocraft.status.disabled")));
        LogUtil.info("[AutoCraft] Service stopped.");
    }

    private static void setState(State newState) {
        lastState = currentState;
        currentState = newState;
        if (lastState != newState) {
             LogUtil.info("[AutoCraft] State change: " + lastState + " -> " + newState);
        }
    }

    private static void handleRecoverableError(String reason) {
        retryCount++;
        LogUtil.warn("[AutoCraft] Recoverable error: " + reason + ". Retry attempt " + retryCount + "/" + MAX_RETRIES);
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + "[AutoCraft] An error occurred: " + reason + ". Attempting to recover... (" + retryCount + "/" + MAX_RETRIES + ")"));

        if (retryCount > MAX_RETRIES) {
            LogUtil.error("[AutoCraft] Max retries reached. Stopping service.");
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + "[AutoCraft] Recovery failed. Stopping."));
            stop();
            return;
        }

        if (mc.currentScreen != null) {
            mc.thePlayer.closeScreen();
        }
        setDelay(20);
        setState(State.CHECK_SUPPLIES);
    }
    
    /**
     * 检查一个物品栈是否是当前配方所需的输入材料。
     * @param stack 要检查的物品栈。
     * @return 如果是输入材料则返回 true。
     */
    private static boolean isIngredient(ItemStack stack) {
        if (activeRecipe == null || stack == null) return false;
        String displayName = EnumChatFormatting.getTextWithoutFormattingCodes(stack.getDisplayName());
        return activeRecipe.ingredientDisplayName.equals(displayName);
    }

    private static boolean isBarrier(ItemStack stack) {
        return stack != null && stack.getItem() == Item.getItemFromBlock(Blocks.barrier);
    }

    /**
     * 监听聊天消息事件，用于捕捉/pickupstash的完成信号。
     */
    @SubscribeEvent
    public void onChatReceived(ClientChatReceivedEvent event) {
        if (currentState != State.WAITING_FOR_STASH_MESSAGE) {
            return;
        }
        String message = EnumChatFormatting.getTextWithoutFormattingCodes(event.message.getUnformattedText());
        if (message.contains("You picked up") && message.contains("from your material stash")) {
            LogUtil.info("[AutoCraft] Stash pickup confirmation message received.");
            // 收到消息后，重置超时计数器，并设置短暂延迟后进入检查状态
            // 这里给予足够的时间（如3秒）让客户端同步库存
            timeoutCounter = INVENTORY_SYNC_TIMEOUT_TICKS; 
            setDelay(5); 
            setState(State.CHECK_SUPPLIES_AFTER_STASH);
        }
    }

    @SubscribeEvent
    public void onClientTick(TickEvent.ClientTickEvent event) {
        if (event.phase != TickEvent.Phase.END || !active || mc.thePlayer == null || mc.theWorld == null || activeRecipe == null) {
            return;
        }
        
        // setState(currentState); // 移除此行，避免日志刷屏

        if (tickCounter > 0) {
            tickCounter--;
            return;
        }

        try {
            switch (currentState) {
                case STARTING:
                    setState(State.CHECK_SUPPLIES);
                    break;

                case CHECK_SUPPLIES:
                    if (mc.currentScreen != null) { 
                        LogUtil.info("[AutoCraft] Found open screen, closing it before checking supplies.");
                        mc.thePlayer.closeScreen(); 
                        setDelay(10); 
                        break; 
                    }
                    int ingredientCount = getIngredientCount();
                    LogUtil.info("[AutoCraft] Checking supplies for " + activeRecipe.ingredientDisplayName + ". Found " + ingredientCount + ". Required: " + activeRecipe.requiredAmount);
                    if (ingredientCount >= activeRecipe.requiredAmount) {
                        setState(State.OPEN_MENU);
                    } else {
                        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + LangUtil.translate("ghost.autocraft.error.insufficient_ingredient", activeRecipe.ingredientDisplayName)));
                        setState(State.GET_SUPPLIES);
                    }
                    break;

                case GET_SUPPLIES:
                    LogUtil.info("[AutoCraft] Sending /pickupstash command.");
                    mc.thePlayer.sendChatMessage("/pickupstash");
                    timeoutCounter = STASH_MESSAGE_TIMEOUT_TICKS; // 设置超时
                    setState(State.WAITING_FOR_STASH_MESSAGE);
                    break;

                case WAITING_FOR_STASH_MESSAGE:
                    timeoutCounter--;
                    if (timeoutCounter <= 0) {
                        LogUtil.error("[AutoCraft] Timed out waiting for /pickupstash confirmation message.");
                        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghost.autocraft.error.stash_timeout")));
                        stop();
                    }
                    break;

                case CHECK_SUPPLIES_AFTER_STASH:
                    // 这是一个轮询检查状态，直到超时或者材料充足
                    int finalIngredientCount = getIngredientCount();
                    
                    if (finalIngredientCount >= activeRecipe.requiredAmount) {
                        LogUtil.info("[AutoCraft] Supplies confirmed after sync: " + finalIngredientCount + ". Proceeding.");
                        setState(State.OPEN_MENU);
                    } else {
                        if (timeoutCounter > 0) {
                            // 如果还没超时，说明可能还在同步中，继续等待
                            int waitInterval = 5; // 每5 ticks检查一次
                            timeoutCounter -= waitInterval;
                            setDelay(waitInterval);
                            LogUtil.debug("[AutoCraft] Supplies insufficient (" + finalIngredientCount + "/" + activeRecipe.requiredAmount + "). Waiting for inventory sync... " + timeoutCounter + " ticks left.");
                        } else {
                            // 超时了，说明真的不够
                            LogUtil.info("[AutoCraft] Final supply check failed. Found " + finalIngredientCount + ". Required: " + activeRecipe.requiredAmount);
                            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghost.autocraft.error.insufficient_after_stash", activeRecipe.ingredientDisplayName)));
                            LogUtil.error("[AutoCraft] Insufficient " + activeRecipe.ingredientDisplayName + " after picking up stash (timed out). Stopping.");
                            stop();
                        }
                    }
                    break;

                case OPEN_MENU:
                    ItemStack ninthSlot = mc.thePlayer.inventory.getStackInSlot(8);
                    if (ninthSlot != null && ninthSlot.getItem() == Items.nether_star) {
                        LogUtil.info("[AutoCraft] Found Nether Star in slot 9. Using item...");
                        mc.playerController.sendUseItem(mc.thePlayer, mc.theWorld, ninthSlot);
                        setDelay(GhostConfig.AutoCraft.autoCraftMenuOpenDelayTicks);
                        setState(State.WAIT_FOR_MENU_GUI);
                    } else {
                        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghost.autocraft.error.no_nether_star")));
                        LogUtil.error("[AutoCraft] Nether Star not found in slot 9!");
                        stop();
                    }
                    break;

                case WAIT_FOR_MENU_GUI:
                    if (isCorrectGuiOpen(SKYBLOCK_MENU_NAME)) {
                        setState(State.CLICK_CRAFT_TABLE);
                    } else {
                        setState(State.OPEN_MENU);
                    }
                    break;

                case CLICK_CRAFT_TABLE:
                    if (isCorrectGuiOpen(SKYBLOCK_MENU_NAME)) {
                        LogUtil.info("[AutoCraft] Clicking on craft table slot: " + CRAFT_TABLE_SLOT);
                        mc.playerController.windowClick(mc.thePlayer.openContainer.windowId, CRAFT_TABLE_SLOT, 0, 0, mc.thePlayer);
                        setDelay(GhostConfig.AutoCraft.autoCraftTableOpenDelayTicks);
                        setState(State.WAIT_FOR_CRAFT_GUI);
                    } else {
                        setState(State.OPEN_MENU);
                    }
                    break;

                case WAIT_FOR_CRAFT_GUI:
                     if (isCorrectGuiOpen(CRAFT_GUI_NAME)) {
                        LogUtil.info("[AutoCraft] Craft Item GUI opened. Resetting placed ingredients count.");
                        ingredientsPlaced = 0; 
                        setState(State.DO_CRAFT);
                    } else {
                        setState(State.CLICK_CRAFT_TABLE);
                    }
                    break;

                case DO_CRAFT:
                    if (!isCorrectGuiOpen(CRAFT_GUI_NAME)) { 
                        LogUtil.warn("[AutoCraft] Craft GUI is not open! Returning to OPEN_MENU state.");
                        setState(State.OPEN_MENU); 
                        break; 
                    }
                    LogUtil.info("[AutoCraft] In DO_CRAFT state. Placed: " + ingredientsPlaced + "/" + activeRecipe.requiredAmount);

                    if (ingredientsPlaced < activeRecipe.requiredAmount) {
                        int ingredientSlotId = findAnyIngredientSlot();
                        // LogUtil.info("[AutoCraft] Searching for " + activeRecipe.ingredientDisplayName + "... Found in actual container slot: " + ingredientSlotId);
                        if (ingredientSlotId != -1) {
                            ItemStack stackBeforeClick = mc.thePlayer.openContainer.getSlot(ingredientSlotId).getStack();
                            if (stackBeforeClick != null) {
                                slotToWatch = ingredientSlotId;
                                stackSizeToWatch = stackBeforeClick.stackSize;
                                LogUtil.info("[AutoCraft] Performing SHIFT+CLICK on slot " + slotToWatch + " which has " + stackSizeToWatch + " items.");
                                mc.playerController.windowClick(mc.thePlayer.openContainer.windowId, slotToWatch, 0, 1, mc.thePlayer);
                                timeoutCounter = PLACEMENT_TIMEOUT_TICKS;
                                setState(State.WAIT_FOR_ITEM_PLACEMENT);
                            } else {
                                LogUtil.warn("[AutoCraft] Slot " + ingredientSlotId + " became empty before click. Retrying search.");
                            }
                        } else {
                            LogUtil.warn("[AutoCraft] No " + activeRecipe.ingredientDisplayName + " found in inventory mid-craft! Returning to CHECK_SUPPLIES.");
                            setState(State.CHECK_SUPPLIES); 
                        }
                    } else {
                        LogUtil.info("[AutoCraft] All required ingredients placed. Moving to wait for craft result.");
                        timeoutCounter = WAIT_TIMEOUT_TICKS;
                        setState(State.WAIT_FOR_CRAFT_RESULT);
                    }
                    break;
                
                case WAIT_FOR_ITEM_PLACEMENT:
                    timeoutCounter--;
                    if (!isCorrectGuiOpen(CRAFT_GUI_NAME)) {
                        handleRecoverableError("GUI closed unexpectedly");
                        break;
                    }
                    ItemStack currentStack = mc.thePlayer.openContainer.getSlot(slotToWatch).getStack();
                    int currentStackSize = (currentStack == null) ? 0 : currentStack.stackSize;

                    // LogUtil.info("[AutoCraft] Waiting for placement confirmation on slot " + slotToWatch + ". Original size: " + stackSizeToWatch + ", Current size: " + currentStackSize + ". Timeout in: " + timeoutCounter);

                    if (currentStack == null || currentStackSize < stackSizeToWatch) {
                        int amountPlaced = stackSizeToWatch - currentStackSize;
                        ingredientsPlaced += amountPlaced;
                        LogUtil.info("[AutoCraft] Placement confirmed. " + amountPlaced + " items placed. Total placed: " + ingredientsPlaced);
                        slotToWatch = -1;
                        stackSizeToWatch = -1;
                        setDelay(GhostConfig.AutoCraft.autoCraftPlacementDelayTicks);
                        setState(State.DO_CRAFT);
                    } else if (timeoutCounter <= 0) {
                        LogUtil.error("[AutoCraft] Timed out waiting for item placement from slot " + slotToWatch + ".");
                        handleRecoverableError("Item placement timeout");
                    }
                    break;

                case WAIT_FOR_CRAFT_RESULT:
                    timeoutCounter--;
                    if (!isCorrectGuiOpen(CRAFT_GUI_NAME)) { setState(State.OPEN_MENU); break; }
                    
                    ItemStack resultStack = mc.thePlayer.openContainer.getSlot(CRAFT_RESULT_SLOT).getStack();
                    if (resultStack != null && !isBarrier(resultStack)) {
                        LogUtil.info("[AutoCraft] Crafting result detected in output slot!");
                        setState(State.TAKE_PRODUCT);
                    } else if (timeoutCounter <= 0) {
                        handleRecoverableError("Crafting result timeout");
                    }
                    break;

                case TAKE_PRODUCT:
                    if (!isCorrectGuiOpen(CRAFT_GUI_NAME)) { setState(State.OPEN_MENU); break; }
                    LogUtil.info("[AutoCraft] Taking product from slot " + CRAFT_RESULT_SLOT);
                    mc.playerController.windowClick(mc.thePlayer.openContainer.windowId, CRAFT_RESULT_SLOT, 0, 1, mc.thePlayer);
                    retryCount = 0;
                    LogUtil.info("[AutoCraft] Craft cycle successful. Retry counter reset.");
                    timeoutCounter = WAIT_TIMEOUT_TICKS;
                    setState(State.WAIT_FOR_SLOT_CLEAR);
                    break;

                case WAIT_FOR_SLOT_CLEAR:
                    timeoutCounter--;
                    if (!isCorrectGuiOpen(CRAFT_GUI_NAME)) { setState(State.OPEN_MENU); break; }

                    ItemStack slotContent = mc.thePlayer.openContainer.getSlot(CRAFT_RESULT_SLOT).getStack();
                    if (isBarrier(slotContent)) {
                        LogUtil.info("[AutoCraft] Slot cleared. Checking supplies for next cycle.");
                        
                        // 优化：在进入下一次合成循环前立即检查材料是否充足
                        if (getIngredientCount() < activeRecipe.requiredAmount) {
                            LogUtil.info("[AutoCraft] Insufficient supplies for next cycle. Triggering supply check.");
                            if (mc.currentScreen != null) {
                                mc.thePlayer.closeScreen();
                            }
                            setState(State.CHECK_SUPPLIES);
                        } else {
                            LogUtil.info("[AutoCraft] Supplies sufficient. Pausing before next cycle.");
                            setDelay(GhostConfig.AutoCraft.autoCraftCycleDelayTicks);
                            ingredientsPlaced = 0;
                            setState(State.DO_CRAFT);
                        }
                    } else if (timeoutCounter <= 0) {
                        handleRecoverableError("Pickup slot clear timeout");
                    }
                    break;
            }
        } catch (Exception e) {
            LogUtil.error("[AutoCraft] An unexpected error occurred: " + e.getMessage());
            e.printStackTrace();
            stop();
        }
    }

    private static int getIngredientCount() {
        if (activeRecipe == null) return 0;
        int count = 0;
        InventoryPlayer inventory = mc.thePlayer.inventory;
        for (int i = 0; i < inventory.getSizeInventory(); i++) {
            ItemStack stack = inventory.getStackInSlot(i);
            if (isIngredient(stack)) {
                count += stack.stackSize;
            }
        }
        return count;
    }
    
    private static int findAnyIngredientSlot() {
        if (mc.thePlayer.openContainer == null || activeRecipe == null) {
            return -1;
        }
        for (Slot slot : mc.thePlayer.openContainer.inventorySlots) {
            if (slot.getHasStack() && isIngredient(slot.getStack()) && slot.inventory instanceof InventoryPlayer) {
                return slot.slotNumber;
            }
        }
        return -1;
    }

    private static boolean isCorrectGuiOpen(String guiName) {
        String currentGuiName = getGuiName();
        return currentGuiName != null && currentGuiName.contains(guiName);
    }
    
    private static String getGuiName() {
        if (mc.currentScreen instanceof GuiChest) {
            GuiChest chest = (GuiChest) mc.currentScreen;
            ContainerChest container = (ContainerChest) chest.inventorySlots;
            return container.getLowerChestInventory().getDisplayName().getUnformattedText();
        }
        return null;
    }

    private static void setDelay(int ticks) {
        tickCounter = ticks;
    }
}

features/autocraft/AutoCraftCommand.java:
package com.zihaomc.ghost.features.autocraft;

import com.zihaomc.ghost.LangUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.event.HoverEvent;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * 处理 /autocraft 命令，用于启动、停止、管理和重载自动合成功能。
 */
public class AutoCraftCommand extends CommandBase {

    @Override
    public String getCommandName() {
        return "autocraft";
    }

    @Override
    public String getCommandUsage(ICommandSender sender) {
        return LangUtil.translate("ghost.autocraft.command.usage");
    }

    @Override
    public int getRequiredPermissionLevel() {
        return 0; // 客户端命令，无需权限
    }

    @Override
    public boolean canCommandSenderUseCommand(ICommandSender sender) {
        return true;
    }

    @Override
    public void processCommand(ICommandSender sender, String[] args) throws CommandException {
        if (args.length == 0) {
            throw new WrongUsageException(getCommandUsage(sender));
        }

        String action = args[0].toLowerCase();

        switch (action) {
            case "start":
                handleStart(sender, args);
                break;
            case "stop":
                AutoCraftHandler.stop();
                break;
            case "reload":
                AutoCraftRecipeManager.reloadRecipes();
                sender.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + LangUtil.translate("ghost.autocraft.command.reload.success")));
                break;
            case "add":
                handleAdd(sender, args);
                break;
            case "remove":
                handleRemove(sender, args);
                break;
            case "list":
                handleList(sender);
                break;
            default:
                throw new WrongUsageException(getCommandUsage(sender));
        }
    }

    private void handleStart(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 2) {
            throw new WrongUsageException(LangUtil.translate("ghost.autocraft.command.usage.start"));
        }
        String recipeKey = args[1];
        AutoCraftRecipe recipe = AutoCraftRecipeManager.getRecipe(recipeKey);
        if (recipe == null) {
            throw new CommandException(LangUtil.translate("ghost.autocraft.error.recipe_not_found"), recipeKey);
        }
        AutoCraftHandler.start(recipe);
    }

    private void handleAdd(ICommandSender sender, String[] args) throws CommandException {
        if (args.length != 4) {
            String[] usageLines = LangUtil.translate("ghost.autocraft.command.usage.add").split("\n");
            for(String line : usageLines) {
                sender.addChatMessage(new ChatComponentText(line));
            }
            return;
        }
        String key = args[1].toLowerCase();
        if (AutoCraftRecipeManager.getRecipe(key) != null) {
            throw new CommandException(LangUtil.translate("ghost.autocraft.error.recipe_already_exists"), key);
        }

        String ingredientName = args[2].replace('_', ' ');
        int amount = parseAmount(args[3]);

        AutoCraftRecipe newRecipe = new AutoCraftRecipe(key, ingredientName, amount);
        AutoCraftRecipeManager.registerRecipe(newRecipe);
        AutoCraftRecipeManager.saveRecipes();

        sender.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + LangUtil.translate("ghost.autocraft.command.add.success", key)));
    }

    private void handleRemove(ICommandSender sender, String[] args) throws CommandException {
        if (args.length != 2) {
            throw new WrongUsageException(LangUtil.translate("ghost.autocraft.command.usage.remove"));
        }
        String key = args[1].toLowerCase();
        if (AutoCraftRecipeManager.getRecipe(key) == null) {
            throw new CommandException(LangUtil.translate("ghost.autocraft.error.recipe_not_found"), key);
        }
        
        AutoCraftRecipeManager.removeRecipe(key);
        AutoCraftRecipeManager.saveRecipes();
        
        sender.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + LangUtil.translate("ghost.autocraft.command.remove.success", key)));
    }

    private void handleList(ICommandSender sender) {
        Collection<AutoCraftRecipe> recipes = AutoCraftRecipeManager.getAllRecipes();
        if (recipes.isEmpty()) {
            sender.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + LangUtil.translate("ghost.autocraft.command.list.empty")));
            return;
        }

        sender.addChatMessage(new ChatComponentText(EnumChatFormatting.GOLD + "--- " + LangUtil.translate("ghost.autocraft.command.list.header") + " ---"));
        for (AutoCraftRecipe recipe : recipes) {
            String hoverText = String.format(
                "§e材料: §f%s §ex%d",
                recipe.ingredientDisplayName, recipe.requiredAmount
            );
            ChatComponentText line = new ChatComponentText("§a- " + recipe.recipeKey);
            line.setChatStyle(new ChatStyle().setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ChatComponentText(hoverText))));
            sender.addChatMessage(line);
        }
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length == 1) {
            return getListOfStringsMatchingLastWord(args, "start", "stop", "add", "remove", "list", "reload");
        }
        
        String action = args[0].toLowerCase();
        
        if ("start".equals(action) || "remove".equals(action)) {
            if (args.length == 2) {
                return getListOfStringsMatchingLastWord(args, AutoCraftRecipeManager.getAllRecipeKeys());
            }
        }

        if ("add".equals(action)) {
            // 当输入第二个参数 (配方Key) 时，提供一个固定的占位符
            if (args.length == 2) {
                return getListOfStringsMatchingLastWord(args, Collections.singletonList("recipe_key"));
            }
            // 当输入第三个参数 (材料名) 时
            if (args.length == 3) {
                EntityPlayerSP player = Minecraft.getMinecraft().thePlayer;
                if (player != null) {
                    Set<String> uniqueItemNames = getUniqueItemNamesFromInventory(player);
                    if (!uniqueItemNames.isEmpty()) {
                        return getListOfStringsMatchingLastWord(args, uniqueItemNames.stream().map(name -> name.replace(' ', '_')).collect(Collectors.toList()));
                    }
                }
                return Collections.emptyList();
            }
            if (args.length == 4) { // requiredAmount
                return getListOfStringsMatchingLastWord(args, "64", "160", "320", "576", "64*");
            }
        }
        
        return null;
    }

    /**
     * 解析数量字符串，支持 'x' 或 '*' 作为乘法符号。
     */
    private int parseAmount(String amountString) throws CommandException {
        amountString = amountString.toLowerCase();
        try {
            if (amountString.contains("*") || amountString.contains("x")) {
                String[] parts = amountString.split("[*x]");
                if (parts.length == 2) {
                    int num1 = Integer.parseInt(parts[0].trim());
                    int num2 = Integer.parseInt(parts[1].trim());
                    return num1 * num2;
                }
            }
            return CommandBase.parseInt(amountString);
        } catch (NumberFormatException e) {
            throw new CommandException(LangUtil.translate("ghost.autocraft.error.invalid_amount_format"), amountString);
        }
    }

    /**
     * 扫描玩家物品栏并返回所有唯一的物品显示名称。
     */
    private Set<String> getUniqueItemNamesFromInventory(EntityPlayerSP player) {
        Set<String> uniqueItemNames = new HashSet<>();
        if (player != null) {
            for (ItemStack itemStack : player.inventory.mainInventory) {
                if (itemStack != null) {
                    String itemName = EnumChatFormatting.getTextWithoutFormattingCodes(itemStack.getDisplayName());
                    if (!itemName.trim().isEmpty()) {
                        uniqueItemNames.add(itemName);
                    }
                }
            }
        }
        return uniqueItemNames;
    }
}

features/visual/PlayerArrowRendererHandler.java:
package com.zihaomc.ghost.features.visual;

import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.client.event.RenderPlayerEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

/**
 * [最终版]
 * 使用 RenderPlayerEvent 来确保与 OptiFine 的最大兼容性。
 * 这是隐藏玩家身上箭矢的标准且最可靠的方法。
 */
public class PlayerArrowRendererHandler {

    // 用于临时存储玩家身上真实的箭矢数量
    private int originalArrowCount = -1;

    /**
     * 在渲染玩家之前触发。
     */
    @SubscribeEvent
    public void onRenderPlayerPre(RenderPlayerEvent.Pre event) {
        // 如果功能未开启，直接返回
        if (!GhostConfig.GameplayTweaks.hideArrowsOnPlayers) {
            return;
        }

        EntityPlayer player = event.entityPlayer;
        
        int currentArrowCount = player.getArrowCountInEntity();

        if (currentArrowCount > 0) {
            // 备份真实的箭矢数量
            this.originalArrowCount = currentArrowCount;
            // 临时将箭矢数量设置为0，以阻止渲染
            player.setArrowCountInEntity(0);
        }
    }

    /**
     * 在渲染玩家之后触发。
     */
    @SubscribeEvent
    public void onRenderPlayerPost(RenderPlayerEvent.Post event) {
        // 如果我们之前修改过数量，就将其恢复
        if (this.originalArrowCount != -1) {
            EntityPlayer player = event.entityPlayer;
            
            // 恢复真实的箭矢数量，以保证游戏逻辑正常
            player.setArrowCountInEntity(this.originalArrowCount);
            // 重置备份变量
            this.originalArrowCount = -1;
        }
    }
}

features/automine/PacketNormalMiningStrategy.java:
package com.zihaomc.ghost.features.automine;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.RotationUtil;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.network.play.client.C07PacketPlayerDigging;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.Vec3;

/**
 * 使用数据包进行常规挖掘的策略。
 * 它会模拟挖掘进度，并在进度达到100%时发送停止挖掘的数据包。
 */
public class PacketNormalMiningStrategy implements IMiningStrategy {

    private final Minecraft mc = Minecraft.getMinecraft();
    private float breakProgress = 0.0f;
    private BlockPos lastPacketTarget = null;

    @Override
    public void onStartMining(BlockPos target) {
        this.breakProgress = 0.0f;
        // lastPacketTarget 会在首次发包时设置
    }

    @Override
    public void onStopMining() {
        // 此模式下无需特殊清理
    }

    @Override
    public void handleMiningTick(BlockPos target, Vec3 bestPointToLookAt) {
        // --- 旋转逻辑 ---
        float[] targetRots = RotationUtil.getRotations(bestPointToLookAt);
        if (GhostConfig.AutoMine.instantRotation) {
            mc.thePlayer.rotationYaw = targetRots[0];
            mc.thePlayer.rotationPitch = targetRots[1];
        } else {
            float[] smoothRots = RotationUtil.getSmoothRotations(mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, targetRots[0], targetRots[1], (float) GhostConfig.AutoMine.rotationSpeed);
            mc.thePlayer.rotationYaw = smoothRots[0];
            mc.thePlayer.rotationPitch = smoothRots[1];
        }

        // --- 挖掘逻辑 ---
        MovingObjectPosition mouseOver = mc.objectMouseOver;
        if (mouseOver == null || mouseOver.typeOfHit != MovingObjectPosition.MovingObjectType.BLOCK || !mouseOver.getBlockPos().equals(target)) {
            // 如果没对准，就等待下一Tick
            return;
        }

        EnumFacing facing = mouseOver.sideHit;
        IBlockState targetBlockState = mc.theWorld.getBlockState(target);

        // 如果是新的目标，发送开始挖掘的数据包
        if (!target.equals(lastPacketTarget)) {
            breakProgress = 0.0f;
            mc.getNetHandler().addToSendQueue(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.START_DESTROY_BLOCK, target, facing));
            lastPacketTarget = target;
        }

        // 持续挥手并累加挖掘进度
        mc.thePlayer.swingItem();
        float hardness = targetBlockState.getBlock().getPlayerRelativeBlockHardness(mc.thePlayer, mc.theWorld, target);
        breakProgress += hardness;

        // 挖掘完成
        if (breakProgress >= 1.0f) {
            mc.getNetHandler().addToSendQueue(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK, target, facing));
            // 触发反作弊回弹检测
            AutoMineHandler.startValidation(target);
        }
    }

    @Override
    public String getModeName() {
        return "PACKET_NORMAL";
    }
}

features/automine/AutoMineTargetManager.java:
package com.zihaomc.ghost.features.automine;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.zihaomc.ghost.features.ghostblock.data.GhostBlockData;
import com.zihaomc.ghost.utils.LogUtil;
import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ResourceLocation;

import java.io.*;
import java.lang.reflect.Type;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * 管理 AutoMine 目标（坐标、方块类型、权重、自定义组）的持久化。
 */
public class AutoMineTargetManager {

    private static final String CONFIG_DIR = "config/Ghost/";
    private static final String TARGETS_COORD_FILE_NAME = "automine_targets.json";
    private static final String TARGET_BLOCKS_FILE_NAME = "automine_blocks.json";
    private static final String TARGET_WEIGHTS_FILE_NAME = "automine_weights.json";
    private static final String TARGET_GROUPS_FILE_NAME = "automine_groups.json";
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    public static final Map<String, List<BlockPos>> worldTargetBlocks = new ConcurrentHashMap<>();
    public static final Set<BlockData> targetBlockTypes = new HashSet<>();
    public static final Map<Block, Integer> targetBlockWeights = new ConcurrentHashMap<>();
    public static final Map<String, List<String>> customBlockGroups = new ConcurrentHashMap<>();

    public static class BlockData {
        public final Block block;
        public final int metadata;

        public BlockData(Block block, int metadata) {
            this.block = block;
            this.metadata = metadata;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            BlockData blockData = (BlockData) o;
            return metadata == blockData.metadata && Objects.equals(block.getRegistryName(), blockData.block.getRegistryName());
        }

        @Override
        public int hashCode() {
            return Objects.hash(block.getRegistryName(), metadata);
        }

        @Override
        public String toString() {
            String baseId = block.getRegistryName().toString();
            return metadata == -1 ? baseId : baseId + ":" + metadata;
        }
    }

    private static class AutoMineTargetEntry {
        int x, y, z;
        public AutoMineTargetEntry(BlockPos pos) {
            this.x = pos.getX();
            this.y = pos.getY();
            this.z = pos.getZ();
        }
    }

    private static File getCoordsFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) configDir.mkdirs();
        return new File(configDir, TARGETS_COORD_FILE_NAME);
    }
    
    private static File getBlocksFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) configDir.mkdirs();
        return new File(configDir, TARGET_BLOCKS_FILE_NAME);
    }

    private static File getWeightsFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) configDir.mkdirs();
        return new File(configDir, TARGET_WEIGHTS_FILE_NAME);
    }
    
    private static File getGroupsFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) configDir.mkdirs();
        return new File(configDir, TARGET_GROUPS_FILE_NAME);
    }

    public static void loadTargets() {
        loadCoordinates();
        loadBlockTypes();
        loadBlockWeights();
        loadBlockGroups();
    }

    private static String getCurrentWorldId() {
        if (Minecraft.getMinecraft() != null && Minecraft.getMinecraft().theWorld != null) {
            return GhostBlockData.getWorldIdentifier(Minecraft.getMinecraft().theWorld);
        }
        return null;
    }

    public static List<BlockPos> getCurrentTargetBlocks() {
        String worldId = getCurrentWorldId();
        if (worldId == null) {
            return Collections.emptyList();
        }
        return worldTargetBlocks.computeIfAbsent(worldId, k -> new ArrayList<>());
    }
    
    private static void loadCoordinates() {
        File targetsFile = getCoordsFile();
        if (!targetsFile.exists()) return;
        try (Reader reader = new FileReader(targetsFile)) {
            Type type = new TypeToken<Map<String, List<AutoMineTargetEntry>>>(){}.getType();
            Map<String, List<AutoMineTargetEntry>> loadedMap = GSON.fromJson(reader, type);
            if (loadedMap != null) {
                worldTargetBlocks.clear();
                for (Map.Entry<String, List<AutoMineTargetEntry>> worldEntry : loadedMap.entrySet()) {
                    List<BlockPos> blockPosList = worldEntry.getValue().stream()
                        .map(entry -> new BlockPos(entry.x, entry.y, entry.z))
                        .collect(Collectors.toList());
                    worldTargetBlocks.put(worldEntry.getKey(), blockPosList);
                }
                long totalTargets = worldTargetBlocks.values().stream().mapToLong(List::size).sum();
                LogUtil.info("log.automine.targets.loaded", totalTargets);
            }
        } catch (Exception e) {
            LogUtil.error("log.automine.targets.load_failed", e.getMessage());
        }
    }
    
    private static void loadBlockTypes() {
        File blocksFile = getBlocksFile();
        if (!blocksFile.exists()) return;
        try (Reader reader = new FileReader(blocksFile)) {
            Type type = new TypeToken<Set<String>>(){}.getType();
            Set<String> loadedBlockIds = GSON.fromJson(reader, type);
            if (loadedBlockIds != null) {
                targetBlockTypes.clear();
                for (String blockIdString : loadedBlockIds) {
                    try {
                        String blockName = blockIdString;
                        int meta = -1;
                        int lastColon = blockIdString.lastIndexOf(':');
                        if (lastColon > 0 && lastColon > blockIdString.indexOf(':')) {
                             try {
                                meta = Integer.parseInt(blockIdString.substring(lastColon + 1));
                                blockName = blockIdString.substring(0, lastColon);
                            } catch (NumberFormatException e) {
                            }
                        }
                        Block block = Block.blockRegistry.getObject(new ResourceLocation(blockName));
                        if (block != null) {
                            targetBlockTypes.add(new BlockData(block, meta));
                        } else {
                            LogUtil.warn("log.automine.block.id.invalid", blockIdString);
                        }
                    } catch (Exception e) {
                        LogUtil.warn("log.automine.block.id.invalid", blockIdString);
                    }
                }
                LogUtil.info("log.automine.blocks.loaded", targetBlockTypes.size());
            }
        } catch (Exception e) {
            LogUtil.error("log.automine.targets.load_failed", e.getMessage());
        }
    }

    private static void loadBlockWeights() {
        File weightsFile = getWeightsFile();
        if (!weightsFile.exists()) return;
        try (Reader reader = new FileReader(weightsFile)) {
            Type type = new TypeToken<Map<String, Integer>>(){}.getType();
            Map<String, Integer> loadedWeights = GSON.fromJson(reader, type);
            if (loadedWeights != null) {
                targetBlockWeights.clear();
                for (Map.Entry<String, Integer> entry : loadedWeights.entrySet()) {
                    Block block = Block.blockRegistry.getObject(new ResourceLocation(entry.getKey()));
                    if (block != null) {
                        targetBlockWeights.put(block, entry.getValue());
                    } else {
                        LogUtil.warn("log.automine.block.id.invalid", entry.getKey());
                    }
                }
                LogUtil.info("log.automine.weights.loaded", targetBlockWeights.size());
            }
        } catch (Exception e) {
            LogUtil.error("log.automine.weights.load_failed", e.getMessage());
        }
    }

    private static void loadBlockGroups() {
        File groupsFile = getGroupsFile();
        if (!groupsFile.exists()) {
            PredefinedGroupManager.initializePredefinedGroups();
            return;
        }
        try (Reader reader = new FileReader(groupsFile)) {
            Type type = new TypeToken<Map<String, List<String>>>(){}.getType();
            Map<String, List<String>> loadedGroups = GSON.fromJson(reader, type);
            if (loadedGroups != null) {
                customBlockGroups.clear();
                customBlockGroups.putAll(loadedGroups);
                LogUtil.info("log.automine.groups.loaded", customBlockGroups.size());
            }
        } catch (Exception e) {
            LogUtil.error("log.automine.groups.load_failed", e.getMessage());
        }
    }

    public static void saveCoordinates() {
        File targetsFile = getCoordsFile();
        worldTargetBlocks.entrySet().removeIf(entry -> entry.getValue() == null || entry.getValue().isEmpty());

        if (worldTargetBlocks.isEmpty()) {
            if (targetsFile.exists()) targetsFile.delete();
            return;
        }
        try (Writer writer = new FileWriter(targetsFile)) {
            Map<String, List<AutoMineTargetEntry>> mapToSave = new HashMap<>();
            for (Map.Entry<String, List<BlockPos>> worldEntry : worldTargetBlocks.entrySet()) {
                List<AutoMineTargetEntry> targetEntries = worldEntry.getValue().stream()
                    .map(AutoMineTargetEntry::new)
                    .collect(Collectors.toList());
                mapToSave.put(worldEntry.getKey(), targetEntries);
            }
            GSON.toJson(mapToSave, writer);
        } catch (IOException e) {
            LogUtil.error("log.automine.targets.save_failed", e.getMessage());
        }
    }

    public static void saveBlockTypes() {
        File blocksFile = getBlocksFile();
        if (targetBlockTypes.isEmpty()) {
            if (blocksFile.exists()) blocksFile.delete();
            return;
        }
        Set<String> blockIdsToSave = targetBlockTypes.stream().map(BlockData::toString).collect(Collectors.toSet());
        try (Writer writer = new FileWriter(blocksFile)) {
            GSON.toJson(blockIdsToSave, writer);
        } catch (IOException e) {
            LogUtil.error("log.automine.targets.save_failed", e.getMessage());
        }
    }

    public static void saveBlockWeights() {
        File weightsFile = getWeightsFile();
        if (targetBlockWeights.isEmpty()) {
            if (weightsFile.exists()) weightsFile.delete();
            return;
        }
        Map<String, Integer> weightsToSave = targetBlockWeights.entrySet().stream().collect(Collectors.toMap(entry -> entry.getKey().getRegistryName().toString(), Map.Entry::getValue));
        try (Writer writer = new FileWriter(weightsFile)) {
            GSON.toJson(weightsToSave, writer);
        } catch (IOException e) {
            LogUtil.error("log.automine.weights.save_failed", e.getMessage());
        }
    }

    public static void saveBlockGroups() {
        File groupsFile = getGroupsFile();
        if (customBlockGroups.isEmpty()) {
            if (groupsFile.exists()) {
                groupsFile.delete();
            }
            return;
        }
        try (Writer writer = new FileWriter(groupsFile)) {
            GSON.toJson(customBlockGroups, writer);
        } catch (IOException e) {
            LogUtil.error("log.automine.groups.save_failed", e.getMessage());
        }
    }
}


features/automine/SimulateMiningStrategy.java:
package com.zihaomc.ghost.features.automine;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.RotationUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.Vec3;

/**
 * 模拟玩家按键进行挖掘的策略。
 * 这是最安全、最像人类玩家行为的模式。
 */
public class SimulateMiningStrategy implements IMiningStrategy {

    private final Minecraft mc = Minecraft.getMinecraft();

    @Override
    public void onStartMining(BlockPos target) {
        // 在切换目标时，确保攻击键是松开的
        if (mc.gameSettings.keyBindAttack.isKeyDown()) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindAttack.getKeyCode(), false);
        }
    }

    @Override
    public void onStopMining() {
        // 停止时，确保攻击键是松开的
        if (mc.gameSettings.keyBindAttack.isKeyDown()) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindAttack.getKeyCode(), false);
        }
    }

    @Override
    public void handleMiningTick(BlockPos target, Vec3 bestPointToLookAt) {
        // --- 旋转逻辑 ---
        float[] targetRots = RotationUtil.getRotations(bestPointToLookAt);
        if (GhostConfig.AutoMine.instantRotation) {
            mc.thePlayer.rotationYaw = targetRots[0];
            mc.thePlayer.rotationPitch = targetRots[1];
        } else {
            float[] smoothRots = RotationUtil.getSmoothRotations(mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, targetRots[0], targetRots[1], (float) GhostConfig.AutoMine.rotationSpeed);
            mc.thePlayer.rotationYaw = smoothRots[0];
            mc.thePlayer.rotationPitch = smoothRots[1];
        }

        // --- 挖掘逻辑 ---
        MovingObjectPosition mouseOver = mc.objectMouseOver;
        boolean isCrosshairOnTarget = mouseOver != null && mouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && mouseOver.getBlockPos().equals(target);

        if (isCrosshairOnTarget) {
            // 如果准星对准了目标，就按下攻击键
            if (!mc.gameSettings.keyBindAttack.isKeyDown()) {
                KeyBinding.setKeyBindState(mc.gameSettings.keyBindAttack.getKeyCode(), true);
            }
        } else {
            // 否则松开
            if (mc.gameSettings.keyBindAttack.isKeyDown()) {
                KeyBinding.setKeyBindState(mc.gameSettings.keyBindAttack.getKeyCode(), false);
            }
        }
    }

    @Override
    public String getModeName() {
        return "SIMULATE";
    }
}

features/automine/IMiningStrategy.java:
package com.zihaomc.ghost.features.automine;

import net.minecraft.util.BlockPos;
import net.minecraft.util.Vec3;

/**
 * 自动挖掘策略的接口。
 * 定义了不同挖掘模式（如模拟、数据包）需要实现的通用方法。
 */
public interface IMiningStrategy {

    /**
     * 当开始挖掘一个新的目标方块时调用。
     * 用于重置策略内部的状态。
     * @param target 新的目标方块坐标。
     */
    void onStartMining(BlockPos target);

    /**
     * 当自动挖掘功能完全停止时调用。
     * 用于执行清理工作，例如释放按键。
     */
    void onStopMining();

    /**
     * 在每个 "MINING" 状态的游戏刻（tick）中调用。
     * 这是执行核心挖掘逻辑的地方。
     * @param target 当前的目标方块坐标。
     * @param bestPointToLookAt 建议的瞄准点。
     */
    void handleMiningTick(BlockPos target, Vec3 bestPointToLookAt);

    /**
     * 获取此策略的模式名称。
     * @return 模式的字符串表示形式。
     */
    String getModeName();
}

features/automine/AutoMineHandler.java:
package com.zihaomc.ghost.features.automine;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.RotationUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.event.ClickEvent;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.*;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * "Auto Mine" 功能的核心处理器。
 * (重构后) 负责状态管理、目标搜寻，并将具体的挖掘行为委托给策略对象。
 * 同时处理反作弊回弹检测。
 */
public class AutoMineHandler {

    private static final int TOOL_SWITCH_DELAY_TICKS = 5;

    public enum MiningMode {
        SIMULATE,
        PACKET_NORMAL,
        PACKET_INSTANT
    }

    private enum State {
        IDLE,
        SWITCHING_TARGET,
        MINING,
        WAITING,
        VALIDATING_BREAK,
        POST_SWITCH_DELAY
    }

    private static final Minecraft mc = Minecraft.getMinecraft();
    private static boolean isActive = false;
    private static BlockPos currentTarget = null;
    private static IBlockState initialTargetState = null;
    private static State currentState = State.IDLE;
    private int waitTicks = 0;
    private int delayTicks = 0;

    private static final ConcurrentHashMap<BlockPos, Block> unmineableBlacklist = new ConcurrentHashMap<>();
    private Long miningStartTime = null;

    private static boolean modIsControllingSneak = false;

    private static int randomMoveTicks = 0;
    private static int currentMoveDuration = 0;
    private static KeyBinding currentMoveKey = null;

    private static IBlockState lastMinedState = null;
    private static final int DEFAULT_WEIGHT = 10;

    private static IMiningStrategy currentStrategy = new SimulateMiningStrategy();
    private static MiningMode currentMiningMode = MiningMode.SIMULATE;

    private static boolean isPausedByGui = false;

    private static BlockPos blockToValidate = null;
    private static int validationTicks = 0;
    private static final int VALIDATION_DELAY_TICKS = 8;
    private static boolean awaitingRollbackConfirmation = false;
    private static int packetBreaksSinceStart = 0;
    private static final int CHECKS_TO_PERFORM = 3;
    private static boolean checksTemporarilyDisabled = false;

    private static final Set<AutoMineTargetManager.BlockData> titaniumBlockTypes = new HashSet<>();
    private static final Set<String> MITHRIL_ORE_IDS = new HashSet<>(Arrays.asList(
            "minecraft:wool:7", "minecraft:prismarine", "minecraft:wool:11", "minecraft:stained_hardened_clay:9"
    ));
    private static int originalSlot = -1;
    private static final Pattern BREAKING_POWER_PATTERN = Pattern.compile("Breaking Power (\\d+)");
    private static boolean isCleanupMode = false;
    private static boolean mithrilOptimizationIsActive = false;
    private static boolean cleanupToolTooWeakNotified = false;
    private static BlockPos lastSkippedBlock = null;

    public static void toggle() {
        if (awaitingRollbackConfirmation) {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghost.automine.error.rollback_confirm_pending")));
            return;
        }

        boolean hasAnyTargets = !AutoMineTargetManager.getCurrentTargetBlocks().isEmpty() || !AutoMineTargetManager.targetBlockTypes.isEmpty();
        if (!isActive && !hasAnyTargets) {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghost.automine.error.no_targets_set")));
            return;
        }

        isActive = !isActive;
        isPausedByGui = false;

        String status = isActive ? EnumChatFormatting.GREEN + LangUtil.translate("ghost.generic.enabled") : EnumChatFormatting.RED + LangUtil.translate("ghost.generic.disabled");
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.AQUA + LangUtil.translate("ghost.keybind.toggle.automine") + " " + status));

        if (isActive) {
            validateAndActivateMithrilOptimization();
            currentState = State.SWITCHING_TARGET;
            packetBreaksSinceStart = 0;
        } else {
            reset();
            checksTemporarilyDisabled = false;
        }
    }

    private static void reset() {
        if (mc.gameSettings.keyBindAttack.isKeyDown()) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindAttack.getKeyCode(), false);
        }
        if (modIsControllingSneak) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindSneak.getKeyCode(), false);
            modIsControllingSneak = false;
        }
        if (currentMoveKey != null) {
            KeyBinding.setKeyBindState(currentMoveKey.getKeyCode(), false);
            currentMoveKey = null;
        }
        if (currentStrategy != null) {
            currentStrategy.onStopMining();
        }

        if (originalSlot != -1) {
            mc.thePlayer.inventory.currentItem = originalSlot;
            originalSlot = -1;
        }

        randomMoveTicks = 0;
        currentMoveDuration = 0;
        currentState = State.IDLE;
        currentTarget = null;
        initialTargetState = null;
        isActive = false;
        unmineableBlacklist.clear();
        lastMinedState = null;
        blockToValidate = null;
        validationTicks = 0;
        isCleanupMode = false;
        mithrilOptimizationIsActive = false;
        cleanupToolTooWeakNotified = false;
        lastSkippedBlock = null;
    }

    public static void setMiningMode(MiningMode mode) {
        if (currentMiningMode != mode) {
            currentMiningMode = mode;
            GhostConfig.setAutoMineMiningMode(mode.name());

            switch (mode) {
                case SIMULATE: currentStrategy = new SimulateMiningStrategy(); break;
                case PACKET_NORMAL: currentStrategy = new PacketNormalMiningStrategy(); break;
                case PACKET_INSTANT: currentStrategy = new PacketInstantMiningStrategy(); break;
            }

            if (isActive) {
                reset();
                toggle();
            }
            mc.thePlayer.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.mode.set", mode.name())));
        }
    }

    public static void setCurrentMiningMode_noMessage(MiningMode mode) {
        currentMiningMode = mode;
        switch (mode) {
            case SIMULATE: currentStrategy = new SimulateMiningStrategy(); break;
            case PACKET_NORMAL: currentStrategy = new PacketNormalMiningStrategy(); break;
            case PACKET_INSTANT: currentStrategy = new PacketInstantMiningStrategy(); break;
        }
    }

    public static MiningMode getMiningMode() { return currentMiningMode; }
    public static void clearBlacklist() { unmineableBlacklist.clear(); }
    public static boolean isActive() { return isActive; }

    public static void startValidation(BlockPos pos) {
        packetBreaksSinceStart++;
        if (GhostConfig.AutoMine.antiCheatCheck && !checksTemporarilyDisabled && packetBreaksSinceStart <= CHECKS_TO_PERFORM) {
            blockToValidate = pos;
            validationTicks = 0;
            currentState = State.VALIDATING_BREAK;
        } else {
            currentState = State.SWITCHING_TARGET;
        }
    }

    public static void onRollbackFeedback(String action) {
        if (!awaitingRollbackConfirmation) return;
        awaitingRollbackConfirmation = false;

        if ("continue".equalsIgnoreCase(action)) {
            checksTemporarilyDisabled = true;
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + LangUtil.translate("ghost.automine.feedback.continue")));
            toggle();
        } else if ("disable".equalsIgnoreCase(action)) {
            GhostConfig.setAutoMineAntiCheatCheck(false);
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GOLD + LangUtil.translate("ghost.automine.feedback.disable")));
            toggle();
        } else {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + LangUtil.translate("ghost.automine.feedback.stop")));
        }
    }

    @SubscribeEvent
    public void onClientTick(TickEvent.ClientTickEvent event) {
        if (event.phase != TickEvent.Phase.END || mc.thePlayer == null || mc.theWorld == null) return;

        if (currentMiningMode == MiningMode.SIMULATE) {
            if (mc.currentScreen != null) {
                if (isActive && !isPausedByGui) {
                    reset();
                    isPausedByGui = true;
                }
                return;
            } else {
                if (isPausedByGui) {
                    isPausedByGui = false;
                    toggle();
                }
            }
        }

        handleMovementKeys();
        if (!isActive) {
            if (modIsControllingSneak) {
                KeyBinding.setKeyBindState(mc.gameSettings.keyBindSneak.getKeyCode(), false);
                modIsControllingSneak = false;
            }
            return;
        }

        if (GhostConfig.AutoMine.sneakOnMine) {
            if (!mc.gameSettings.keyBindSneak.isKeyDown()) {
                KeyBinding.setKeyBindState(mc.gameSettings.keyBindSneak.getKeyCode(), true);
            }
            modIsControllingSneak = true;
        } else {
            if (modIsControllingSneak) {
                KeyBinding.setKeyBindState(mc.gameSettings.keyBindSneak.getKeyCode(), false);
                modIsControllingSneak = false;
            }
        }

        switch (currentState) {
            case SWITCHING_TARGET: handleSwitchingTarget(); break;
            case WAITING:
                waitTicks++;
                if (waitTicks >= 20) currentState = State.SWITCHING_TARGET;
                break;
            case MINING: handleMining(); break;
            case VALIDATING_BREAK: handleValidation(); break;
            case POST_SWITCH_DELAY: handlePostSwitchDelay(); break;
        }
    }

    private void handleSwitchingTarget() {
        if (currentStrategy != null) currentStrategy.onStopMining();
        miningStartTime = null;
        initialTargetState = null;

        BlockPos veinTarget = findVeinMineTarget();
        if (veinTarget != null) {
            currentTarget = veinTarget;
        } else {
            lastMinedState = null;
            currentTarget = findBestTarget();
        }

        if (currentTarget != null) {
            initialTargetState = mc.theWorld.getBlockState(currentTarget);
            if (currentStrategy != null) currentStrategy.onStartMining(currentTarget);
            currentState = State.MINING;
        } else {
            if (currentState != State.IDLE) {
                mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GRAY + LangUtil.translate("ghost.automine.status.waiting")));
                currentState = State.WAITING;
                waitTicks = 0;
            }
        }
    }

    private void handleMining() {
        if (currentTarget == null) {
            currentState = State.SWITCHING_TARGET;
            return;
        }
        
        IBlockState currentStateAtTarget = mc.theWorld.getBlockState(currentTarget);
        if (initialTargetState == null || currentStateAtTarget.getBlock() != initialTargetState.getBlock() || currentStateAtTarget.getBlock().getMetaFromState(currentStateAtTarget) != initialTargetState.getBlock().getMetaFromState(initialTargetState)) {
             currentState = State.SWITCHING_TARGET;
             return;
        }


        if (needsToolSwitch()) {
            if (handleToolSwitching()) {
                currentState = State.POST_SWITCH_DELAY;
                delayTicks = TOOL_SWITCH_DELAY_TICKS;
                if (currentStrategy != null) currentStrategy.onStopMining();
                return;
            } else {
                return;
            }
        }
        
        if (!isToolSufficientFor(currentTarget)) {
            unmineableBlacklist.put(currentTarget, currentStateAtTarget.getBlock());
            if (!currentTarget.equals(lastSkippedBlock)) {
                int requiredPower = isTitanium(currentStateAtTarget) ? 5 : 4;
                mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GOLD + String.format("[Ghost] Skipping %s, tool is too weak (BP %d < %d)",
                        currentStateAtTarget.getBlock().getLocalizedName(), getBreakingPower(mc.thePlayer.getCurrentEquippedItem()), requiredPower)));
                lastSkippedBlock = currentTarget;
            }
            currentState = State.SWITCHING_TARGET;
            return;
        }
        
        if (!mithrilOptimizationIsActive) {
            MovingObjectPosition mouseOver = mc.objectMouseOver;
            if (mouseOver != null && mouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
                BlockPos crosshairTargetPos = mouseOver.getBlockPos();
                
                if (!crosshairTargetPos.equals(currentTarget) && isTargetValid(crosshairTargetPos)) {
                    currentStrategy.onStopMining();
                    currentTarget = crosshairTargetPos;
                    initialTargetState = mc.theWorld.getBlockState(currentTarget);
                    currentStrategy.onStartMining(currentTarget);
                    miningStartTime = null;
                    return;
                }
            }
        }

        Block blockAtTarget = currentStateAtTarget.getBlock();
        if (blockAtTarget != Blocks.air) {
            lastMinedState = currentStateAtTarget;
        }

        if (checkTimeout(blockAtTarget)) {
            currentState = State.SWITCHING_TARGET;
            return;
        }
        
        MovingObjectPosition mouseOver = mc.objectMouseOver;
        Vec3 bestPointToLookAt = (mouseOver != null && mouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && mouseOver.getBlockPos().equals(currentTarget))
                ? mouseOver.hitVec : RotationUtil.getClosestVisiblePoint(currentTarget);

        if (bestPointToLookAt == null) {
            currentState = State.SWITCHING_TARGET;
            return;
        }

        if (currentStrategy != null) {
            currentStrategy.handleMiningTick(currentTarget, bestPointToLookAt);
        }
    }

    private void handleValidation() {
        if (blockToValidate == null) {
            currentState = State.SWITCHING_TARGET;
            return;
        }
        validationTicks++;
        if (validationTicks >= VALIDATION_DELAY_TICKS) {
            IBlockState state = mc.theWorld.getBlockState(blockToValidate);
            if (state.getBlock() == Blocks.air) {
                currentState = State.SWITCHING_TARGET;
            } else {
                handleRollbackDetected();
            }
            blockToValidate = null;
        }
    }
    
    private void handlePostSwitchDelay() {
        if (mc.gameSettings.keyBindAttack.isKeyDown()) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindAttack.getKeyCode(), false);
        }

        delayTicks--;
        if (delayTicks <= 0) {
            currentState = State.MINING;
        }
    }

    private void handleRollbackDetected() {
        unmineableBlacklist.put(blockToValidate, mc.theWorld.getBlockState(blockToValidate).getBlock());
        reset();
        awaitingRollbackConfirmation = true;

        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + "====================================================="));
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GOLD.toString() + EnumChatFormatting.BOLD + "      " + LangUtil.translate("ghost.automine.rollback.title")));
        mc.thePlayer.addChatMessage(new ChatComponentText(" "));
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + LangUtil.translate("ghost.automine.rollback.description")));
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + LangUtil.translate("ghost.automine.rollback.advice")));
        mc.thePlayer.addChatMessage(new ChatComponentText(" "));

        ChatComponentText optionsMessage = new ChatComponentText(EnumChatFormatting.WHITE + LangUtil.translate("ghost.automine.rollback.question"));
        
        IChatComponent continueButton = new ChatComponentText(" " + LangUtil.translate("ghost.automine.rollback.option.continue"))
                .setChatStyle(new ChatStyle().setColor(EnumChatFormatting.GREEN).setChatClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/automine automine_internal_feedback continue")));
        
        IChatComponent disableButton = new ChatComponentText(" " + LangUtil.translate("ghost.automine.rollback.option.disable"))
                .setChatStyle(new ChatStyle().setColor(EnumChatFormatting.GOLD).setChatClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/automine automine_internal_feedback disable")));
        
        IChatComponent stopButton = new ChatComponentText(" " + LangUtil.translate("ghost.automine.rollback.option.stop"))
                .setChatStyle(new ChatStyle().setColor(EnumChatFormatting.RED).setChatClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, "/automine automine_internal_feedback stop")));
        
        optionsMessage.appendSibling(continueButton)
                      .appendSibling(new ChatComponentText("  "))
                      .appendSibling(disableButton)
                      .appendSibling(new ChatComponentText("  "))
                      .appendSibling(stopButton);

        mc.thePlayer.addChatMessage(optionsMessage);
        mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + "====================================================="));
    }

    private boolean checkTimeout(Block blockAtTarget) {
        if (miningStartTime == null) {
            miningStartTime = System.currentTimeMillis();
            return false;
        }
        long mineTimeoutMs = GhostConfig.AutoMine.mineTimeoutSeconds * 1000L;
        if (System.currentTimeMillis() - miningStartTime > mineTimeoutMs) {
            unmineableBlacklist.put(currentTarget, blockAtTarget);
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + LangUtil.translate("ghost.automine.error.mining_timeout_blacklisted", blockAtTarget.getLocalizedName(), currentTarget.getX(), currentTarget.getY(), currentTarget.getZ())));
            return true;
        }
        return false;
    }

    private void handleMovementKeys() {
        if (!isActive || !GhostConfig.AutoMine.enableRandomMovements) {
            if (currentMoveKey != null) {
                KeyBinding.setKeyBindState(currentMoveKey.getKeyCode(), false);
                currentMoveKey = null;
            }
            randomMoveTicks = 0;
            currentMoveDuration = 0;
            return;
        }
        if (currentMoveDuration > 0) {
            currentMoveDuration--;
        } else {
            if (currentMoveKey != null) {
                KeyBinding.setKeyBindState(currentMoveKey.getKeyCode(), false);
                currentMoveKey = null;
            }
            if (randomMoveTicks > 0) {
                randomMoveTicks--;
            } else {
                int variability = GhostConfig.AutoMine.randomMoveIntervalVariability;
                int baseInterval = GhostConfig.AutoMine.randomMoveInterval;
                randomMoveTicks = baseInterval + ThreadLocalRandom.current().nextInt(-variability, variability + 1);
                randomMoveTicks = Math.max(10, randomMoveTicks);
                currentMoveDuration = GhostConfig.AutoMine.randomMoveDuration;
                KeyBinding[] moveKeys = {mc.gameSettings.keyBindForward, mc.gameSettings.keyBindBack, mc.gameSettings.keyBindLeft, mc.gameSettings.keyBindRight};
                currentMoveKey = moveKeys[ThreadLocalRandom.current().nextInt(moveKeys.length)];
                KeyBinding.setKeyBindState(currentMoveKey.getKeyCode(), true);
            }
        }
    }

    private BlockPos findVeinMineTarget() {
        if (!GhostConfig.AutoMine.enableVeinMining || currentTarget == null || lastMinedState == null || mc.theWorld.getBlockState(currentTarget).getBlock() != Blocks.air) return null;
        
        BlockPos lastPos = currentTarget;
        BlockPos bestNeighbor = null;
        double minScore = Double.MAX_VALUE;
        for (EnumFacing facing : EnumFacing.values()) {
            BlockPos neighborPos = lastPos.offset(facing);
            IBlockState neighborState = mc.theWorld.getBlockState(neighborPos);
            if (neighborState.equals(lastMinedState) && isTargetValid(neighborPos)) {
                double score = getAngleDifferenceToBlock(neighborPos);
                if (score < minScore) {
                    minScore = score;
                    bestNeighbor = neighborPos;
                }
            }
        }
        return bestNeighbor;
    }

    private BlockPos findBestTarget() {
        BlockPos blockToTemporarilyIgnore = null;
        // 优化点：当首次进入清理模式时，暂时忽略导致模式切换的那个方块
        if (mithrilOptimizationIsActive && !isCleanupMode) {
            Set<BlockPos> tempTitanium = new HashSet<>();
            findAndCategorizeMithrilAndTitanium(new HashSet<>(), tempTitanium);
            if (tempTitanium.size() >= GhostConfig.AutoMine.mithrilCleanupThreshold) {
                MovingObjectPosition mop = mc.objectMouseOver;
                if (mop != null && mop.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK) {
                    if(isTitanium(mc.theWorld.getBlockState(mop.getBlockPos()))){
                        blockToTemporarilyIgnore = mop.getBlockPos();
                    }
                }
            }
        }


        if (!mithrilOptimizationIsActive) {
            Set<BlockPos> allCandidates = new HashSet<>();
            findAndCategorizeMithrilAndTitanium(allCandidates, new HashSet<>());
            return findBestCandidate(allCandidates, null);
        }

        Set<BlockPos> mithrilCandidates = new HashSet<>();
        Set<BlockPos> titaniumCandidates = new HashSet<>();
        findAndCategorizeMithrilAndTitanium(mithrilCandidates, titaniumCandidates);

        boolean hasAbilityToMineTitanium;
        if (GhostConfig.AutoMine.enableAutomaticToolSwitching) {
            boolean hasBP5plus = findToolByBreakingPower(5, true) != -1;
            boolean hasBP4 = findToolByBreakingPower(4, false) != -1;
            hasAbilityToMineTitanium = hasBP5plus && hasBP4;
        } else {
            hasAbilityToMineTitanium = getBreakingPower(mc.thePlayer.getCurrentEquippedItem()) >= 5;
        }

        boolean shouldEnterCleanupMode = false;
        if (hasAbilityToMineTitanium && !titaniumCandidates.isEmpty()) {
            boolean cleanupThresholdMet = titaniumCandidates.size() >= GhostConfig.AutoMine.mithrilCleanupThreshold;
            boolean noMithrilLeft = mithrilCandidates.isEmpty();
            
            if (cleanupThresholdMet || (isCleanupMode && !titaniumCandidates.isEmpty()) || noMithrilLeft) {
                shouldEnterCleanupMode = true;
            }
        }

        if (shouldEnterCleanupMode) {
            if (!isCleanupMode) {
                isCleanupMode = true;
                mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GOLD + "[Ghost] " + LangUtil.translate("ghost.automine.status.cleanup_start")));
            }
            return findBestCandidate(titaniumCandidates, blockToTemporarilyIgnore);
        } else {
            if (isCleanupMode) {
                isCleanupMode = false;
                mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.GREEN + "[Ghost] " + LangUtil.translate("ghost.automine.status.cleanup_complete")));
            }
            
            if (mithrilCandidates.isEmpty() && !titaniumCandidates.isEmpty() && !hasAbilityToMineTitanium && !cleanupToolTooWeakNotified) {
                String warningMessage = "[Ghost] " + LangUtil.translate("ghost.automine.warning.tool_too_weak_for_cleanup");
                mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + warningMessage));
                cleanupToolTooWeakNotified = true;
            }
            
            return findBestCandidate(mithrilCandidates, null);
        }
    }

    private void findAndCategorizeMithrilAndTitanium(Set<BlockPos> primaryOut, Set<BlockPos> secondaryOut) {
        int radius = GhostConfig.AutoMine.searchRadius;
        BlockPos playerPos = mc.thePlayer.getPosition();
        
        for (BlockPos pos : BlockPos.getAllInBox(playerPos.add(-radius, -radius, -radius), playerPos.add(radius, radius, radius))) {
            if (!isTargetValid(pos)) continue;
            
            IBlockState state = mc.theWorld.getBlockState(pos);
            
            if (mithrilOptimizationIsActive && isTitanium(state)) {
                secondaryOut.add(new BlockPos(pos));
            } 
            else if (isBlockTypeTargeted(state)) {
                primaryOut.add(new BlockPos(pos));
            }
        }
    }

    private BlockPos findBestCandidate(Set<BlockPos> candidates, BlockPos blockToIgnore) {
        if (candidates == null || candidates.isEmpty()) return null;

        BlockPos bestPos = null;
        double minScore = Double.MAX_VALUE;

        // 如果候选列表在移除忽略方块后只剩下一个或没有，那么就没必要忽略了
        boolean canAffordToIgnore = candidates.size() > 1;

        for (BlockPos candidate : candidates) {
            // “瞬时回避”逻辑
            if (canAffordToIgnore && candidate.equals(blockToIgnore)) {
                continue; // 跳过这个方块
            }

            double angleDiff = getAngleDifferenceToBlock(candidate);
            double distanceSq = mc.thePlayer.getDistanceSq(candidate);
            Block candidateBlock = mc.theWorld.getBlockState(candidate).getBlock();
            int weight = AutoMineTargetManager.targetBlockWeights.getOrDefault(candidateBlock, DEFAULT_WEIGHT);
            double score = (angleDiff * 10.0 + distanceSq) / weight;
            if (score < minScore) {
                minScore = score;
                bestPos = candidate;
            }
        }
        
        // 如果因为忽略了方块导致没选到任何目标，那就退一步，把被忽略的方块选上
        if (bestPos == null && blockToIgnore != null && candidates.contains(blockToIgnore)) {
            return blockToIgnore;
        }

        return bestPos;
    }

    private boolean isBlockTypeTargeted(IBlockState state) {
        Block block = state.getBlock();
        int meta = block.getMetaFromState(state);
        AutoMineTargetManager.BlockData specificBlock = new AutoMineTargetManager.BlockData(block, meta);
        AutoMineTargetManager.BlockData wildcardBlock = new AutoMineTargetManager.BlockData(block, -1);
        return AutoMineTargetManager.targetBlockTypes.contains(specificBlock) || AutoMineTargetManager.targetBlockTypes.contains(wildcardBlock);
    }

    private double getAngleDifferenceToBlock(BlockPos pos) {
        Vec3 targetVec = new Vec3(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);
        float[] rotations = RotationUtil.getRotations(targetVec);
        EntityPlayerSP player = mc.thePlayer;
        float yawDiff = Math.abs(MathHelper.wrapAngleTo180_float(player.rotationYaw - rotations[0]));
        float pitchDiff = Math.abs(MathHelper.wrapAngleTo180_float(player.rotationPitch - rotations[1]));
        return yawDiff * yawDiff + pitchDiff * pitchDiff;
    }

    private boolean isTargetValid(BlockPos pos) {
        IBlockState state = mc.theWorld.getBlockState(pos);
        
        if (unmineableBlacklist.containsKey(pos)) {
            if (state.getBlock() != unmineableBlacklist.get(pos)) unmineableBlacklist.remove(pos);
            else return false;
        }
        if (GhostConfig.AutoMine.enableVoidSafetyCheck && pos.getY() < GhostConfig.AutoMine.voidSafetyYLimit) return false;
        if (state.getBlock() == Blocks.air) return false;
        if (GhostConfig.AutoMine.preventDiggingDown && pos.getY() < MathHelper.floor_double(mc.thePlayer.posY)) return false;
        if (state.getBlock().getBlockHardness(mc.theWorld, pos) < 0) {
            unmineableBlacklist.put(pos, state.getBlock());
            return false;
        }

        boolean isMithrilTarget = isBlockTypeTargeted(state);
        boolean isTitaniumTarget = mithrilOptimizationIsActive && isTitanium(state);

        if (!isMithrilTarget && !isTitaniumTarget) {
            return false;
        }

        double reach = GhostConfig.AutoMine.maxReachDistance;
        Vec3 blockCenter = new Vec3(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);
        if (mc.thePlayer.getPositionEyes(1.0f).squareDistanceTo(blockCenter) > reach * reach) return false;
        
        return RotationUtil.getClosestVisiblePoint(pos) != null;
    }

    private static void updateTitaniumBlockTypes() {
        titaniumBlockTypes.clear();
        for (String id : GhostConfig.AutoMine.titaniumBlockIds) {
            try {
                String blockName = id;
                int meta = -1;
                String[] parts = id.split(":");
                if (parts.length > 2) {
                    try {
                        meta = Integer.parseInt(parts[parts.length - 1]);
                        blockName = String.join(":", Arrays.copyOf(parts, parts.length - 1));
                    } catch (NumberFormatException e) {}
                }
                Block block = Block.getBlockFromName(blockName);
                if (block != null) titaniumBlockTypes.add(new AutoMineTargetManager.BlockData(block, meta));
            } catch (Exception e) {}
        }
    }

    private boolean isTitanium(IBlockState state) {
        Block block = state.getBlock();
        int meta = block.getMetaFromState(state);
        AutoMineTargetManager.BlockData specificBlock = new AutoMineTargetManager.BlockData(block, meta);
        AutoMineTargetManager.BlockData wildcardBlock = new AutoMineTargetManager.BlockData(block, -1);
        return titaniumBlockTypes.contains(specificBlock) || titaniumBlockTypes.contains(wildcardBlock);
    }
    
    private boolean isToolSufficientFor(BlockPos target) {
        if (!mithrilOptimizationIsActive) return true;
        IBlockState targetState = mc.theWorld.getBlockState(target);
        int requiredPower = isTitanium(targetState) ? 5 : 4;
        return getBreakingPower(mc.thePlayer.getCurrentEquippedItem()) >= requiredPower;
    }

    private boolean needsToolSwitch() {
        if (!mithrilOptimizationIsActive || !GhostConfig.AutoMine.enableAutomaticToolSwitching || currentTarget == null) return false;
        
        IBlockState targetState = mc.theWorld.getBlockState(currentTarget);
        boolean isTargetTitanium = isTitanium(targetState);
        int requiredPower = isTargetTitanium ? 5 : 4;
        
        int toolSlot = findToolByBreakingPower(requiredPower, isTargetTitanium);
        
        return toolSlot != -1 && mc.thePlayer.inventory.currentItem != toolSlot;
    }

    private boolean handleToolSwitching() {
        if (!GhostConfig.AutoMine.enableAutomaticToolSwitching) return true;
        
        IBlockState targetState = mc.theWorld.getBlockState(currentTarget);
        boolean isTargetTitanium = isTitanium(targetState);
        int requiredPower = isTargetTitanium ? 5 : 4;

        int toolSlot = findToolByBreakingPower(requiredPower, isTargetTitanium);
        
        if (toolSlot == -1) {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.RED + "[Ghost] " + LangUtil.translate("ghost.automine.error.no_tool_found", requiredPower)));
            reset();
            return false;
        }
        if (mc.thePlayer.inventory.currentItem != toolSlot) {
            if (originalSlot == -1) originalSlot = mc.thePlayer.inventory.currentItem;
            mc.thePlayer.inventory.currentItem = toolSlot;
        }
        return true;
    }

    private static int getBreakingPower(ItemStack stack) {
        if (stack == null || stack.getTagCompound() == null) return 0;
        NBTTagCompound display = stack.getTagCompound().getCompoundTag("display");
        if (display.hasKey("Lore", Constants.NBT.TAG_LIST)) {
            NBTTagList lore = display.getTagList("Lore", Constants.NBT.TAG_STRING);
            for (int j = 0; j < lore.tagCount(); j++) {
                String colorlessLine = EnumChatFormatting.getTextWithoutFormattingCodes(lore.getStringTagAt(j));
                Matcher matcher = BREAKING_POWER_PATTERN.matcher(colorlessLine);
                if (matcher.find()) {
                    try { return Integer.parseInt(matcher.group(1)); } 
                    catch (NumberFormatException ignored) {}
                }
            }
        }
        return 0;
    }

    private static int findToolByBreakingPower(int requiredPower, boolean findStrongest) {
        int bestSlot = -1;
        int bestPower = findStrongest ? -1 : Integer.MAX_VALUE;

        for (int i = 0; i < 9; i++) {
            ItemStack stack = mc.thePlayer.inventory.mainInventory[i];
            if (stack == null) continue;
            
            int power = getBreakingPower(stack);
            
            if (power >= requiredPower) {
                if (findStrongest) {
                    if (power > bestPower) {
                        bestPower = power;
                        bestSlot = i;
                    }
                } else {
                    if (power < bestPower) {
                        bestPower = power;
                        bestSlot = i;
                    }
                }
            }
        }
        return bestSlot;
    }

    private static void validateAndActivateMithrilOptimization() {
        mithrilOptimizationIsActive = false;
        if (!GhostConfig.AutoMine.enableMithrilOptimization) return;
        boolean hasMithrilInTargets = false;
        for (AutoMineTargetManager.BlockData target : AutoMineTargetManager.targetBlockTypes) {
            for (String mithrilId : MITHRIL_ORE_IDS) {
                if (target.toString().equals(mithrilId)) {
                    hasMithrilInTargets = true;
                    break;
                }
            }
            if (hasMithrilInTargets) break;
        }
        if (!hasMithrilInTargets) {
            mc.thePlayer.addChatMessage(new ChatComponentText(EnumChatFormatting.YELLOW + "[Ghost] " + LangUtil.translate("ghost.automine.warning.no_mithril_targets")));
            return;
        }
        mithrilOptimizationIsActive = true;
        updateTitaniumBlockTypes();
    }
}

features/automine/PredefinedGroupManager.java:
package com.zihaomc.ghost.features.automine;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 管理预定义的、硬编码的矿物组。
 */
public class PredefinedGroupManager {

    private static final Map<String, List<String>> PREDEFINED_GROUPS = new HashMap<>();

    static {
        // 初始化所有预定义的组
        PREDEFINED_GROUPS.put("skyblock:mithril", Arrays.asList(
            "minecraft:wool:7",
            "minecraft:prismarine",
            "minecraft:wool:11",
            "minecraft:stained_hardened_clay:9"
        ));
        PREDEFINED_GROUPS.put("skyblock:titanium", Arrays.asList(
            "minecraft:stone:4"
        ));
    }

    /**
     * 将所有预定义的组加载到用户的自定义组列表中（如果不存在）。
     * 这通常在首次启动或配置文件为空时调用。
     */
    public static void initializePredefinedGroups() {
        for (Map.Entry<String, List<String>> entry : PREDEFINED_GROUPS.entrySet()) {
            // putIfAbsent 确保我们不会覆盖用户可能已经修改或删除的同名组
            AutoMineTargetManager.customBlockGroups.putIfAbsent(entry.getKey(), entry.getValue());
        }
        AutoMineTargetManager.saveBlockGroups();
    }
    
    /**
     * 获取一个预定义组的组件列表。
     * @param groupName 组名
     * @return 组件列表，如果不存在则返回 null。
     */
    public static List<String> getGroup(String groupName) {
        return PREDEFINED_GROUPS.get(groupName.toLowerCase());
    }
}

features/automine/AutoMineCommand.java:
package com.zihaomc.ghost.features.automine;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.features.automine.AutoMineHandler;
import com.zihaomc.ghost.features.automine.AutoMineTargetManager;
import net.minecraft.block.Block;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.event.HoverEvent;
import net.minecraft.item.ItemStack;
import net.minecraft.util.BlockPos;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatStyle;
import net.minecraft.util.EnumChatFormatting;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * /automine 命令的实现类 (重构优化版)。
 * 修正了包名以匹配文件路径。
 */
public class AutoMineCommand extends CommandBase {

    @Override
    public String getCommandName() {
        return "automine";
    }

    @Override
    public String getCommandUsage(ICommandSender sender) {
        return LangUtil.translate("ghost.automine.command.usage");
    }

    @Override
    public int getRequiredPermissionLevel() {
        return 0;
    }

    @Override
    public void processCommand(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 1 || "help".equalsIgnoreCase(args[0])) {
            handleHelp(sender);
            return;
        }

        String subCommand = args[0].toLowerCase();

        switch (subCommand) {
            case "add":
                handleAdd(sender, args);
                break;
            case "remove":
                handleRemove(sender, args);
                break;
            case "list":
                handleList(sender);
                break;
            case "clear":
                handleClear(sender, args);
                break;
            case "weight":
                handleWeight(sender, args);
                break;
            case "group":
                handleGroup(sender, args);
                break;
            case "mode":
                handleMode(sender, args);
                break;
            case "toggle":
            case "start":
            case "stop":
                AutoMineHandler.toggle();
                break;
            // 新增一个隐藏的内部命令，用于处理回弹确认
            case "automine_internal_feedback":
                if (args.length > 1) {
                    AutoMineHandler.onRollbackFeedback(args[1]);
                }
                break;
            default:
                throw new WrongUsageException(getCommandUsage(sender));
        }
    }

    private void handleAdd(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 2) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.add"));
        
        String addType = args[1].toLowerCase();
        switch (addType) {
            case "coord":
                if (args.length < 5) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.add.coord"));
                BlockPos pos = parseBlockPos(sender, args, 2, false);
                AutoMineTargetManager.getCurrentTargetBlocks().add(pos);
                AutoMineTargetManager.saveCoordinates();
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.add.coord.success", pos.getX(), pos.getY(), pos.getZ())));
                break;
            case "block":
                if (args.length < 3) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.add.block"));
                AutoMineTargetManager.BlockData blockData = parseBlockData(sender, args[2]);
                if (AutoMineTargetManager.targetBlockTypes.add(blockData)) {
                    AutoMineTargetManager.saveBlockTypes();
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.add.block.success", getBlockDisplayName(blockData))));
                } else {
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.add.block.already_exists", blockData.toString())));
                }
                break;
            case "group":
                if (args.length < 3) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.add.group"));
                String groupName = args[2].toLowerCase();
                List<AutoMineTargetManager.BlockData> components = getComponentsForGroup(sender, groupName);
                if (components.isEmpty()) throw new CommandException(LangUtil.translate("ghost.automine.command.group.not_found", groupName));

                int addedCount = 0;
                for (AutoMineTargetManager.BlockData component : components) {
                    if (AutoMineTargetManager.targetBlockTypes.add(component)) addedCount++;
                }
                
                if (addedCount > 0) {
                    AutoMineTargetManager.saveBlockTypes();
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.add.group.success", groupName, addedCount)));
                } else {
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.add.group.already_exists", groupName)));
                }
                break;
            default:
                throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.add"));
        }
    }

    private void handleRemove(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 2) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.remove"));

        String removeType = args[1].toLowerCase();
        switch (removeType) {
            case "coord":
                if (args.length < 3) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.remove.coord"));
                List<BlockPos> currentTargets = AutoMineTargetManager.getCurrentTargetBlocks();
                int indexToRemove = parseInt(args[2], 1) - 1;
                if (indexToRemove >= 0 && indexToRemove < currentTargets.size()) {
                    BlockPos removed = currentTargets.remove(indexToRemove);
                    AutoMineTargetManager.saveCoordinates();
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.remove.coord.success", removed.getX(), removed.getY(), removed.getZ())));
                } else {
                    throw new CommandException(LangUtil.translate("ghost.automine.command.remove.coord.error", currentTargets.size()));
                }
                break;
            case "block":
                if (args.length < 3) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.remove.block"));
                AutoMineTargetManager.BlockData blockData = parseBlockData(sender, args[2]);
                if (AutoMineTargetManager.targetBlockTypes.remove(blockData)) {
                    AutoMineTargetManager.saveBlockTypes();
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.remove.block.success", blockData.toString())));
                } else {
                    throw new CommandException(LangUtil.translate("ghost.automine.command.remove.block.not_found", blockData.toString()));
                }
                break;
            case "group":
                if (args.length < 3) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.remove.group"));
                String groupName = args[2].toLowerCase();
                List<AutoMineTargetManager.BlockData> components = getComponentsForGroup(sender, groupName);
                if (components.isEmpty()) throw new CommandException(LangUtil.translate("ghost.automine.command.group.not_found", groupName));

                int removedCount = 0;
                for (AutoMineTargetManager.BlockData component : components) {
                    if (AutoMineTargetManager.targetBlockTypes.remove(component)) removedCount++;
                }

                if (removedCount > 0) {
                    AutoMineTargetManager.saveBlockTypes();
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.remove.group.success", groupName, removedCount)));
                } else {
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.remove.group.none_found", groupName)));
                }
                break;
            default:
                throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.remove"));
        }
    }
    
    private void handleMode(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 2) {
            String currentModeName = AutoMineHandler.getMiningMode().name();
            sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.mode.current", currentModeName)));
            return;
        }

        String modeName = args[1].toUpperCase();
        try {
            AutoMineHandler.MiningMode newMode = AutoMineHandler.MiningMode.valueOf(modeName);
            AutoMineHandler.setMiningMode(newMode);
        } catch (IllegalArgumentException e) {
            throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.mode"));
        }
    }

    private void handleClear(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 2) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.clear"));
        
        String clearType = args[1].toLowerCase();
        switch (clearType) {
            case "coords":
                AutoMineTargetManager.getCurrentTargetBlocks().clear();
                AutoMineTargetManager.saveCoordinates();
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.clear.coords.success")));
                break;
            case "blocks":
                AutoMineTargetManager.targetBlockTypes.clear();
                AutoMineTargetManager.saveBlockTypes();
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.clear.blocks.success")));
                break;
            case "weights":
                AutoMineTargetManager.targetBlockWeights.clear();
                AutoMineTargetManager.saveBlockWeights();
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.clear.weights.success")));
                break;
            case "blacklist":
                AutoMineHandler.clearBlacklist();
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.clear.blacklist.success")));
                break;
            default:
                throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.clear"));
        }

        if (AutoMineTargetManager.getCurrentTargetBlocks().isEmpty() && AutoMineTargetManager.targetBlockTypes.isEmpty() && AutoMineHandler.isActive()) {
            AutoMineHandler.toggle();
        }
    }

    private void handleWeight(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 2) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.weight"));
        
        String action = args[1].toLowerCase();
        switch (action) {
            case "set":
                if (args.length < 4) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.weight.set"));
                Block block = getBlockByText(sender, args[2]);
                int weight = parseInt(args[3], 1);
                if (weight <= 0) throw new CommandException(LangUtil.translate("ghost.automine.command.weight.error.positive"));
                AutoMineTargetManager.targetBlockWeights.put(block, weight);
                AutoMineTargetManager.saveBlockWeights();
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.weight.set.success", block.getLocalizedName(), weight)));
                break;
            case "clear":
                if (args.length < 3) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.weight.clear_one"));
                Block blockToClear = getBlockByText(sender, args[2]);
                if (AutoMineTargetManager.targetBlockWeights.remove(blockToClear) != null) {
                    AutoMineTargetManager.saveBlockWeights();
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.weight.clear.success", blockToClear.getLocalizedName())));
                } else {
                    throw new CommandException(LangUtil.translate("ghost.automine.command.weight.clear.not_found", blockToClear.getLocalizedName()));
                }
                break;
            default:
                throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.weight"));
        }
    }
    
    private void handleGroup(ICommandSender sender, String[] args) throws CommandException {
        if (args.length < 2) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.group"));
        
        String action = args[1].toLowerCase();
        switch (action) {
            case "create":
                if (args.length < 4) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.group.create"));
                String groupName = args[2].toLowerCase();
                List<String> components = new ArrayList<>(Arrays.asList(args).subList(3, args.length));
                for (String comp : components) parseBlockData(sender, comp); 
                AutoMineTargetManager.customBlockGroups.put(groupName, components);
                AutoMineTargetManager.saveBlockGroups();
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.group.create.success", groupName, components.size())));
                break;
            case "delete":
                if (args.length < 3) throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.group.delete"));
                String groupToRemove = args[2].toLowerCase();
                if (AutoMineTargetManager.customBlockGroups.remove(groupToRemove) != null) {
                    AutoMineTargetManager.saveBlockGroups();
                    sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.group.delete.success", groupToRemove)));
                } else {
                    throw new CommandException(LangUtil.translate("ghost.automine.command.group.not_found", groupToRemove));
                }
                break;
            default:
                throw new WrongUsageException(LangUtil.translate("ghost.automine.command.usage.group"));
        }
    }

    private void handleList(ICommandSender sender) {
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.header_main")));
        
        List<BlockPos> currentTargets = AutoMineTargetManager.getCurrentTargetBlocks();

        boolean hasCoords = !currentTargets.isEmpty();
        boolean hasBlocks = !AutoMineTargetManager.targetBlockTypes.isEmpty();
        boolean hasWeights = !AutoMineTargetManager.targetBlockWeights.isEmpty();
        boolean hasGroups = !AutoMineTargetManager.customBlockGroups.isEmpty();

        if (!hasCoords && !hasBlocks && !hasGroups) {
            sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.none")));
            return;
        }

        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.header_coords")));
        if (hasCoords) {
            for (int i = 0; i < currentTargets.size(); i++) {
                BlockPos p = currentTargets.get(i);
                sender.addChatMessage(new ChatComponentText(String.format("§e%d. §f(%d, %d, %d)", i + 1, p.getX(), p.getY(), p.getZ())));
            }
        } else {
            sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.empty_coords")));
        }
        sender.addChatMessage(new ChatComponentText(" "));

        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.header_blocks")));
        if (hasBlocks) {
            for (AutoMineTargetManager.BlockData blockData : AutoMineTargetManager.targetBlockTypes) {
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.block_entry", getBlockDisplayName(blockData), blockData.toString())));
            }
        } else {
            sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.empty_blocks")));
        }
        sender.addChatMessage(new ChatComponentText(" "));

        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.header_groups")));
        if (hasGroups) {
            for (String groupName : AutoMineTargetManager.customBlockGroups.keySet()) {
                List<AutoMineTargetManager.BlockData> components = getComponentsForGroup(sender, groupName);
                boolean isEnabled = !components.isEmpty() && AutoMineTargetManager.targetBlockTypes.containsAll(components);
                sender.addChatMessage(createGroupComponent(groupName, components, isEnabled));
            }
        } else {
            sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.empty_groups")));
        }
        sender.addChatMessage(new ChatComponentText(" "));

        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.header_weights")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.weights_default_hint")));
        if(hasWeights) {
            for (Map.Entry<Block, Integer> entry : AutoMineTargetManager.targetBlockWeights.entrySet()) {
                sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.weight_entry", entry.getKey().getLocalizedName(), entry.getKey().getRegistryName(), entry.getValue())));
            }
        } else {
            sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.list.empty_weights")));
        }
    }

    private void handleHelp(ICommandSender sender) {
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.header")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.description")));
        sender.addChatMessage(new ChatComponentText(" "));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommands.header")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.toggle")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.mode")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.list")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.add")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.remove")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.clear")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.weight")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.subcommand.group")));
        sender.addChatMessage(new ChatComponentText(" "));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.header")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.add_coord")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.add_block")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.add_group")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.set_mode")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.remove_coord")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.create_group")));
        sender.addChatMessage(new ChatComponentText(LangUtil.translate("ghost.automine.command.help.examples.set_weight")));
    }

    @Override
    public List<String> addTabCompletionOptions(ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length > 0 && "automine_internal_feedback".equalsIgnoreCase(args[0])) {
            return Collections.emptyList();
        }
        
        if (args.length == 1) {
            return getListOfStringsMatchingLastWord(args, "add", "remove", "list", "clear", "toggle", "weight", "group", "mode", "help");
        }
        if (args.length == 2) {
            String subCmd = args[0].toLowerCase();
            switch (subCmd) {
                case "add":
                case "remove":
                    return getListOfStringsMatchingLastWord(args, "coord", "block", "group");
                case "clear":
                    return getListOfStringsMatchingLastWord(args, "coords", "blocks", "weights", "blacklist");
                case "weight":
                    return getListOfStringsMatchingLastWord(args, "set", "clear");
                case "group":
                    return getListOfStringsMatchingLastWord(args, "create", "delete");
                case "mode":
                    return getListOfStringsMatchingLastWord(args, Arrays.stream(AutoMineHandler.MiningMode.values()).map(Enum::name).collect(Collectors.toList()));
            }
        }
        if (args.length > 2) {
            String subCmd = args[0].toLowerCase();
            String type = args[1].toLowerCase();
            switch (subCmd) {
                case "add":
                    if ("coord".equals(type) && args.length <= 5) return func_175771_a(args, 2, pos);
                    if ("block".equals(type) && args.length == 3) return getListOfStringsMatchingLastWord(args, Block.blockRegistry.getKeys());
                    if ("group".equals(type) && args.length == 3) return getListOfStringsMatchingLastWord(args, AutoMineTargetManager.customBlockGroups.keySet());
                    break;
                case "remove":
                    if ("coord".equals(type) && args.length == 3) {
                        List<String> indices = new ArrayList<>();
                        for (int i = 1; i <= AutoMineTargetManager.getCurrentTargetBlocks().size(); i++) indices.add(String.valueOf(i));
                        return getListOfStringsMatchingLastWord(args, indices);
                    }
                    if ("block".equals(type) && args.length == 3) {
                        List<String> addedBlockIds = AutoMineTargetManager.targetBlockTypes.stream().map(AutoMineTargetManager.BlockData::toString).collect(Collectors.toList());
                        return getListOfStringsMatchingLastWord(args, addedBlockIds);
                    }
                    if ("group".equals(type) && args.length == 3) return getListOfStringsMatchingLastWord(args, AutoMineTargetManager.customBlockGroups.keySet());
                    break;
                case "weight":
                    if (("set".equals(type) || "clear".equals(type)) && args.length == 3) return getListOfStringsMatchingLastWord(args, Block.blockRegistry.getKeys());
                    if ("set".equals(type) && args.length == 4) return getListOfStringsMatchingLastWord(args, "10", "50", "100");
                    break;
                case "group":
                    if ("delete".equals(type) && args.length == 3) return getListOfStringsMatchingLastWord(args, AutoMineTargetManager.customBlockGroups.keySet());
                    if ("create".equals(type) && args.length >= 4) return getListOfStringsMatchingLastWord(args, Block.blockRegistry.getKeys());
                    break;
            }
        }
        return Collections.emptyList();
    }
    
    private AutoMineTargetManager.BlockData parseBlockData(ICommandSender sender, String input) throws CommandException {
        String blockIdString = input;
        int meta = -1; 
        int lastColonIndex = input.lastIndexOf(':');
        if (lastColonIndex > 0 && lastColonIndex > input.indexOf(':')) {
            String potentialMeta = input.substring(lastColonIndex + 1);
            try {
                meta = Integer.parseInt(potentialMeta);
                blockIdString = input.substring(0, lastColonIndex);
            } catch (NumberFormatException e) {
            }
        }
        
        try {
            Block block = getBlockByText(sender, blockIdString);
            return new AutoMineTargetManager.BlockData(block, meta);
        } catch (CommandException e) {
            throw new CommandException("commands.generic.block.notFound", input);
        }
    }

    private String getBlockDisplayName(AutoMineTargetManager.BlockData blockData) {
        try {
            if (blockData.metadata == -1) return blockData.block.getLocalizedName();
            return new ItemStack(blockData.block, 1, blockData.metadata).getDisplayName();
        } catch (Exception e) {
            return blockData.toString();
        }
    }

    private List<AutoMineTargetManager.BlockData> getComponentsForGroup(ICommandSender sender, String groupName) {
        List<String> componentIds = AutoMineTargetManager.customBlockGroups.get(groupName.toLowerCase());
        if (componentIds == null) return new ArrayList<>();
        return componentIds.stream().map(id -> {
            try { return parseBlockData(sender, id); } catch (CommandException e) { return null; }
        }).filter(java.util.Objects::nonNull).collect(Collectors.toList());
    }

    private ChatComponentText createGroupComponent(String groupName, List<AutoMineTargetManager.BlockData> components, boolean isEnabled) {
        String hoverText = LangUtil.translate("ghost.automine.command.list.group_hover_tooltip", 
            components.stream().map(this::getBlockDisplayName).collect(Collectors.joining(", ")));
        
        String status = isEnabled ? LangUtil.translate("ghost.generic.enabled") : LangUtil.translate("ghost.generic.disabled");
        
        ChatComponentText textComponent = new ChatComponentText("§f- " + groupName + " [" + status + "§f]");
        textComponent.getChatStyle().setChatHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ChatComponentText(hoverText)));
        return textComponent;
    }
}

features/automine/PacketInstantMiningStrategy.java:
package com.zihaomc.ghost.features.automine;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.utils.RotationUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.network.play.client.C07PacketPlayerDigging;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.Vec3;

/**
 * 使用数据包瞬间破坏方块的策略。
 * 它会在同一个tick内发送开始和停止挖掘的数据包。
 */
public class PacketInstantMiningStrategy implements IMiningStrategy {

    private final Minecraft mc = Minecraft.getMinecraft();

    @Override
    public void onStartMining(BlockPos target) {
        // 此模式无内部状态需要重置
    }

    @Override
    public void onStopMining() {
        // 此模式下无需特殊清理
    }

    @Override
    public void handleMiningTick(BlockPos target, Vec3 bestPointToLookAt) {
        // 瞬发模式总是强制瞬间旋转
        float[] targetRots = RotationUtil.getRotations(bestPointToLookAt);
        mc.thePlayer.rotationYaw = targetRots[0];
        mc.thePlayer.rotationPitch = targetRots[1];

        // 手动进行射线追踪，不依赖 mc.objectMouseOver
        MovingObjectPosition mop = mc.thePlayer.rayTrace(GhostConfig.AutoMine.maxReachDistance, 1.0F);

        // 如果射线成功命中目标方块
        if (mop != null && mop.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && mop.getBlockPos().equals(target)) {
            EnumFacing facing = mop.sideHit;
            // 连续发送开始、挥手、停止数据包
            mc.getNetHandler().addToSendQueue(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.START_DESTROY_BLOCK, target, facing));
            mc.thePlayer.swingItem();
            mc.getNetHandler().addToSendQueue(new C07PacketPlayerDigging(C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK, target, facing));
            // 触发反作弊回弹检测
            AutoMineHandler.startValidation(target);
        }
        // 如果没对准，就在下一tick再次尝试
    }

    @Override
    public String getModeName() {
        return "PACKET_INSTANT";
    }
}

features/autosneak/AutoSneakHandler.java:
package com.zihaomc.ghost.features.autosneak;

import com.zihaomc.ghost.config.GhostConfig;
// import com.zihaomc.ghost.utils.LogUtil; // 如果需要调试，取消此行注释
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;
import net.minecraft.util.Vec3;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.lwjgl.input.Keyboard; // 导入LWJGL的Keyboard类

public class AutoSneakHandler {

    private boolean modIsControllingSneakKey = false; // Mod当前是否正在通过 setKeyBindState *控制* 蹲下键的状态
    private final Minecraft mc = Minecraft.getMinecraft();

    @SubscribeEvent
    public void onClientTick(TickEvent.ClientTickEvent event) {
        if (event.phase != TickEvent.Phase.END) {
            return;
        }

        EntityPlayerSP player = mc.thePlayer;
        World world = mc.theWorld;

        if (player == null || world == null) {
            if (modIsControllingSneakKey) {
                releaseSneakKeyByMod(); // 确保在退出世界或玩家消失时释放
            }
            return;
        }

        if (!GhostConfig.AutoSneak.enableAutoSneakAtEdge) {
            if (modIsControllingSneakKey) {
                releaseSneakKeyByMod(); // 如果功能被禁用，释放由 Mod 触发的蹲下
            }
            return;
        }

        // 玩家是否满足执行自动蹲伏逻辑的前提条件
        boolean canPlayerAutoSneak = player.onGround &&
                                   !player.capabilities.isFlying &&
                                   !mc.gameSettings.keyBindJump.isKeyDown() && // 检查游戏内跳跃键是否激活
                                   !player.isInWater() &&
                                   !player.isInLava();

        // Mod 是否认为玩家应该蹲下
        boolean modWantsPlayerToSneak = false;
        if (canPlayerAutoSneak) {
            modWantsPlayerToSneak = checkIsPlayerAtEdge(player, world);
        }

        // 玩家是否真实地、物理地按下了潜行键
        boolean isPhysicalSneakKeyPressedByPlayer = false;
        int sneakKeyCode = mc.gameSettings.keyBindSneak.getKeyCode();
        if (sneakKeyCode > 0 && sneakKeyCode < Keyboard.KEYBOARD_SIZE) { // 确保keyCode有效且在Keyboard数组范围内
            isPhysicalSneakKeyPressedByPlayer = Keyboard.isKeyDown(sneakKeyCode);
        }


        // --- 核心决策逻辑 ---
        if (modWantsPlayerToSneak) {
            // Mod希望玩家蹲下
            if (!player.isSneaking()) { // 如果玩家当前没有实际蹲下
                if (!isPhysicalSneakKeyPressedByPlayer) { // 并且玩家没有手动按住物理潜行键
                    pressSneakKeyByMod(); // Mod按下蹲下键
                }
                // else: 玩家手动按着物理潜行键，Mod不干预 (即使他还没实际蹲下，比如按键刚按下)
            } else { // 玩家已经在蹲下了
                // 如果玩家在蹲下，但既不是因为手动按住物理键，也不是Mod之前控制的
                // (例如：玩家手动按了键，开始蹲伏，然后松开了物理键，但mod仍然希望他蹲伏)
                // Mod此时应该“接管”控制权，以便之后能正确释放
                if (!isPhysicalSneakKeyPressedByPlayer && !modIsControllingSneakKey) {
                    modIsControllingSneakKey = true;
                }
                // else: 玩家手动按着物理键蹲下，或者Mod之前按了键导致蹲下且仍在控制，则保持现状
            }
        } else {
            // Mod不希望玩家蹲下 (不在边缘或不满足前提条件)
            if (modIsControllingSneakKey) { // 只有当蹲下状态之前是由Mod触发或“接管”时
                if (!isPhysicalSneakKeyPressedByPlayer) { // 并且玩家当前没有手动按住物理潜行键
                    releaseSneakKeyByMod(); // Mod松开蹲下键，玩家将站起
                } else {
                    // 玩家手动按住了物理潜行键。Mod虽然不希望自动蹲下，但由于玩家的手动操作，Mod应放弃控制权。
                    // 蹲下状态会因为玩家的手动操作而继续。
                    modIsControllingSneakKey = false;
                }
            }
            // else: Mod之前没有控制蹲下。如果玩家手动蹲下，他们会继续直到松开。Mod不干预。
        }
    }

    // 使用你提供的 checkIsPlayerAtEdge 方法结构，并稍作调整以提高稳健性
    private boolean checkIsPlayerAtEdge(EntityPlayerSP player, World world) {
        double playerFeetY = player.getEntityBoundingBox().minY;
        float yaw = player.rotationYaw;
        float moveForward = player.moveForward; // 这些值由Minecraft更新，反映玩家的移动组件
        float moveStrafe = player.moveStrafing;
        Vec3 moveDirection;

        double forwardOffset = GhostConfig.AutoSneak.autoSneakForwardOffset;
        double verticalCheckDepth = GhostConfig.AutoSneak.autoSneakVerticalCheckDepth;

        // 判断是基于玩家的移动意图还是朝向
        if (Math.abs(moveForward) > 0.001f || Math.abs(moveStrafe) > 0.001f) {
            // 根据移动的forward和strafe分量，以及玩家的yaw，计算世界坐标系下的移动方向向量
            float strafeComp = moveStrafe, forwardComp = moveForward;
            float sinYaw = MathHelper.sin(yaw * (float)Math.PI / 180.0F);
            float cosYaw = MathHelper.cos(yaw * (float)Math.PI / 180.0F);
            double motionX = (double)(strafeComp * cosYaw - forwardComp * sinYaw);
            double motionZ = (double)(forwardComp * cosYaw + strafeComp * sinYaw);
            
            // 使用平方长度避免开方，判断计算出的移动向量是否足够大
            double lengthSq = motionX * motionX + motionZ * motionZ;
            if (lengthSq >= 1.0E-8D) { // 1E-4 * 1E-4 = 1E-8. 一个较小的阈值
                double length = MathHelper.sqrt_double(lengthSq);
                moveDirection = new Vec3(motionX / length, 0, motionZ / length);
            } else {
                // 移动分量产生的合向量太小，使用玩家的视线方向 (仅考虑水平分量)
                Vec3 lookVec = player.getLookVec();
                moveDirection = new Vec3(lookVec.xCoord, 0, lookVec.zCoord).normalize();
            }
        } else {
            // 玩家没有明显的移动输入 (moveForward 和 moveStrafe 都很小)，使用玩家的视线方向
            Vec3 lookVec = player.getLookVec();
            moveDirection = new Vec3(lookVec.xCoord, 0, lookVec.zCoord).normalize();
        }

        // 检查最终计算出的moveDirection是否有效
        // Vec3.normalize() 对于零向量可能会返回 (NaN, NaN, NaN) 或 (0,0,0)
        // 如果长度非常小，意味着没有明确的水平方向去检测边缘。
        if (moveDirection.lengthVector() < 1.0E-4D) {
            return false; // 无效或不明确的检测方向
        }
        // 如果之前的normalize()可能因为输入是(0,0,0)而没有正确归一化，这里可以再次normalize。
        // 但通常情况下，如果lengthVector() > 0，它已经被归一化了。
        // moveDirection = moveDirection.normalize(); // 通常不需要重复，上面的逻辑已确保向量有效或已归一化

        double checkX = player.posX + moveDirection.xCoord * forwardOffset;
        double checkZ = player.posZ + moveDirection.zCoord * forwardOffset;
        // 从玩家脚底实体边界框的minY再往下一点点开始检测，避免检测到玩家当前站立的方块自身
        BlockPos posToTestBelow = new BlockPos(checkX, playerFeetY - 0.01, checkZ);

        for (int i = 0; i < MathHelper.ceiling_double_int(verticalCheckDepth); i++) {
            BlockPos currentTestPos = posToTestBelow.down(i);
            if (!world.isAirBlock(currentTestPos)) { // 如果不是空气方块
                return false; // 找到了非空气方块，说明下方有支撑，不在边缘
            }
        }
        // 在检测深度内全是空气，说明在边缘
        return true;
    }

    /**
     * 由Mod按下蹲下键。
     */
    private void pressSneakKeyByMod() {
        // 只有当键的逻辑状态当前不是按下时，才通过程序设置它为按下
        // 这样可以避免不必要的 KeyBinding.setKeyBindState 调用，尽管重复调用通常无害
        if (!mc.gameSettings.keyBindSneak.isKeyDown()) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindSneak.getKeyCode(), true);
        }
        modIsControllingSneakKey = true;
        // LogUtil.debug("log.debug.autosneak.press");
    }

    /**
     * 由Mod释放蹲下键。
     */
    private void releaseSneakKeyByMod() {
        // 只有当键的逻辑状态当前是按下时，才通过程序设置它为释放
        if (mc.gameSettings.keyBindSneak.isKeyDown()) {
            KeyBinding.setKeyBindState(mc.gameSettings.keyBindSneak.getKeyCode(), false);
        }
        modIsControllingSneakKey = false;
        // LogUtil.debug("log.debug.autosneak.release");
    }
}

features/playeresp/PlayerESPHandler.java:
package com.zihaomc.ghost.features.playeresp;

import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.client.event.RenderLivingEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import org.lwjgl.opengl.GL11;

public class PlayerESPHandler {

    private final Minecraft mc = Minecraft.getMinecraft();

    @SubscribeEvent
    public void onRenderPlayerPre(RenderLivingEvent.Pre<EntityPlayer> event) {
        if (!GhostConfig.PlayerESP.enablePlayerESP || !(event.entity instanceof EntityPlayer) || event.entity == mc.thePlayer) {
            return;
        }

        GlStateManager.pushMatrix();

        // 核心：使用多边形偏移来解决深度冲突 (Z-Fighting)
        // 开启这个功能
        GlStateManager.enablePolygonOffset();
        // 设置偏移量。-1.0, -1000000.0 是常用值，将ESP的渲染“拉”到更靠近摄像机的位置，
        // 使其在深度测试中优先通过，从而覆盖掉墙壁等物体。
        // factor: -1.0, units: -1000000.0
        GlStateManager.doPolygonOffset(-1.0F, -1000000.0F);

        // 我们不禁用深度测试，让它正常工作，只是通过偏移来“欺骗”它
        // 这样可以保留正确的模型内部遮挡关系
    }

    @SubscribeEvent
    public void onRenderPlayerPost(RenderLivingEvent.Post<EntityPlayer> event) {
        if (!GhostConfig.PlayerESP.enablePlayerESP || !(event.entity instanceof EntityPlayer) || event.entity == mc.thePlayer) {
            return;
        }
        
        // 恢复多边形偏移
        // factor: 1.0, units: 1000000.0 (恢复到正值或0,0)
        GlStateManager.doPolygonOffset(1.0F, 1000000.0F);
        GlStateManager.disablePolygonOffset();

        GlStateManager.popMatrix();
    }
}

features/note/NoteInputHandler.java:
package com.zihaomc.ghost.features.note;

import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.client.gui.GuiScreen;
import org.lwjgl.input.Keyboard;

import java.io.IOException;

/**
 * 负责处理笔记GUI中的所有用户输入（键盘和鼠标）。
 * - 支持 Tab 键缩进。
 */
public class NoteInputHandler {
    
    private final GuiNote guiNote;
    private final NoteEditor editor;
    private final NoteHistory history;

    public NoteInputHandler(GuiNote guiNote, NoteEditor editor, NoteHistory history) {
        this.guiNote = guiNote;
        this.editor = editor;
        this.history = history;
    }

    public void handleKeyboardInput() throws IOException {
        if (Keyboard.getEventKeyState()) {
            if (GhostConfig.ChatFeatures.disableTwitchAtKey && Keyboard.getEventCharacter() == '@') {
                // 手动处理 @ 键以绕过 Twitch 功能
                editor.insertText("@");
                history.saveState(editor.getTextContent(), true);
                return;
            }
        }
        // 让父类处理其他按键，最终会调用下面的 keyTyped 方法
        guiNote.superHandleKeyboardInput();
    }

    public void keyTyped(char typedChar, int keyCode) throws IOException {
        if (keyCode == Keyboard.KEY_ESCAPE) {
            guiNote.getMc().displayGuiScreen(null);
            return;
        }

        if (GhostConfig.NoteTaking.enableAdvancedEditing && GuiScreen.isCtrlKeyDown()) {
            handleCtrlKeys(keyCode);
            return;
        }

        // 保存修改前的文本，用于之后判断文本是否真的发生了变化
        String originalText = editor.getTextContent();

        switch (keyCode) {
            case Keyboard.KEY_BACK:
                if (editor.hasSelection()) editor.deleteSelection();
                else editor.deleteCharBackwards();
                // 只有当文本确实被修改时，才保存历史记录
                if (!originalText.equals(editor.getTextContent())) {
                    history.saveState(editor.getTextContent(), true); // true表示这是一个可合并的打字操作
                }
                break;
            case Keyboard.KEY_DELETE:
                if (editor.hasSelection()) editor.deleteSelection();
                else editor.deleteCharForwards();
                if (!originalText.equals(editor.getTextContent())) {
                    history.saveState(editor.getTextContent(), true);
                }
                break;
            // 以下按键不修改文本，所以不需要保存历史
            case Keyboard.KEY_LEFT: editor.moveCursorBy(-1, GuiScreen.isShiftKeyDown()); break;
            case Keyboard.KEY_RIGHT: editor.moveCursorBy(1, GuiScreen.isShiftKeyDown()); break;
            case Keyboard.KEY_HOME: editor.setCursorPosition(0, GuiScreen.isShiftKeyDown()); break;
            case Keyboard.KEY_END: editor.setCursorPosition(editor.getTextContent().length(), GuiScreen.isShiftKeyDown()); break;
            
            case Keyboard.KEY_TAB:
                editor.insertText("    ");
                history.saveState(editor.getTextContent(), false); // false表示这是一个独立操作，不可合并
                break;
            
            case Keyboard.KEY_RETURN:
                editor.insertText("\n");
                history.saveState(editor.getTextContent(), false);
                break;

            default:
                if (typedChar == '§' || typedChar == '&' || net.minecraft.util.ChatAllowedCharacters.isAllowedCharacter(typedChar)) {
                    editor.insertText(Character.toString(typedChar));
                    history.saveState(editor.getTextContent(), true);
                }
        }
    }

    private void handleCtrlKeys(int keyCode) {
        switch (keyCode) {
            case Keyboard.KEY_A:
                editor.selectAll();
                break;
            case Keyboard.KEY_C:
                GuiScreen.setClipboardString(editor.getSelectedText());
                break;
            case Keyboard.KEY_X: // 剪切
                GuiScreen.setClipboardString(editor.getSelectedText());
                editor.deleteSelection();
                history.saveState(editor.getTextContent(), false);
                break;
            case Keyboard.KEY_V: // 粘贴
                String clipboard = GuiScreen.getClipboardString();
                editor.insertText(clipboard);
                history.saveState(editor.getTextContent(), false);
                break;
            case Keyboard.KEY_Z: // 撤销/重做
                if (!GuiScreen.isShiftKeyDown()) {
                    guiNote.handleUndo();
                } else {
                    guiNote.handleRedo();
                }
                break;
            case Keyboard.KEY_Y: // 重做
                guiNote.handleRedo();
                break;
        }
    }

    public void mouseClicked(int mouseX, int mouseY, int mouseButton) {
        if (mouseButton == 0 && guiNote.isMouseInTextArea(mouseX, mouseY)) {
            int charIndex = guiNote.getCharIndexAt(mouseX, mouseY);
            editor.setCursorPosition(charIndex, false);
            guiNote.resetCursorBlink();
        }
    }

    public void mouseClickMove(int mouseX, int mouseY) {
         if (guiNote.isMouseInTextArea(mouseX, mouseY)) {
            int charIndex = guiNote.getCharIndexAt(mouseX, mouseY);
            editor.setCursorPosition(charIndex, true);
            guiNote.resetCursorBlink();
        }
    }
}

features/note/GuiNote.java:
package com.zihaomc.ghost.features.note;

import com.zihaomc.ghost.LangUtil;
import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiButton;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.util.MathHelper;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.GL11;

import java.io.IOException;

/**
 * 游戏内笔记的GUI界面 (最终优化版)。
 * - 作为协调者，将状态管理、渲染和输入处理委托给专门的辅助类。
 * - 实现了类似Minecraft原生体验的可视化滚动条。
 * - 使用布局常量提高代码的可维护性。
 */
public class GuiNote extends GuiScreen {

    // --- 辅助类实例 ---
    private NoteEditor editor;
    private NoteRenderer renderer;
    private NoteInputHandler inputHandler;
    private NoteHistory history;

    // --- 布局常量 ---
    private static final int TEXT_AREA_WIDTH = 300;
    private static final int TEXT_AREA_HEIGHT_MARGIN_TOP = 40;
    // <<< 布局修复：底部边距应为50，以保证总高度正确 >>>
    private static final int TEXT_AREA_HEIGHT_MARGIN_BOTTOM = 50; 
    private static final int TEXT_PADDING = 4;
    private static final int SCROLLBAR_WIDTH = 6;

    // --- GUI 状态 ---
    private int textAreaX, textAreaY, textAreaWidth, textAreaHeight;
    private int scrollOffset = 0;
    private int maxScroll = 0;
    private int cursorBlink;

    // <<< 滚动条交互逻辑重构：新增变量 >>>
    private boolean isDraggingScrollbar = false;
    private float initialMouseY = -1; // 记录拖动开始时鼠标的Y坐标
    private int scrollOffsetAtDragStart = -1; // 记录拖动开始时滚动条的偏移量

    // --- 按钮 ---
    private GuiButton markdownToggleButton, colorToggleButton, ampersandToggleButton;
    private GuiButton helpButton, undoButton, redoButton;

    // --- 构造函数 ---
    public GuiNote() {
        this.editor = new NoteEditor();
        this.history = new NoteHistory();
    }

    // --- GUI 生命周期 ---
    @Override
    public void initGui() {
        super.initGui();
        Keyboard.enableRepeatEvents(true);

        // 使用常量进行布局，确保真正居中
        this.textAreaWidth = TEXT_AREA_WIDTH;
        this.textAreaX = this.width / 2 - this.textAreaWidth / 2;
        this.textAreaY = TEXT_AREA_HEIGHT_MARGIN_TOP;
        this.textAreaHeight = this.height - (TEXT_AREA_HEIGHT_MARGIN_TOP + TEXT_AREA_HEIGHT_MARGIN_BOTTOM);

        // 初始化渲染器和输入处理器
        this.renderer = new NoteRenderer(this.fontRendererObj, this.textAreaX, this.textAreaWidth - (TEXT_PADDING * 2) - SCROLLBAR_WIDTH);
        this.inputHandler = new NoteInputHandler(this, this.editor, this.history);

        if (this.editor.getTextContent().isEmpty()) {
            this.editor.setTextContent(NoteHistory.undoStack.isEmpty() ? NoteManager.loadNote() : NoteHistory.undoStack.peek());
        }
        
        if (!GhostConfig.GuiTweaks.fixGuiStateLossOnResize) {
            this.editor.setTextContent(NoteManager.loadNote());
        }

        this.renderer.updateLines(editor.getTextContent());
        this.editor.setCursorPosition(editor.getTextContent().length(), false);
        
        initButtons();
    }

    private void initButtons() {
        this.buttonList.clear();
        this.buttonList.add(new GuiButton(0, this.width / 2 - 100, this.height - 25, LangUtil.translate("ghost.gui.note.save_and_close")));

        int btnWidth = 120, btnHeight = 20;
        int leftX = textAreaX - btnWidth - 5;
        int rightX = textAreaX + textAreaWidth + 5;

        markdownToggleButton = new GuiButton(1, leftX, textAreaY, btnWidth, btnHeight, "");
        colorToggleButton = new GuiButton(2, leftX, textAreaY + btnHeight + 5, btnWidth, btnHeight, "");
        ampersandToggleButton = new GuiButton(6, leftX, textAreaY + (btnHeight + 5) * 2, btnWidth, btnHeight, "");
        helpButton = new GuiButton(3, rightX, textAreaY, 20, 20, "?");
        undoButton = new GuiButton(4, rightX, textAreaY + btnHeight + 5, 20, 20, "<");
        redoButton = new GuiButton(5, rightX + 20 + 2, textAreaY + btnHeight + 5, 20, 20, ">");
        
        this.buttonList.add(markdownToggleButton);
        this.buttonList.add(colorToggleButton);
        this.buttonList.add(ampersandToggleButton);
        this.buttonList.add(helpButton);
        this.buttonList.add(undoButton);
        this.buttonList.add(redoButton);

        updateButtonStates();
    }

    @Override
    public void onGuiClosed() {
        super.onGuiClosed();
        Keyboard.enableRepeatEvents(false);
        history.commitTypingAction(editor.getTextContent());
        NoteManager.saveNote(editor.getTextContent());
    }

    @Override
    public void updateScreen() {
        super.updateScreen();
        this.cursorBlink++;
        if (history.needsCommit()) {
            history.commitTypingAction(editor.getTextContent());
            updateUndoRedoButtonState();
        }
    }

    // --- 渲染 ---
    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks) {
        this.drawDefaultBackground();
        drawCenteredString(this.fontRendererObj, LangUtil.translate("ghost.gui.note.title"), this.width / 2, 20, 0xFFFFFF);
        drawRect(textAreaX - 1, textAreaY - 1, textAreaX + textAreaWidth + 1, textAreaY + textAreaHeight + 1, 0xFFC0C0C0);
        drawRect(textAreaX, textAreaY, textAreaX + textAreaWidth, textAreaY + textAreaHeight, 0xFF000000);
        
        this.maxScroll = Math.max(0, renderer.getRenderedLines().size() * fontRendererObj.FONT_HEIGHT - textAreaHeight + (TEXT_PADDING * 2));
        
        GL11.glEnable(GL11.GL_SCISSOR_TEST);
        int scaleFactor = new net.minecraft.client.gui.ScaledResolution(mc).getScaleFactor();
        GL11.glScissor(textAreaX * scaleFactor, mc.displayHeight - (textAreaY + textAreaHeight) * scaleFactor, textAreaWidth * scaleFactor, textAreaHeight * scaleFactor);
        
        int yPos = textAreaY + TEXT_PADDING - scrollOffset;
        for (int i = 0; i < renderer.getRenderedLines().size(); i++) {
            if (yPos + fontRendererObj.FONT_HEIGHT > textAreaY && yPos < textAreaY + textAreaHeight) {
                String line = renderer.getRenderedLines().get(i);
                renderer.drawStringAndCachePositions(line, textAreaX + TEXT_PADDING, yPos, 0xFFFFFF);
                if (editor.hasSelection()) {
                    renderer.drawSelection(yPos, editor.getSelectionStart(), editor.getSelectionEnd(), i);
                }
                if (i == renderer.findLineForPosition(editor.getCursorPosition()) && (cursorBlink / 6) % 2 == 0) {
                    renderer.drawCursor(yPos, editor.getCursorPosition());
                }
            }
            yPos += fontRendererObj.FONT_HEIGHT;
        }

        GL11.glDisable(GL11.GL_SCISSOR_TEST);
        
        drawScrollbar();
        
        drawCenteredString(fontRendererObj, LangUtil.translate("ghost.gui.note.scroll_hint"), this.width / 2, this.height - 35, 0xA0A0A0);
        super.drawScreen(mouseX, mouseY, partialTicks);
    }
    
    private void drawScrollbar() {
        if (maxScroll > 0) {
            int scrollbarX = this.textAreaX + this.textAreaWidth - SCROLLBAR_WIDTH;
            int scrollbarY = this.textAreaY;
            int scrollbarHeight = this.textAreaHeight;

            drawRect(scrollbarX, scrollbarY, scrollbarX + (SCROLLBAR_WIDTH - 1), scrollbarY + scrollbarHeight, 0x80000000);

            int handleHeight = Math.max(10, (int) ((float) scrollbarHeight * scrollbarHeight / (float) (maxScroll + scrollbarHeight)));
            int handleY = scrollbarY + (int) ((float) scrollOffset / (float) maxScroll * (scrollbarHeight - handleHeight));
            
            drawRect(scrollbarX, handleY, scrollbarX + (SCROLLBAR_WIDTH - 1), handleY + handleHeight, 0xFF808080);
            drawRect(scrollbarX, handleY, scrollbarX + (SCROLLBAR_WIDTH - 2), handleY + handleHeight - 1, 0xFFC0C0C0);
        }
    }

    // --- 输入处理 ---
    @Override
    public void handleKeyboardInput() throws IOException {
        inputHandler.handleKeyboardInput();
        renderer.updateLines(editor.getTextContent());
        ensureCursorVisible();
    }
    
    public void superHandleKeyboardInput() throws IOException {
        super.handleKeyboardInput();
    }

    @Override
    protected void keyTyped(char typedChar, int keyCode) throws IOException {
        inputHandler.keyTyped(typedChar, keyCode);
        renderer.updateLines(editor.getTextContent());
        ensureCursorVisible();
        updateUndoRedoButtonState();
    }

    // <<< 滚动条交互逻辑重构 >>>
    @Override
    protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException {
        if (mouseButton == 0 && maxScroll > 0) {
            int scrollbarX = this.textAreaX + this.textAreaWidth - SCROLLBAR_WIDTH;
            if (mouseX >= scrollbarX && mouseX < scrollbarX + SCROLLBAR_WIDTH && mouseY >= this.textAreaY && mouseY < this.textAreaY + this.textAreaHeight) {
                int scrollbarHeight = this.textAreaHeight;
                int handleHeight = Math.max(10, (int) ((float) scrollbarHeight * scrollbarHeight / (float) (maxScroll + scrollbarHeight)));
                int handleY = this.textAreaY + (int) ((float) scrollOffset / (float) maxScroll * (scrollbarHeight - handleHeight));

                if (mouseY >= handleY && mouseY < handleY + handleHeight) {
                    // 点击在滑块上，开始拖动
                    this.isDraggingScrollbar = true;
                    this.initialMouseY = mouseY;
                    this.scrollOffsetAtDragStart = this.scrollOffset;
                } else {
                    // 点击在轨道空白处，实现翻页
                    this.scrollOffset += (mouseY < handleY ? -1 : 1) * this.textAreaHeight;
                    this.scrollOffset = MathHelper.clamp_int(scrollOffset, 0, maxScroll);
                }
                return; // 消耗点击事件
            }
        }
        
        this.isDraggingScrollbar = false;
        super.mouseClicked(mouseX, mouseY, mouseButton);
        inputHandler.mouseClicked(mouseX, mouseY, mouseButton);
    }

    @Override
    protected void mouseClickMove(int mouseX, int mouseY, int clickedMouseButton, long timeSinceLastClick) {
        if (this.isDraggingScrollbar) {
            float deltaY = mouseY - this.initialMouseY;
            int scrollbarHeight = this.textAreaHeight;
            int handleHeight = Math.max(10, (int) ((float) scrollbarHeight * scrollbarHeight / (float) (maxScroll + scrollbarHeight)));
            float tractableHeight = scrollbarHeight - handleHeight;

            if (tractableHeight > 0) {
                float scrollRatio = (float) this.maxScroll / tractableHeight;
                this.scrollOffset = (int) (this.scrollOffsetAtDragStart + (deltaY * scrollRatio));
                this.scrollOffset = MathHelper.clamp_int(scrollOffset, 0, maxScroll);
            }
            return;
        }
        
        super.mouseClickMove(mouseX, mouseY, clickedMouseButton, timeSinceLastClick);
        inputHandler.mouseClickMove(mouseX, mouseY);
    }
    
    @Override
    protected void mouseReleased(int mouseX, int mouseY, int state) {
        super.mouseReleased(mouseX, mouseY, state);
        if (state == 0) {
            this.isDraggingScrollbar = false;
            this.initialMouseY = -1;
            this.scrollOffsetAtDragStart = -1;
        }
    }
    
    @Override
    public void handleMouseInput() throws IOException {
        super.handleMouseInput();
        int dWheel = Mouse.getEventDWheel();
        if (dWheel != 0) {
            int scrollAmount = fontRendererObj.FONT_HEIGHT * 3 * (dWheel < 0 ? 1 : -1);
            this.maxScroll = Math.max(0, renderer.getRenderedLines().size() * fontRendererObj.FONT_HEIGHT - textAreaHeight + (TEXT_PADDING * 2));
            scrollOffset = Math.max(0, Math.min(maxScroll, scrollOffset + scrollAmount));
        }
    }

    // ... (actionPerformed, handleUndo, handleRedo 等方法保持不变) ...
    @Override
    protected void actionPerformed(GuiButton button) throws IOException {
        if (!button.enabled) return;
        switch (button.id) {
            case 0: mc.displayGuiScreen(null); break;
            case 1: GhostConfig.setEnableMarkdownRendering(!GhostConfig.NoteTaking.enableMarkdownRendering); break;
            case 2: GhostConfig.setEnableColorRendering(!GhostConfig.NoteTaking.enableColorRendering); break;
            case 3: history.commitTypingAction(editor.getTextContent()); mc.displayGuiScreen(new GuiNoteHelp(this)); break;
            case 4: handleUndo(); break;
            case 5: handleRedo(); break;
            case 6: GhostConfig.setEnableAmpersandColorCodes(!GhostConfig.NoteTaking.enableAmpersandColorCodes); break;
        }
        updateButtonStates();
        super.actionPerformed(button);
    }
    
    public void handleUndo() {
        history.commitTypingAction(editor.getTextContent());
        String undoneText = history.undo();
        if (undoneText != null) {
            editor.setTextContent(undoneText);
            editor.setCursorPosition(undoneText.length(), false);
            renderer.updateLines(undoneText);
            updateUndoRedoButtonState();
        }
    }
    
    public void handleRedo() {
        history.commitTypingAction(editor.getTextContent());
        String redoneText = history.redo();
        if (redoneText != null) {
            editor.setTextContent(redoneText);
            editor.setCursorPosition(redoneText.length(), false);
            renderer.updateLines(redoneText);
            updateUndoRedoButtonState();
        }
    }

    // --- 辅助方法 ---
    public String getTextContent() { return this.editor.getTextContent(); }
    public void setTextContentAndInitialize(String newText) { if (newText != null) this.editor.setTextContent(newText); }
    public boolean isMouseInTextArea(int mouseX, int mouseY) {
        return mouseX >= textAreaX && mouseX <= textAreaX + textAreaWidth - (SCROLLBAR_WIDTH + 1) && mouseY >= textAreaY && mouseY <= textAreaY + textAreaHeight;
    }
    public int getCharIndexAt(int mouseX, int mouseY) {
        int relativeY = mouseY - this.textAreaY - TEXT_PADDING + this.scrollOffset;
        return renderer.getCharIndexAt(mouseX, mouseY, relativeY);
    }
    public void resetCursorBlink() { this.cursorBlink = 0; }
    public Minecraft getMc() { return this.mc; }
    
    private void ensureCursorVisible() {
        int lineIndex = renderer.findLineForPosition(editor.getCursorPosition());
        int cursorY = lineIndex * fontRendererObj.FONT_HEIGHT;
        if (cursorY < scrollOffset) {
            scrollOffset = cursorY;
        } else if (cursorY + fontRendererObj.FONT_HEIGHT > scrollOffset + textAreaHeight - (TEXT_PADDING * 2)) {
            scrollOffset = cursorY + fontRendererObj.FONT_HEIGHT - textAreaHeight + (TEXT_PADDING * 2);
        }
        this.maxScroll = Math.max(0, renderer.getRenderedLines().size() * fontRendererObj.FONT_HEIGHT - textAreaHeight + (TEXT_PADDING * 2));
        scrollOffset = Math.max(0, Math.min(maxScroll, scrollOffset));
    }
    
    private void updateButtonStates() {
        markdownToggleButton.displayString = LangUtil.translate("ghost.gui.note.markdown.prefix") + (GhostConfig.NoteTaking.enableMarkdownRendering ? LangUtil.translate("ghost.generic.enabled") : LangUtil.translate("ghost.generic.disabled"));
        colorToggleButton.displayString = LangUtil.translate("ghost.gui.note.color.prefix") + (GhostConfig.NoteTaking.enableColorRendering ? LangUtil.translate("ghost.generic.enabled") : LangUtil.translate("ghost.generic.disabled"));
        ampersandToggleButton.displayString = LangUtil.translate("ghost.gui.note.ampersand.prefix") + (GhostConfig.NoteTaking.enableAmpersandColorCodes ? LangUtil.translate("ghost.generic.enabled") : LangUtil.translate("ghost.generic.disabled"));
        updateUndoRedoButtonState();
    }
    
    private void updateUndoRedoButtonState() {
        undoButton.enabled = history.canUndo();
        redoButton.enabled = history.canRedo();
    }
}

features/note/NoteManager.java:
package com.zihaomc.ghost.features.note;

import com.zihaomc.ghost.utils.LogUtil;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.stream.Collectors;

/**
 * 管理游戏内笔记的文件加载与保存。
 */
public class NoteManager {

    private static final String CONFIG_DIR = "config/Ghost/";
    private static final String NOTE_FILE_NAME = "notes.txt";

    private static File getNoteFile() {
        File configDir = new File(CONFIG_DIR);
        if (!configDir.exists()) {
            configDir.mkdirs();
        }
        return new File(configDir, NOTE_FILE_NAME);
    }

    /**
     * 从文件加载笔记内容。
     * @return 笔记内容字符串。如果文件不存在或加载失败，则返回空字符串。
     */
    public static String loadNote() {
        File noteFile = getNoteFile();
        if (!noteFile.exists()) {
            return "";
        }

        try (BufferedReader reader = Files.newBufferedReader(noteFile.toPath(), StandardCharsets.UTF_8)) {
            String content = reader.lines().collect(Collectors.joining("\n"));
            // 当从文件加载新内容时，重置历史记录
            NoteHistory.resetWithContent(content);
            return content;
        } catch (IOException e) {
            LogUtil.error("log.error.note.loadFailed", e.getMessage());
            NoteHistory.resetWithContent(""); // 出错时也重置
            return "";
        }
    }

    /**
     * 将指定的文本保存到笔记文件。
     * @param text 要保存的文本内容。
     */
    public static void saveNote(String text) {
        if (text == null) return;

        File noteFile = getNoteFile();
        try (Writer writer = new OutputStreamWriter(new FileOutputStream(noteFile), StandardCharsets.UTF_8)) {
            writer.write(text);
        } catch (IOException e) {
            LogUtil.error("log.error.note.saveFailed", e.getMessage());
        }
    }
}

features/note/GuiNoteHelp.java:
package com.zihaomc.ghost.features.note;

import com.zihaomc.ghost.LangUtil;
import net.minecraft.client.gui.GuiButton;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.util.EnumChatFormatting;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * 笔记功能的帮助界面，用于显示 Markdown 和颜色代码的语法。
 */
public class GuiNoteHelp extends GuiScreen {

    private final GuiScreen parentScreen;
    private List<String> helpLines;

    private int scrollOffset = 0;
    private int maxScroll = 0;

    public GuiNoteHelp(GuiScreen parent) {
        this.parentScreen = parent;
    }

    @Override
    public void initGui() {
        super.initGui();
        // 将按钮文字从“完成”改为“返回”
        this.buttonList.add(new GuiButton(0, this.width / 2 - 100, this.height - 28, LangUtil.translate("ghost.gui.note.help.back")));
        
        populateHelpLines();
    }

    /**
     * 从语言文件加载并格式化所有帮助文本行。
     */
    private void populateHelpLines() {
        this.helpLines = new ArrayList<>();
        int wrapWidth = this.width - 50;

        helpLines.add(EnumChatFormatting.GOLD + LangUtil.translate("ghost.gui.note.help.title"));
        helpLines.add(""); // 空行

        // Markdown 部分
        helpLines.add(EnumChatFormatting.AQUA + LangUtil.translate("ghost.gui.note.help.markdown_header"));
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.headings.title") + " " + LangUtil.translate("ghost.gui.note.help.headings.desc"), wrapWidth));
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.bold.title") + " " + LangUtil.translate("ghost.gui.note.help.bold.desc"), wrapWidth));
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.italic.title") + " " + LangUtil.translate("ghost.gui.note.help.italic.desc"), wrapWidth));
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.strike.title") + " " + LangUtil.translate("ghost.gui.note.help.strike.desc"), wrapWidth));
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.list.title") + " " + LangUtil.translate("ghost.gui.note.help.list.desc"), wrapWidth));
        helpLines.add("");

        // 颜色代码部分
        helpLines.add(EnumChatFormatting.AQUA + LangUtil.translate("ghost.gui.note.help.color_header"));
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.color_desc"), wrapWidth));
        helpLines.add(LangUtil.translate("ghost.gui.note.help.color_example"));
        helpLines.add("§00 §11 §22 §33 §44 §55 §66 §77");
        helpLines.add("§88 §99 §aa §bb §cc §dd §ee §ff");
        helpLines.add("");
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.ampersand_desc"), wrapWidth));
        helpLines.add(LangUtil.translate("ghost.gui.note.help.ampersand_example"));
        helpLines.add("");

        // 格式代码部分
        helpLines.add(EnumChatFormatting.AQUA + LangUtil.translate("ghost.gui.note.help.format_header"));
        helpLines.addAll(this.fontRendererObj.listFormattedStringToWidth(LangUtil.translate("ghost.gui.note.help.format_desc"), wrapWidth));
        helpLines.add("§l" + LangUtil.translate("ghost.gui.note.help.format.bold") + " (§l&l§r), " + "§o" + LangUtil.translate("ghost.gui.note.help.format.italic") + " (§o&o§r)");
        helpLines.add("§n" + LangUtil.translate("ghost.gui.note.help.format.underline") + " (§n&n§r), " + "§m" + LangUtil.translate("ghost.gui.note.help.format.strike") + " (§m&m§r)");
        helpLines.add(LangUtil.translate("ghost.gui.note.help.format.reset") + " (§r&r§r)");
    }

    @Override
    protected void actionPerformed(GuiButton button) throws IOException {
        if (button.id == 0) {
            this.mc.displayGuiScreen(this.parentScreen);
        }
    }

    /**
     * 覆写键盘输入方法，以自定义 ESC 键的行为。
     */
    @Override
    protected void keyTyped(char typedChar, int keyCode) throws IOException {
        // 当按下 ESC 键 (keyCode 为 1) 时，返回到父界面 (笔记编辑器)
        if (keyCode == Keyboard.KEY_ESCAPE) {
            this.mc.displayGuiScreen(this.parentScreen);
        }
        // 对于其他按键，不执行任何操作，因为这是一个只读界面
    }

    @Override
    public void handleMouseInput() throws IOException {
        super.handleMouseInput();
        int dWheel = Mouse.getEventDWheel();
        if (dWheel != 0 && this.maxScroll > 0) {
            int scrollAmount = this.fontRendererObj.FONT_HEIGHT * 3 * (dWheel < 0 ? 1 : -1);
            this.scrollOffset = Math.max(0, Math.min(this.maxScroll, this.scrollOffset + scrollAmount));
        }
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks) {
        drawDefaultBackground();
        
        int yPos = 35 - this.scrollOffset;
        int xPos = 25;

        // 计算可滚动范围
        this.maxScroll = Math.max(0, (this.helpLines.size() + 2) * this.fontRendererObj.FONT_HEIGHT - this.height + 60);
        this.scrollOffset = Math.min(this.maxScroll, Math.max(0, this.scrollOffset));

        for (String line : this.helpLines) {
            this.fontRendererObj.drawStringWithShadow(line, xPos, yPos, 0xFFFFFF);
            yPos += this.fontRendererObj.FONT_HEIGHT;
        }

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}

features/note/NoteEditor.java:
package com.zihaomc.ghost.features.note;

import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.util.ChatAllowedCharacters;
import net.minecraft.util.MathHelper;

/**
 * 笔记编辑器核心，负责管理文本内容、光标和选区。
 * 这是一个纯粹的数据和逻辑模型，不涉及任何GUI渲染。
 */
public class NoteEditor {

    private String textContent = "";
    private int cursorPosition = 0;
    private int selectionAnchor = 0;

    public String getTextContent() { return textContent; }
    public int getCursorPosition() { return cursorPosition; }
    public int getSelectionAnchor() { return selectionAnchor; }
    
    public void setTextContent(String text) {
        this.textContent = text;
        this.cursorPosition = MathHelper.clamp_int(this.cursorPosition, 0, this.textContent.length());
        this.selectionAnchor = MathHelper.clamp_int(this.selectionAnchor, 0, this.textContent.length());
    }

    public void insertText(String textToInsert) {
        if (hasSelection()) deleteSelection();
        
        StringBuilder filtered = new StringBuilder();
        for (char c : textToInsert.toCharArray()) {
            if (c == '§' || c == '&' || ChatAllowedCharacters.isAllowedCharacter(c) || c == '\n') {
                filtered.append(c);
            }
        }
        String cleanText = filtered.toString();
        if (cleanText.isEmpty()) return;

        this.textContent = new StringBuilder(this.textContent).insert(this.cursorPosition, cleanText).toString();
        this.cursorPosition += cleanText.length();
        this.selectionAnchor = this.cursorPosition;
    }
    
    public void deleteCharBackwards() {
        if (cursorPosition > 0) {
            int numToDelete = 1;
            if (cursorPosition > 1) {
                char precedingChar = textContent.charAt(cursorPosition - 2);
                char lastChar = textContent.charAt(cursorPosition - 1);
                boolean isColorPrefix = precedingChar == '§' || (GhostConfig.NoteTaking.enableAmpersandColorCodes && precedingChar == '&');
                if (isColorPrefix && "0123456789abcdefklmnor".indexOf(Character.toLowerCase(lastChar)) != -1) {
                    numToDelete = 2;
                }
            }
            
            int start = this.cursorPosition - numToDelete;
            this.textContent = new StringBuilder(this.textContent).delete(start, this.cursorPosition).toString();
            setCursorPosition(start, false);
        }
    }
    
    /**
     * 新增：处理前进删除（DEL键）的逻辑
     */
    public void deleteCharForwards() {
        if (cursorPosition < textContent.length()) {
            int numToDelete = 1;
            if (cursorPosition < textContent.length() - 1) {
                char currentChar = textContent.charAt(cursorPosition);
                char nextChar = textContent.charAt(cursorPosition + 1);
                boolean isColorPrefix = currentChar == '§' || (GhostConfig.NoteTaking.enableAmpersandColorCodes && currentChar == '&');
                if (isColorPrefix && "0123456789abcdefklmnor".indexOf(Character.toLowerCase(nextChar)) != -1) {
                    numToDelete = 2;
                }
            }
            this.textContent = new StringBuilder(this.textContent).delete(this.cursorPosition, this.cursorPosition + numToDelete).toString();
            // 前进删除后，光标位置不变，但需要重置选区
            this.selectionAnchor = this.cursorPosition;
        }
    }
    
    public void deleteSelection() {
        if (!hasSelection()) return;
        int start = getSelectionStart();
        this.textContent = new StringBuilder(this.textContent).delete(start, getSelectionEnd()).toString();
        setCursorPosition(start, false);
    }
    
    public boolean hasSelection() { return this.cursorPosition != this.selectionAnchor; }
    public int getSelectionStart() { return Math.min(this.cursorPosition, this.selectionAnchor); }
    public int getSelectionEnd() { return Math.max(this.cursorPosition, this.selectionAnchor); }
    public String getSelectedText() { return hasSelection() ? this.textContent.substring(getSelectionStart(), getSelectionEnd()) : ""; }
    
    public void setCursorPosition(int newPosition, boolean extendSelection) {
        this.cursorPosition = MathHelper.clamp_int(newPosition, 0, this.textContent.length());
        if (!extendSelection) {
            this.selectionAnchor = this.cursorPosition;
        }
    }
    
    public void moveCursorBy(int amount, boolean extendSelection) {
        int newPos = this.cursorPosition;
        if (amount < 0) { // 向左
            newPos = Math.max(0, this.cursorPosition + amount);
            if (newPos > 0) {
                 char precedingChar = this.textContent.charAt(newPos - 1);
                 if (precedingChar == '§' || (GhostConfig.NoteTaking.enableAmpersandColorCodes && precedingChar == '&')) {
                    newPos = Math.max(0, newPos - 1);
                 }
            }
        } else if (amount > 0) { // 向右
            newPos = Math.min(this.textContent.length(), this.cursorPosition + amount);
            if (newPos < this.textContent.length() - 1) {
                char currentChar = this.textContent.charAt(newPos);
                if (currentChar == '§' || (GhostConfig.NoteTaking.enableAmpersandColorCodes && currentChar == '&')) {
                    newPos = Math.min(this.textContent.length(), newPos + 1);
                }
            }
        }
        setCursorPosition(newPos, extendSelection);
    }

    public void selectAll() {
        this.selectionAnchor = 0;
        this.cursorPosition = this.textContent.length();
    }
}

features/note/NoteHistory.java:
package com.zihaomc.ghost.features.note;

import java.util.ArrayDeque;
import java.util.Deque;

/**
 * 管理笔记的撤销/重做历史记录。
 */
public class NoteHistory {

    public static final Deque<String> undoStack = new ArrayDeque<>();
    public static final Deque<String> redoStack = new ArrayDeque<>();
    public static final int HISTORY_LIMIT = 100;

    private long lastEditTime = 0L;
    private static final long EDIT_MERGE_INTERVAL = 1000L; // 1秒
    private boolean isTypingAction = false;

    /**
     * 保存一个新的文本状态到历史记录中。
     * 这个方法应该在文本内容被修改 *之后* 调用。
     * @param newText 修改后的新文本内容。
     * @param isTyping 这次修改是否是一次打字输入（用于合并）。
     */
    public void saveState(String newText, boolean isTyping) {
        long now = System.currentTimeMillis();
        redoStack.clear();

        // 如果新文本与历史记录的最新状态相同，则不执行任何操作。
        if (!undoStack.isEmpty() && undoStack.peek().equals(newText)) {
            return;
        }

        // 检查此操作是否应与上一个操作合并（仅适用于连续打字）。
        if (isTyping && this.isTypingAction && (now - lastEditTime) < EDIT_MERGE_INTERVAL) {
            // 是一个合并的打字操作。我们用新文本替换掉栈顶的旧文本。
            if(!undoStack.isEmpty()) {
                undoStack.pop();
            }
            undoStack.push(newText);
        } else {
            // 是一个新的、独立的操作。将其作为新条目推入栈中。
            undoStack.push(newText);
            if (undoStack.size() > HISTORY_LIMIT) {
                undoStack.removeLast();
            }
        }

        // 更新状态以供下一次调用时使用。
        this.isTypingAction = isTyping;
        this.lastEditTime = now;
    }

    /**
     * 提交并结束当前的打字序列。
     * 这会确保下一次按键（无论是什么）都会创建一个新的历史记录条目。
     * @param currentText 当前文本，用于确保最终状态被正确记录。
     */
    public void commitTypingAction(String currentText) {
        // 通过将 isTypingAction 设置为 false，强制下一次 saveState 创建新条目。
        isTypingAction = false;
    }

    /**
     * 检查是否有可撤销的操作。
     * @return 如果可以撤销，则为 true。
     */
    public boolean canUndo() {
        // 如果栈中有多于一个状态（初始状态+至少一个修改），则可以撤销。
        return undoStack.size() > 1;
    }

    /**
     * 检查是否有可重做的操作。
     */
    public boolean canRedo() {
        return !redoStack.isEmpty();
    }
    
    /**
     * 执行撤销操作。
     * @return 撤销后的文本内容。
     */
    public String undo() {
        if (canUndo()) {
            String currentState = undoStack.pop();
            redoStack.push(currentState);
            isTypingAction = false; // 撤销操作会中断连续的打字输入
            return undoStack.peek();
        }
        return null;
    }

    /**
     * 执行重做操作。
     * @return 重做后的文本内容。
     */
    public String redo() {
        if (canRedo()) {
            String stateToRestore = redoStack.pop();
            undoStack.push(stateToRestore);
            isTypingAction = false; // 重做操作同样会中断连续的打字输入
            return stateToRestore;
        }
        return null;
    }
    
    /**
     * 检查是否需要因为超时而提交当前编辑。
     * （在新的逻辑中不再需要，但保留以防万一）
     * @return 如果需要提交，则返回true。
     */
    public boolean needsCommit() {
        return false;
    }
    
    /**
     * 从文件加载时，用加载的内容重置历史记录。
     * @param content 从文件加载的初始内容。
     */
    public static void resetWithContent(String content) {
        undoStack.clear();
        redoStack.clear();
        undoStack.push(content);
    }
}

features/note/NoteRenderer.java:
package com.zihaomc.ghost.features.note;

import com.google.common.collect.Lists;
import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.util.EnumChatFormatting;

import java.util.ArrayList;
import java.util.List;

/**
 * 负责所有与笔记GUI相关的渲染逻辑。
 * 包括文本换行、绘制、光标、选区等。
 */
public class NoteRenderer {

    private final FontRenderer fontRenderer;
    private final int wrappingWidth;
    private final int textAreaX;
    
    private List<String> renderedLines = new ArrayList<>();
    private int[] lineStartIndices = new int[0];
    private final List<Integer> charXPositions = new ArrayList<>();

    public NoteRenderer(FontRenderer fontRenderer, int textAreaX, int wrappingWidth) {
        this.fontRenderer = fontRenderer;
        this.textAreaX = textAreaX;
        this.wrappingWidth = wrappingWidth;
    }
    
    public List<String> getRenderedLines() { return renderedLines; }

    public void updateLines(String textContent) {
        if (textContent == null) return;
        
        List<String> newLines = new ArrayList<>();
        List<Integer> indices = new ArrayList<>();
        
        if (textContent.isEmpty()) {
            newLines.add("");
            indices.add(0);
        } else {
            int currentPos = 0;
            while (currentPos < textContent.length()) {
                indices.add(currentPos);
                String remaining = textContent.substring(currentPos);
                int lineLength = computeMaxCharsForWidth(remaining, wrappingWidth);

                if (lineLength <= 0 && currentPos < textContent.length()) {
                     lineLength = textContent.charAt(currentPos) == '\n' ? 0 : 1;
                }
                
                newLines.add(textContent.substring(currentPos, currentPos + lineLength));
                currentPos += lineLength;

                if (currentPos < textContent.length() && textContent.charAt(currentPos) == '\n') {
                    currentPos++;
                }
            }
        }
        
        if (newLines.isEmpty() || (textContent.length() > 0 && textContent.endsWith("\n"))) {
            newLines.add("");
            indices.add(textContent.length());
        }

        this.renderedLines = newLines;
        this.lineStartIndices = new int[indices.size() + 1];
        for (int i = 0; i < indices.size(); i++) {
            this.lineStartIndices[i] = indices.get(i);
        }
        this.lineStartIndices[indices.size()] = textContent.length();
    }

    private int computeMaxCharsForWidth(String text, int width) {
        if (text.isEmpty()) return 0;
        int manualNewlinePos = text.indexOf('\n');
        
        for (int i = 1; i <= text.length(); ++i) {
            if (manualNewlinePos != -1 && i > manualNewlinePos) {
                return manualNewlinePos;
            }
            String sub = text.substring(0, i);
            if (this.fontRenderer.getStringWidth(sub) > width) {
                return i - 1;
            }
        }
        return (manualNewlinePos != -1) ? manualNewlinePos : text.length();
    }
    
    public void drawStringAndCachePositions(String text, int x, int y, int color) {
        this.charXPositions.clear();
        float currentX = (float) x;
        String lineToRender = text;
        float scale = 1.0f;
        boolean isBoldTitle = false;

        if (GhostConfig.NoteTaking.enableMarkdownRendering) {
            if (lineToRender.startsWith("# ")) { scale = 1.5f; isBoldTitle = true; lineToRender = lineToRender.substring(2); this.charXPositions.add((int)currentX); this.charXPositions.add((int)currentX); }
            else if (lineToRender.startsWith("## ")) { scale = 1.2f; isBoldTitle = true; lineToRender = lineToRender.substring(3); this.charXPositions.add((int)currentX); this.charXPositions.add((int)currentX); this.charXPositions.add((int)currentX); }
            else if (lineToRender.startsWith("### ")) { isBoldTitle = true; lineToRender = lineToRender.substring(4); this.charXPositions.add((int)currentX); this.charXPositions.add((int)currentX); this.charXPositions.add((int)currentX); this.charXPositions.add((int)currentX); }
            else if (lineToRender.startsWith("- ") || lineToRender.startsWith("* ")) {
                String bullet = "• ";
                this.fontRenderer.drawStringWithShadow(bullet, currentX, (float)y, color);
                currentX += this.fontRenderer.getStringWidth(bullet);
                lineToRender = lineToRender.substring(2);
                this.charXPositions.add(x); this.charXPositions.add(x);
            }
        }

        GlStateManager.pushMatrix();
        GlStateManager.translate(currentX, y, 0);
        GlStateManager.scale(scale, scale, 1);
        GlStateManager.translate(-currentX, -y, 0);

        String activeFormat = "";
        boolean isBold = false, isItalic = false, isStrikethrough = false;
        
        for (int i = 0; i < lineToRender.length();) {
            this.charXPositions.add((int)Math.round(currentX));
            char currentChar = lineToRender.charAt(i);
            char nextChar = (i + 1 < lineToRender.length()) ? lineToRender.charAt(i + 1) : '\0';

            boolean isColorPrefix = (GhostConfig.NoteTaking.enableAmpersandColorCodes && currentChar == '&') || currentChar == '§';
            boolean isColorCode = GhostConfig.NoteTaking.enableColorRendering && isColorPrefix && "0123456789abcdefklmnor".indexOf(Character.toLowerCase(nextChar)) != -1;
            boolean isBoldMd = GhostConfig.NoteTaking.enableMarkdownRendering && currentChar == '*' && nextChar == '*';
            boolean isStrikeMd = GhostConfig.NoteTaking.enableMarkdownRendering && currentChar == '~' && nextChar == '~';
            boolean isItalicMd = GhostConfig.NoteTaking.enableMarkdownRendering && currentChar == '*';

            if (isColorCode) {
                if (Character.toLowerCase(nextChar) == 'r') activeFormat = "";
                else activeFormat += "§" + nextChar;
                i += 2;
                this.charXPositions.add((int)Math.round(currentX));
            } else if (isBoldMd) { isBold = !isBold; i += 2; this.charXPositions.add((int)Math.round(currentX)); }
            else if (isStrikeMd) { isStrikethrough = !isStrikethrough; i += 2; this.charXPositions.add((int)Math.round(currentX)); }
            else if (isItalicMd) { isItalic = !isItalic; i += 1; }
            else {
                StringBuilder finalFormat = new StringBuilder(activeFormat);
                if (isItalic) finalFormat.append(EnumChatFormatting.ITALIC);
                if (isBold || isBoldTitle) finalFormat.append(EnumChatFormatting.BOLD);
                if (isStrikethrough) finalFormat.append(EnumChatFormatting.STRIKETHROUGH);
                String formatPrefix = finalFormat.toString();
                String charToRenderWithFormat = formatPrefix + currentChar;

                this.fontRenderer.drawStringWithShadow(charToRenderWithFormat, currentX, (float)y, color);
                
                // --- BUG FIX ---
                // 为 § 和 & 符号赋予一个非零宽度，确保光标能够移动
                int charWidth;
                if (currentChar == '§' || (GhostConfig.NoteTaking.enableAmpersandColorCodes && currentChar == '&')) {
                    // 使用一个普通字符（如's'）的宽度作为其虚拟宽度
                    charWidth = this.fontRenderer.getCharWidth('s');
                } else {
                    charWidth = this.fontRenderer.getStringWidth(charToRenderWithFormat) - this.fontRenderer.getStringWidth(formatPrefix);
                }
                
                currentX += charWidth;
                i++;
            }
        }
        
        this.charXPositions.add((int)Math.round(currentX));
        GlStateManager.popMatrix();
    }
    
    public void drawCursor(int yPos, int cursorPosition) {
        int lineIndex = findLineForPosition(cursorPosition);
        if (lineIndex < 0 || lineIndex >= renderedLines.size()) return;
        
        int posInLine = cursorPosition - lineStartIndices[lineIndex];
        
        if (posInLine < charXPositions.size()) {
            int cursorX = charXPositions.get(posInLine);
            
            float scale = 1.0f;
            if (GhostConfig.NoteTaking.enableMarkdownRendering) {
                String line = renderedLines.get(lineIndex);
                if (line.startsWith("# ")) scale = 1.5f;
                else if (line.startsWith("## ")) scale = 1.2f;
            }
            float scaledFontHeight = this.fontRenderer.FONT_HEIGHT * scale;
            
            Tessellator tessellator = Tessellator.getInstance();
            WorldRenderer worldrenderer = tessellator.getWorldRenderer();
            GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
            GlStateManager.disableTexture2D();
            worldrenderer.begin(7, DefaultVertexFormats.POSITION);
            worldrenderer.pos((double)cursorX, (double)yPos - 1 + scaledFontHeight, 0.0D).endVertex();
            worldrenderer.pos((double)cursorX + 1, (double)yPos -1 + scaledFontHeight, 0.0D).endVertex();
            worldrenderer.pos((double)cursorX + 1, (double)yPos - 1, 0.0D).endVertex();
            worldrenderer.pos((double)cursorX, (double)yPos - 1, 0.0D).endVertex();
            tessellator.draw();
            GlStateManager.enableTexture2D();
        }
    }
    
    public void drawSelection(int yPos, int selectionStart, int selectionEnd, int lineIndex) {
        int lineStart = lineStartIndices[lineIndex];
        int lineEnd = (lineIndex + 1 < lineStartIndices.length) ? lineStartIndices[lineIndex+1] : Integer.MAX_VALUE;

        if (selectionEnd > lineStart && selectionStart < lineEnd) {
            int highlightStart = Math.max(selectionStart, lineStart) - lineStart;
            int highlightEnd = Math.min(selectionEnd, lineEnd) - lineStart;

            if (highlightStart < highlightEnd && highlightEnd <= charXPositions.size()) {
                int x1 = charXPositions.get(highlightStart);
                // 确保索引不越界
                int x2 = charXPositions.get(Math.min(highlightEnd, charXPositions.size() - 1));
                drawSelectionBox(x1, yPos, x2, yPos + fontRenderer.FONT_HEIGHT);
            }
        }
    }

    private void drawSelectionBox(int startX, int startY, int endX, int endY) {
        Tessellator tessellator = Tessellator.getInstance();
        WorldRenderer worldrenderer = tessellator.getWorldRenderer();
        GlStateManager.color(0.0F, 0.0F, 1.0F, 0.5F);
        GlStateManager.disableTexture2D();
        GlStateManager.enableColorLogic();
        GlStateManager.colorLogicOp(5387);
        worldrenderer.begin(7, DefaultVertexFormats.POSITION);
        worldrenderer.pos(startX, endY, 0.0D).endVertex();
        worldrenderer.pos(endX, endY, 0.0D).endVertex();
        worldrenderer.pos(endX, startY, 0.0D).endVertex();
        worldrenderer.pos(startX, startY, 0.0D).endVertex();
        tessellator.draw();
        GlStateManager.disableColorLogic();
        GlStateManager.enableTexture2D();
    }
    
    public int getCharIndexAt(int mouseX, int mouseY, int relativeY) {
        int lineIndex = Math.max(0, relativeY / fontRenderer.FONT_HEIGHT);
        if (lineIndex >= renderedLines.size()) return Integer.MAX_VALUE;
        
        drawStringAndCachePositions(renderedLines.get(lineIndex), textAreaX + 4, -9999, 0);
        
        int bestIndexInLine = 0;
        int minDistance = Integer.MAX_VALUE;
        for (int i = 0; i < charXPositions.size(); i++) {
            int distance = Math.abs(mouseX - charXPositions.get(i));
            if (distance < minDistance) {
                minDistance = distance;
                bestIndexInLine = i;
            }
        }
        return lineStartIndices[lineIndex] + bestIndexInLine;
    }
    
    public int findLineForPosition(int position) {
        if (lineStartIndices == null || lineStartIndices.length == 0) return 0;
        for (int i = 0; i < lineStartIndices.length - 1; i++) {
            if (position >= lineStartIndices[i] && position < lineStartIndices[i + 1]) {
                return i;
            }
        }
        return renderedLines.size() - 1;
    }
}

handlers/KeybindHandler.java:
package com.zihaomc.ghost.handlers;

import com.zihaomc.ghost.config.GhostConfig;
import com.zihaomc.ghost.features.automine.AutoMineHandler;
import com.zihaomc.ghost.features.note.GuiNote;
import com.zihaomc.ghost.features.translation.ItemTooltipTranslationHandler;
import com.zihaomc.ghost.utils.ColorFormatting;
import com.zihaomc.ghost.features.translation.TranslationUtil;
import com.zihaomc.ghost.LangUtil;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiChat;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.inventory.GuiContainer;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.util.ChatComponentText;
import net.minecraft.util.ChatComponentTranslation;
import net.minecraft.util.EnumChatFormatting;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.client.event.GuiScreenEvent;
import net.minecraftforge.fml.client.registry.ClientRegistry;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class KeybindHandler {

    public static KeyBinding toggleAutoSneak;
    public static KeyBinding togglePlayerESP;
    public static KeyBinding toggleBedrockMiner;
    public static KeyBinding translateItemKey;
    public static KeyBinding openNoteGui;
    public static KeyBinding toggleAutoMine; 

    private static String noteContentToRestore = null;

    public static void registerKeybinds() {
        String category = "key.ghost.category";

        toggleAutoSneak = new KeyBinding("key.ghost.toggleAutoSneak", Keyboard.KEY_NONE, category);
        togglePlayerESP = new KeyBinding("key.ghost.togglePlayerESP", Keyboard.KEY_NONE, category);
        toggleBedrockMiner = new KeyBinding("key.ghost.toggleBedrockMiner", Keyboard.KEY_NONE, category);
        translateItemKey = new KeyBinding("key.ghost.translateItem", Keyboard.KEY_T, category);
        openNoteGui = new KeyBinding("key.ghost.openNote", Keyboard.KEY_N, category);
        toggleAutoMine = new KeyBinding("key.ghost.toggleAutoMine", Keyboard.KEY_NONE, category);

        ClientRegistry.registerKeyBinding(toggleAutoSneak);
        ClientRegistry.registerKeyBinding(togglePlayerESP);
        ClientRegistry.registerKeyBinding(toggleBedrockMiner);
        ClientRegistry.registerKeyBinding(translateItemKey);
        ClientRegistry.registerKeyBinding(openNoteGui);
        ClientRegistry.registerKeyBinding(toggleAutoMine);
    }

    @SubscribeEvent
    public void onClientTick(TickEvent.ClientTickEvent event) {
        if (event.phase != TickEvent.Phase.END || Minecraft.getMinecraft().thePlayer == null) {
            return;
        }

        if (toggleAutoSneak != null && toggleAutoSneak.isPressed()) {
            boolean newState = !GhostConfig.AutoSneak.enableAutoSneakAtEdge;
            GhostConfig.setEnableAutoSneakAtEdge(newState);
            sendToggleMessage("ghost.keybind.toggle.autosneak", newState);
        }

        if (togglePlayerESP != null && togglePlayerESP.isPressed()) {
            boolean newState = !GhostConfig.PlayerESP.enablePlayerESP;
            GhostConfig.setEnablePlayerESP(newState);
            sendToggleMessage("ghost.keybind.toggle.playeresp", newState);
        }

        if (toggleBedrockMiner != null && toggleBedrockMiner.isPressed()) {
            boolean newState = !GhostConfig.BedrockMiner.enableBedrockMiner;
            GhostConfig.setEnableBedrockMiner(newState);
            sendToggleMessage("ghost.keybind.toggle.bedrockminer", newState);
        }
        
        if (openNoteGui != null && openNoteGui.isPressed()) {
            if (GhostConfig.NoteTaking.enableNoteFeature) {
                if (Minecraft.getMinecraft().currentScreen == null) {
                    Minecraft.getMinecraft().displayGuiScreen(new GuiNote());
                }
            }
        }

        if (toggleAutoMine != null && toggleAutoMine.isPressed()) {
            if (Minecraft.getMinecraft().currentScreen == null) {
                AutoMineHandler.toggle();
            }
        }

        if (Minecraft.getMinecraft().currentScreen == null && translateItemKey != null && translateItemKey.isPressed()) {
            if (translateItemKey.getKeyCode() == Minecraft.getMinecraft().gameSettings.keyBindChat.getKeyCode()) {
                Minecraft.getMinecraft().displayGuiScreen(new GuiChat());
            }
        }
    }

    @SubscribeEvent
    public void onGuiOpen(GuiOpenEvent event) {
        if (!GhostConfig.GuiTweaks.fixGuiStateLossOnResize) {
            return;
        }
        GuiScreen currentScreen = Minecraft.getMinecraft().currentScreen;
        if (currentScreen instanceof GuiNote) {
            noteContentToRestore = ((GuiNote) currentScreen).getTextContent();
        }
    }

    @SubscribeEvent
    public void onGuiInitPost(GuiScreenEvent.InitGuiEvent.Post event) {
        if (!GhostConfig.GuiTweaks.fixGuiStateLossOnResize) {
            return;
        }
        if (event.gui instanceof GuiNote) {
            if (noteContentToRestore != null) {
                ((GuiNote) event.gui).setTextContentAndInitialize(noteContentToRestore);
                noteContentToRestore = null;
            }
        }
    }

    @SubscribeEvent
    public void onGuiKeyboardInput(GuiScreenEvent.KeyboardInputEvent.Pre event) {
        if (event.gui instanceof GuiContainer) {
            if (translateItemKey != null && Keyboard.getEventKeyState() && Keyboard.getEventKey() == translateItemKey.getKeyCode()) {
                if (GuiScreen.isShiftKeyDown()) {
                    if (GuiScreen.isCtrlKeyDown()) {
                        handleClearAllItemTranslations();
                    } else {
                        handleClearItemTranslationPress();
                    }
                } else {
                    handleToggleOrTranslatePress();
                }
                event.setCanceled(true);
            }
        }
    }
    
    private void handleClearAllItemTranslations() {
        if (ItemTooltipTranslationHandler.translationCache.isEmpty() && ItemTooltipTranslationHandler.hiddenTranslations.isEmpty()) {
            return;
        }
    
        ItemTooltipTranslationHandler.translationCache.clear();
        ItemTooltipTranslationHandler.pendingTranslations.clear();
        ItemTooltipTranslationHandler.hiddenTranslations.clear();
    
        ChatComponentText message = new ChatComponentText(LangUtil.translate("ghost.cache.cleared_all"));
        message.getChatStyle().setColor(EnumChatFormatting.YELLOW);
        Minecraft.getMinecraft().thePlayer.addChatMessage(message);
    }

    private void handleClearItemTranslationPress() {
        String itemName = ItemTooltipTranslationHandler.lastHoveredItemName;
        if (itemName == null || itemName.trim().isEmpty()) {
            return;
        }
    
        boolean changed = false;
    
        if (ItemTooltipTranslationHandler.translationCache.remove(itemName) != null) {
            changed = true;
        }
        if (ItemTooltipTranslationHandler.hiddenTranslations.remove(itemName)) {
            changed = true;
        }
        if (ItemTooltipTranslationHandler.pendingTranslations.remove(itemName)) {
            changed = true;
        }
        
        if (changed) {
            ChatComponentText message = new ChatComponentText(LangUtil.translate("ghost.cache.cleared", itemName));
            message.getChatStyle().setColor(EnumChatFormatting.YELLOW);
            Minecraft.getMinecraft().thePlayer.addChatMessage(message);
        }
    }
    
    public void handleToggleOrTranslatePress() {
        if (!GhostConfig.Translation.enableItemTranslation && !GhostConfig.Translation.enableAutomaticTranslation) {
            return;
        }
        
        String originalFormattedName = ItemTooltipTranslationHandler.lastHoveredItemOriginalName;
        String unformattedName = ItemTooltipTranslationHandler.lastHoveredItemName;

        if (unformattedName == null || unformattedName.trim().isEmpty()) {
            return;
        }

        if (ItemTooltipTranslationHandler.translationCache.containsKey(unformattedName)) {
            if (ItemTooltipTranslationHandler.hiddenTranslations.contains(unformattedName)) {
                ItemTooltipTranslationHandler.hiddenTranslations.remove(unformattedName);
            } else {
                ItemTooltipTranslationHandler.hiddenTranslations.add(unformattedName);
            }
            return;
        }

        if (ItemTooltipTranslationHandler.pendingTranslations.contains(unformattedName)) {
            return;
        }

        List<String> unformattedLore = ItemTooltipTranslationHandler.lastHoveredItemLore;
        List<String> originalFormattedLore = ItemTooltipTranslationHandler.lastHoveredItemOriginalLore;
        if (unformattedLore == null || originalFormattedLore == null) return;
        
        StringBuilder plainTextBuilder = new StringBuilder(unformattedName);
        for (String line : unformattedLore) {
            plainTextBuilder.append("\n").append(line);
        }
        String textToTranslate = plainTextBuilder.toString();
        
        if (textToTranslate.trim().isEmpty()) {
            return;
        }
        
        ItemTooltipTranslationHandler.pendingTranslations.add(unformattedName);
        ChatComponentText requestMessage = new ChatComponentText(LangUtil.translate("ghost.tooltip.requestSent", unformattedName));
        requestMessage.getChatStyle().setColor(EnumChatFormatting.DARK_GRAY);
        Minecraft.getMinecraft().thePlayer.addChatMessage(requestMessage);

        // 使用线程池执行
        TranslationUtil.runAsynchronously(() -> {
            try {
                String translationResult = TranslationUtil.translate(textToTranslate);
                List<String> finalFormattedLines = new ArrayList<>();
                
                if (translationResult == null || translationResult.trim().isEmpty()) {
                    finalFormattedLines.add(EnumChatFormatting.RED + LangUtil.translate("ghost.error.translation.network"));
                } else if (translationResult.startsWith(TranslationUtil.ERROR_PREFIX)) {
                    String errorContent = translationResult.substring(TranslationUtil.ERROR_PREFIX.length());
                    finalFormattedLines.add(EnumChatFormatting.RED + errorContent);
                } else {
                    String[] translatedParts = translationResult.split("\n");
                    
                    String reformattedName = ColorFormatting.reapply(originalFormattedName, translatedParts[0]);
                    finalFormattedLines.add(reformattedName);
                    
                    int loreLinesToProcess = Math.min(originalFormattedLore.size(), translatedParts.length - 1);
                    for (int i = 0; i < loreLinesToProcess; i++) {
                        String originalLoreLine = originalFormattedLore.get(i);
                        String translatedLoreLine = translatedParts[i + 1];
                        finalFormattedLines.add(ColorFormatting.reapply(originalLoreLine, translatedLoreLine));
                    }
                    if (translatedParts.length - 1 > loreLinesToProcess) {
                        for (int i = loreLinesToProcess + 1; i < translatedParts.length; i++) {
                            finalFormattedLines.add(translatedParts[i]);
                        }
                    }
                }
                
                ItemTooltipTranslationHandler.translationCache.put(unformattedName, finalFormattedLines);

            } finally {
                ItemTooltipTranslationHandler.pendingTranslations.remove(unformattedName);
            }
        });
    }

    private void sendToggleMessage(String featureNameKey, boolean enabled) {
        String featureName = LangUtil.translate(featureNameKey);
        String statusText = LangUtil.translate(enabled ? "ghost.generic.enabled" : "ghost.generic.disabled");
        
        EnumChatFormatting statusColor = enabled ? EnumChatFormatting.GREEN : EnumChatFormatting.RED;
        ChatComponentText statusComponent = new ChatComponentText(statusText);
        statusComponent.getChatStyle().setColor(statusColor);
        
        ChatComponentText message = new ChatComponentText("");
        ChatComponentText prefix = new ChatComponentText(LangUtil.translate("ghost.generic.prefix.default"));
        prefix.getChatStyle().setColor(EnumChatFormatting.AQUA);
        
        ChatComponentTranslation content = new ChatComponentTranslation(
            "ghost.generic.toggle.feedback",
            featureName,
            statusComponent
        );
        
        message.appendSibling(prefix);
        message.appendSibling(content);
        Minecraft.getMinecraft().thePlayer.addChatMessage(message);
    }
}

utils/RotationUtil.java:
package com.zihaomc.ghost.utils;

import com.zihaomc.ghost.config.GhostConfig;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.util.*;

import java.util.List;

/**
 * 封装所有与玩家视角旋转和可见性检查相关的数学计算。
 */
public class RotationUtil {

    private static final Minecraft mc = Minecraft.getMinecraft();
    private static final float ROTATION_TOLERANCE = 0.5f;

    /**
     * 计算玩家眼睛到指定空间点所需的 Yaw 和 Pitch。
     * @param target 目标三维向量
     * @return float 数组, [0] = yaw, [1] = pitch
     */
    public static float[] getRotations(Vec3 target) {
        Vec3 playerEyePos = mc.thePlayer.getPositionEyes(1.0F);

        double deltaX = target.xCoord - playerEyePos.xCoord;
        double deltaY = target.yCoord - playerEyePos.yCoord;
        double deltaZ = target.zCoord - playerEyePos.zCoord;

        double distance = MathHelper.sqrt_double(deltaX * deltaX + deltaZ * deltaZ);

        float yaw = (float) (MathHelper.atan2(deltaZ, deltaX) * 180.0D / Math.PI) - 90.0F;
        float pitch = (float) (-(MathHelper.atan2(deltaY, distance) * 180.0D / Math.PI));

        return new float[]{
                MathHelper.wrapAngleTo180_float(yaw),
                MathHelper.wrapAngleTo180_float(pitch)
        };
    }

    /**
     * 计算朝向目标视角平滑移动一步后的新视角。
     * @param speed 基础旋转速度 (度/tick)
     * @return float 数组, [0] = newYaw, [1] = newPitch
     */
    public static float[] getSmoothRotations(float currentYaw, float currentPitch, float targetYaw, float targetPitch, float speed) {
        float finalSpeed = speed;

        // 如果开启了随机速度，则计算一个波动的速度
        if (GhostConfig.AutoMine.enableRandomRotationSpeed) {
            double variability = GhostConfig.AutoMine.rotationSpeedVariability;
            // 计算一个在 [-variability, +variability] 范围内的随机偏移量
            double randomOffset = (Math.random() - 0.5) * 2.0 * variability;
            finalSpeed += randomOffset;
            // 确保速度不会低于一个最小值，防止旋转过慢或停止
            finalSpeed = Math.max(1.0f, finalSpeed);
        }

        float yawDifference = MathHelper.wrapAngleTo180_float(targetYaw - currentYaw);
        float pitchDifference = MathHelper.wrapAngleTo180_float(targetPitch - currentPitch);

        float yawStep = MathHelper.clamp_float(yawDifference, -finalSpeed, finalSpeed);
        float pitchStep = MathHelper.clamp_float(pitchDifference, -finalSpeed, finalSpeed);

        float newYaw = currentYaw + yawStep;
        float newPitch = currentPitch + pitchStep;

        newPitch = MathHelper.clamp_float(newPitch, -90.0F, 90.0F);

        return new float[]{newYaw, newPitch};
    }

    /**
     * 检查当前视角是否已足够接近目标视角。
     */
    public static boolean isRotationComplete(float currentYaw, float currentPitch, float targetYaw, float targetPitch) {
        float yawDiff = Math.abs(MathHelper.wrapAngleTo180_float(currentYaw - targetYaw));
        float pitchDiff = Math.abs(MathHelper.wrapAngleTo180_float(currentPitch - targetPitch));
        return yawDiff < ROTATION_TOLERANCE && pitchDiff < ROTATION_TOLERANCE;
    }
    
    /**
     * 智能寻找方块上的最佳可视瞄准点。
     * 优先检查中心点，如果中心点不可见，则检查所有面的中心点，并返回与当前准星夹角最小的那个。
     *
     * @param pos 要检查的方块位置
     * @return 如果找到可见点，返回该点的 Vec3 坐标；否则返回 null。
     */
    public static Vec3 getClosestVisiblePoint(BlockPos pos) {
        if (mc.thePlayer == null || mc.theWorld == null) {
            return null;
        }

        Vec3 eyes = mc.thePlayer.getPositionEyes(1.0F);
        
        // 1. 优先检查方块的精确中心点
        Vec3 centerPoint = new Vec3(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);
        // 这里增加了对实体的检测
        if (isPointVisible(eyes, centerPoint, pos) && !isObstructedByEntity(eyes, centerPoint)) {
            return centerPoint; 
        }

        // 2. 如果中心点被遮挡，则遍历所有面寻找替代点
        Vec3 bestPoint = null;
        double minAngleDiff = Double.MAX_VALUE;

        for (EnumFacing facing : EnumFacing.values()) {
            Vec3 pointOnFace = new Vec3(
                pos.getX() + 0.5 + facing.getFrontOffsetX() * 0.5,
                pos.getY() + 0.5 + facing.getFrontOffsetY() * 0.5,
                pos.getZ() + 0.5 + facing.getFrontOffsetZ() * 0.5
            );

            // 这里也增加了对实体的检测
            if (isPointVisible(eyes, pointOnFace, pos) && !isObstructedByEntity(eyes, pointOnFace)) {
                float[] rotations = getRotations(pointOnFace);
                float yawDiff = Math.abs(MathHelper.wrapAngleTo180_float(mc.thePlayer.rotationYaw - rotations[0]));
                float pitchDiff = Math.abs(MathHelper.wrapAngleTo180_float(mc.thePlayer.rotationPitch - rotations[1]));
                double angleDiff = yawDiff * yawDiff + pitchDiff * pitchDiff; // 使用平方和来比较，避免开方

                if (angleDiff < minAngleDiff) {
                    minAngleDiff = angleDiff;
                    bestPoint = pointOnFace;
                }
            }
        }
        
        return bestPoint;
    }

    /**
     * 检查点是否在方块层面上可见（不考虑实体）。
     */
    private static boolean isPointVisible(Vec3 eyes, Vec3 target, BlockPos targetBlockPos) {
        MovingObjectPosition rayTrace = mc.theWorld.rayTraceBlocks(eyes, target, false, true, false);
        return rayTrace == null || rayTrace.typeOfHit == MovingObjectPosition.MovingObjectType.MISS || rayTrace.getBlockPos().equals(targetBlockPos);
    }

    /**
     * 检查视线是否被实体阻挡。
     */
    private static boolean isObstructedByEntity(Vec3 start, Vec3 end) {
        Vec3 direction = end.subtract(start);
        
        // 获取射线路径包围盒内的所有实体
        List<Entity> entities = mc.theWorld.getEntitiesWithinAABBExcludingEntity(mc.thePlayer, 
            mc.thePlayer.getEntityBoundingBox().addCoord(direction.xCoord, direction.yCoord, direction.zCoord).expand(1.0, 1.0, 1.0));
            
        for (Entity entity : entities) {
            if (entity.canBeCollidedWith()) {
                float borderSize = entity.getCollisionBorderSize();
                AxisAlignedBB entityBB = entity.getEntityBoundingBox().expand(borderSize, borderSize, borderSize);
                // 检查射线是否与实体包围盒相交
                MovingObjectPosition intercept = entityBB.calculateIntercept(start, end);
                if (intercept != null) {
                    return true;
                }
            }
        }
        return false;
    }
}

utils/ColorFormatting.java:
package com.zihaomc.ghost.utils;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 一个用于处理 Minecraft 颜色和格式代码的工具类。
 * 主要功能是：
 * 1. 将一个带格式的字符串解析成一系列带有颜色/格式的“片段”(Segment)。
 * 2. 将这些从原始字符串中解析出的格式，按比例应用到一个新的、不同长度的目标字符串上。
 */
public class ColorFormatting {

    /** 匹配 Minecraft 颜色/格式代码的正则表达式 (e.g., §c, §l) */
    private static final Pattern FORMATTING_CODE_PATTERN = Pattern.compile("(?i)§[0-9A-FK-OR]");

    /**
     * 代表一个带有特定格式的文本片段。
     */
    private static class ColorSegment {
        /** 这个片段的颜色/格式代码，例如 "§c§l" */
        final String format;
        /** 这个片段的纯文本内容 */
        final String text;

        ColorSegment(String format, String text) {
            this.format = format;
            this.text = text;
        }
    }

    /**
     * 将一个带格式的 Minecraft 字符串解析成一个 ColorSegment 列表。
     * @param input 原始的、带格式的字符串。
     * @return 一个 ColorSegment 对象的列表。
     */
    private static List<ColorSegment> parse(String input) {
        List<ColorSegment> segments = new ArrayList<>();
        Matcher matcher = FORMATTING_CODE_PATTERN.matcher(input);

        String currentFormat = "";
        int lastMatchEnd = 0;

        // 遍历所有找到的格式代码
        while (matcher.find()) {
            int matchStart = matcher.start();
            
            // 如果在当前匹配和上一个匹配之间有文本，将其作为一个片段添加
            if (matchStart > lastMatchEnd) {
                segments.add(new ColorSegment(currentFormat, input.substring(lastMatchEnd, matchStart)));
            }
            
            // 更新当前格式
            String code = matcher.group();
            char formatChar = Character.toLowerCase(code.charAt(1));
            // 如果是重置代码 'r'，则清空当前所有格式
            if (formatChar == 'r') {
                currentFormat = "";
            } 
            // 如果是颜色代码，则替换掉之前的颜色代码，保留格式代码
            else if ("0123456789abcdef".indexOf(formatChar) != -1) {
                // Java 8 兼容的写法：遍历 currentFormat，只保留非颜色代码的格式
                StringBuilder newFormat = new StringBuilder();
                Matcher existingFormatMatcher = FORMATTING_CODE_PATTERN.matcher(currentFormat);
                while(existingFormatMatcher.find()) {
                    String existingCode = existingFormatMatcher.group();
                    char existingChar = Character.toLowerCase(existingCode.charAt(1));
                    // 只保留样式代码 (k, l, m, n, o, r)，丢弃颜色代码
                    if ("klmnor".indexOf(existingChar) != -1) {
                        newFormat.append(existingCode);
                    }
                }
                currentFormat = newFormat.toString() + code;
            } 
            // 否则是格式代码 (k, l, m, n, o)，直接添加
            else {
                currentFormat += code;
            }
            
            lastMatchEnd = matcher.end();
        }

        // 添加最后一个片段（最后一个格式代码到字符串末尾的文本）
        if (lastMatchEnd < input.length()) {
            segments.add(new ColorSegment(currentFormat, input.substring(lastMatchEnd)));
        }

        return segments;
    }

    /**
     * 核心方法：将源字符串的颜色格式，按比例应用到目标字符串上。
     * @param sourceFormatted 原始的、带格式的源字符串 (e.g., "§eDiamond §aBlock")
     * @param targetUnformatted 翻译后的、不带格式的目标字符串 (e.g., "钻石块")
     * @return 一个新的、将格式应用到目标字符串上的结果 (e.g., "§e钻石§a块")
     */
    public static String reapply(String sourceFormatted, String targetUnformatted) {
        if (sourceFormatted == null || targetUnformatted == null || targetUnformatted.isEmpty()) {
            return targetUnformatted;
        }

        List<ColorSegment> sourceSegments = parse(sourceFormatted);
        if (sourceSegments.isEmpty()) {
            return targetUnformatted;
        }
        
        // 计算原始纯文本的总长度
        int sourceUnformattedLength = 0;
        for (ColorSegment s : sourceSegments) {
            sourceUnformattedLength += s.text.length();
        }

        if (sourceUnformattedLength == 0) {
            // 如果原始文本没有内容，只保留格式
            return sourceSegments.get(0).format + targetUnformatted;
        }
        
        StringBuilder result = new StringBuilder();
        int targetIndex = 0;

        for (int i = 0; i < sourceSegments.size(); i++) {
            ColorSegment segment = sourceSegments.get(i);
            result.append(segment.format);
            
            // 计算这个片段在目标字符串中应该占据的长度
            // 使用浮点数计算以获得更精确的比例
            double proportion = (double) segment.text.length() / sourceUnformattedLength;
            int segmentLengthInTarget = (int) Math.round(proportion * targetUnformatted.length());

            // 特殊处理：确保最后一个片段能“吃掉”所有剩余的字符，以防浮点数舍入误差
            if (i == sourceSegments.size() - 1) {
                segmentLengthInTarget = targetUnformatted.length() - targetIndex;
            }
            
            int endIndex = Math.min(targetIndex + segmentLengthInTarget, targetUnformatted.length());
            
            if (targetIndex < endIndex) {
                result.append(targetUnformatted.substring(targetIndex, endIndex));
            }

            targetIndex = endIndex;
        }

        return result.toString();
    }
}

utils/LogUtil.java:
package com.zihaomc.ghost.utils;

import com.zihaomc.ghost.Ghost;
import com.zihaomc.ghost.LangUtil;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;

/**
 * 统一的日志记录工具类。
 * 能够区分客户端和服务端，以安全的方式输出日志。
 * 在客户端，它会尝试使用 LangUtil 进行翻译。
 * 在服务端，它会打印出语言键 (Key)，以便于调试且不会导致崩溃。
 */
public class LogUtil {

    private static void log(String level, String key, Object... args) {
        String message;
        // 检查当前是否在客户端，以便安全地使用 LangUtil
        if (FMLCommonHandler.instance().getEffectiveSide() == Side.CLIENT) {
            try {
                // 在客户端，格式化翻译后的字符串
                message = LangUtil.translate(key, args);
            } catch (Exception e) {
                // 如果 LangUtil 失败，则回退到打印键名
                message = key + " (Translation failed: " + e.getMessage() + ")";
            }
        } else {
            // 在服务端，LangUtil 不可用。我们只打印键名和参数。
            StringBuilder serverMessage = new StringBuilder(key);
            if (args.length > 0) {
                serverMessage.append(" [");
                for (int i = 0; i < args.length; i++) {
                    serverMessage.append(args[i]);
                    if (i < args.length - 1) {
                        serverMessage.append(", ");
                    }
                }
                serverMessage.append("]");
            }
            message = serverMessage.toString();
        }

        // 统一为最终要输出的消息添加 [Ghost] 前缀
        String finalMessage = "[Ghost] " + message;

        switch (level.toUpperCase()) {
            case "DEBUG":
                Ghost.logger.debug(finalMessage);
                break;
            case "WARN":
                Ghost.logger.warn(finalMessage);
                break;
            case "ERROR":
                Ghost.logger.error(finalMessage);
                break;
            case "INFO":
            default:
                Ghost.logger.info(finalMessage);
                break;
        }
    }

    /**
     * 用于直接打印原始调试字符串，不经过翻译。
     * @param message 要打印的原始消息。
     */
    public static void debugRaw(String message) {
        // TODO: 未来可以添加一个配置项来完全禁用 DEBUG 日志
        Ghost.logger.info("[AutoMine-Debug] " + message);
    }

    public static void info(String key, Object... args) {
        log("INFO", key, args);
    }

    public static void debug(String key, Object... args) {
        // TODO: 未来可以添加一个配置项来完全禁用 DEBUG 日志
        log("DEBUG", key, args);
    }

    public static void warn(String key, Object... args) {
        log("WARN", key, args);
    }

    public static void error(String key, Object... args) {
        log("ERROR", key, args);
    }
    
    /**
     * 用于打印异常堆栈的特殊方法。
     * @param key 描述错误的语言键
     * @param throwable 异常对象
     * @param args 格式化参数
     */
    public static void printStackTrace(String key, Throwable throwable, Object... args) {
        String message;
        if (FMLCommonHandler.instance().getEffectiveSide() == Side.CLIENT) {
            message = LangUtil.translate(key, args);
        } else {
            message = key;
        }
        
        // 同样为异常信息添加前缀
        String finalMessage = "[Ghost] " + message;
        Ghost.logger.error(finalMessage, throwable);
    }
}

